<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Blowoff Top Detector â€” Hybrid AI + Phase & PIPPIN Similarity</title>
<style>
  :root{
    --bg:#07101a;
    --card:#0b1220;
    --muted:#9fb3cc;
    --accent:#2dd4bf;
    --danger:#ff7b7b;
    --glass: rgba(255,255,255,0.03);
  }
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:#e6eef8;margin:12px}
  .card-panel{background:var(--card);border:1px solid #172033;padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,.6);margin-bottom:14px}
  h1{margin:0;font-size:18px}
  .controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;align-items:center}
  label{font-size:13px;color:var(--muted)}
  input,select{background:#071722;border:1px solid #243241;color:#e6eef8;padding:6px;border-radius:6px}
  button{background:#1f6feb;border:none;color:white;padding:8px 10px;border-radius:6px;cursor:pointer}
  button.alt{background:#2b3947}
  .status{margin-top:8px;color:var(--muted);font-size:13px;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .progress{height:8px;background:#05101a;border-radius:4px;margin-top:8px;overflow:hidden;flex:1}
  .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#60a5fa);width:0%}
  .countdown{font-weight:700;color:#cfe8ff}
  .mutedBadge{background:var(--glass);color:var(--muted);padding:4px 8px;border-radius:8px;font-size:12px}
  table{width:100%;border-collapse:collapse;margin-top:12px;font-size:13px;min-width:720px}
  th,td{padding:8px 10px;border-bottom:1px dashed #122331;text-align:left;vertical-align:top}
  th{color:var(--muted);font-size:12px}
  .green{color:#66f9a1}
  .red{color:var(--danger)}
  .small{font-size:12px;color:var(--muted)}
  .badge{display:inline-block;padding:4px 8px;border-radius:12px;background:#0f2430;color:#bfeee1;font-size:12px}
  .blink{animation: blinkHighlight 1.8s ease-in-out 3}
  @keyframes blinkHighlight {0%{box-shadow:0 0 0 rgba(255,80,80,0)}50%{box-shadow:0 0 12px rgba(255,80,80,0.35)}100%{box-shadow:0 0 0 rgba(255,80,80,0)}}
  /* mobile card UI */
  #tableView{display:block} #cardView{display:none}
  @media (max-width:680px){
    #tableView{display:none} #cardView{display:block}
    .coinCard{background:var(--card);border:1px solid #172033;padding:12px;border-radius:10px;margin-bottom:10px}
    .coinRow1{display:flex;justify-content:space-between;align-items:center}
    .coinSymbol{font-size:16px;font-weight:700}
    .coinScore{font-size:14px;font-weight:700}
    .blowBadge{background:#ff4d4d;padding:4px 8px;border-radius:6px;color:white;font-size:12px;font-weight:700}
    .potBadge{background:#ffd966;padding:4px 8px;border-radius:6px;color:black;font-size:12px;font-weight:700}
    .sigList{margin-top:8px;font-size:13px;line-height:18px;color:#cfe8ff}
  }
  footer.small{margin-top:12px;color:var(--muted);font-size:12px}
  .phaseTag{display:inline-block;padding:4px 8px;border-radius:8px;font-weight:700;font-size:12px;margin-left:6px}
</style>
</head>
<body>
<div class="card-panel">
  <h1>Blowoff Top Detector â€” Hybrid AI + Phase & PIPPIN Similarity</h1>
  <div class="small" style="margin-top:6px;color:var(--muted)">
    Scans top N Binance USDT perpetual futures by 24h change. Detects blowoff severity, classifies phase (7-step lifecycle), and computes similarity to live PIPPIN structure. Uses auto-pause safety for API rate limits.
  </div>

  <div class="controls">
    <label>Prefilter (top by 24h) <input id="prefilter" type="number" value="30" min="5" max="60"/></label>
    <label>Delay (ms) <input id="delay" type="number" value="450" min="50" max="2000"/></label>
    <label>Refresh (sec) <input id="interval" type="number" value="60" min="10" max="3600"/></label>
    <label>Score â‰¥ <input id="threshold" type="number" value="4" min="1" max="8"/></label>
    <button id="startBtn">Start</button>
    <button id="stopBtn" class="alt" disabled>Stop</button>
    <button id="oneShot" class="alt">Run Once</button>
  </div>

  <div class="status">
    <div id="message">Ready. Run from a local server to avoid CORS (e.g., <code>python -m http.server</code>).</div>
    <div class="progress"><i id="bar"></i></div>
    <div class="countdown" id="countdown">Next scan in: -</div>
    <div class="mutedBadge" id="safetyStatus">Safety OK</div>
  </div>

  <div id="tableView"></div>
  <div id="cardView"></div>

  <div id="debug" class="small" style="margin-top:8px"></div>
</div>

<script>
/* ======================================================
   Hybrid Blowoff Detector upgrades:
   - Phase detector (7 phases)
   - PIPPIN similarity (dynamic: compares to live PIPPIN)
   - All previous features retained
   ====================================================== */

const API_BASE = 'https://fapi.binance.com';

// ---------- Blacklist ----------
const blacklist = [
  "ALPACAUSDT","BNXUSDT","ALPHAUSDT","OCEANUSDT","DGBUSDT",
  "AGIXUSDT","LINAUSDT","LOKAUSDT","KEYUSDT","MDTUSDT",
  "LOOMUSDT","RENUSDT","OMNIUSDT","SLERFUSDT","STMXUSDT",
  "UXLINKUSDT","BSWUSDT","NEIROETHUSDT","VIDTUSDT","TROYUSDT",
  "BAKEUSDT","AMBUSDT","MEMEFIUSDT","NULSUSDT","HIFIUSDT",
  "LEVERUSDT","XEMUSDT","STRAXUSDT","COMBOUSDT"
];

// ---------- DOM ----------
const el = {
  prefilter: document.getElementById('prefilter'),
  delay: document.getElementById('delay'),
  interval: document.getElementById('interval'),
  threshold: document.getElementById('threshold'),
  startBtn: document.getElementById('startBtn'),
  stopBtn: document.getElementById('stopBtn'),
  oneShot: document.getElementById('oneShot'),
  message: document.getElementById('message'),
  bar: document.getElementById('bar'),
  tableView: document.getElementById('tableView'),
  cardView: document.getElementById('cardView'),
  debug: document.getElementById('debug'),
  safetyStatus: document.getElementById('safetyStatus'),
  countdown: document.getElementById('countdown')
};

// ---------- State ----------
let running=false, queue=[], totalTasks=0, doneTasks=0, autoTimer=null, countdownTimer=null;
let requestsThisWindow=0, windowStart=Date.now(), SAFETY_WINDOW_MS=60000, SAFETY_MAX=900, SAFETY_PAUSE=30;
let prevBlowoffSet = new Set();

// ---------- Utils ----------
function delay(ms){ return new Promise(r=>setTimeout(r,ms)); }
function sma(arr, n){ if(!arr || arr.length < n) return null; let sum=0; for(let i=arr.length-n;i<arr.length;i++) sum+=arr[i]; return sum/n; }
function ema(arr, period){ if(!arr || arr.length===0) return null; const k=2/(period+1); let e=arr[0]; for(let i=1;i<arr.length;i++) e = arr[i]*k + e*(1-k); return e; }
function rsiFromCloses(closes, period=14){ if(!closes || closes.length<=period) return null; let gains=0, losses=0; for(let i=closes.length-period;i<closes.length;i++){ const d=closes[i]-closes[i-1]; if(d>0) gains+=d; else losses+=Math.abs(d);} const avgGain=gains/period, avgLoss=losses/period; if(avgLoss===0) return 100; const rs=avgGain/avgLoss; return 100 - (100/(1+rs)); }
function pct(a,b){ if(b===0) return 0; return ((a-b)/b)*100; }
function dot(a,b){let s=0; for(let i=0;i<a.length;i++) s+=a[i]*b[i]; return s;}
function norm(a){return Math.sqrt(a.reduce((s,x)=>s+x*x,0));}
function cosineSim(a,b){ const n=dot(a,b); const d=norm(a)*norm(b); return d===0?0: n/d; }

// ---------- Safe fetch wrapper (count requests) ----------
async function safeFetch(url){
  if(!running) throw new Error('Not running');
  requestsThisWindow++;
  const r = await fetch(url);
  if(!r.ok) throw new Error('HTTP '+r.status);
  return r.json();
}

// ---------- Safety ----------
function resetWindow(){ requestsThisWindow=0; windowStart=Date.now(); }
function checkSafetyAndMaybePause(){
  const now=Date.now();
  if(now-windowStart > SAFETY_WINDOW_MS){ resetWindow(); el.safetyStatus.innerText='Safety OK'; return false;}
  if(requestsThisWindow > SAFETY_MAX){
    running=false;
    el.safetyStatus.innerText = `Auto-paused: ${requestsThisWindow} req/min`;
    el.message.innerText = `Auto-paused ${SAFETY_PAUSE}s to avoid rate limit.`;
    el.startBtn.disabled=false; el.stopBtn.disabled=true;
    setTimeout(()=>{
      resetWindow();
      const cur = Math.max(200, parseInt(el.delay.value,10)||450);
      el.delay.value = Math.min(2000, Math.round(cur * 1.5));
      el.safetyStatus.innerText = 'Resumed after pause';
      el.message.innerText = 'Resumed (delay increased for safety)';
    }, SAFETY_PAUSE*1000);
    return true;
  }
  el.safetyStatus.innerText = `Req/min: ${requestsThisWindow}`;
  return false;
}

// ---------- Get top N by 24h change (filtered) ----------
async function getTopN(n){
  const tickers = await safeFetch(API_BASE + '/fapi/v1/ticker/24hr');
  const usdt = tickers.filter(t => t.symbol && t.symbol.endsWith('USDT') && !blacklist.includes(t.symbol));
  usdt.sort((a,b)=> parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent));
  return usdt.slice(0,n).map(x=>({symbol:x.symbol, last: Number(x.lastPrice), change24: Number(x.priceChangePercent)}));
}

// ---------- Queue symbol analysis (fetches klines + funding) ----------
function queueSymbolAnalysis(symbol, results){
  queue.push(async ()=>{
    try{
      // Fetch 1d, 4h, 15m and funding
      const [k1d, k4h, k15m, fundingData] = await Promise.all([
        safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=1d&limit=9`),
        safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=4h&limit=30`),
        safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=15m&limit=80`),
        safeFetch(`${API_BASE}/fapi/v1/fundingRate?symbol=${symbol}&limit=1`)
      ]);

      const closes1d = k1d.map(k=>Number(k[4]));
      const closes4h = k4h.map(k=>Number(k[4]));
      const vols4h = k4h.map(k=>Number(k[5]));
      const closes15 = k15m.map(k=>Number(k[4]));
      const vols15 = k15m.map(k=>Number(k[5]));

      const last4 = k4h[k4h.length-1], prev4 = k4h[k4h.length-2] || last4;
      const last15 = k15m[k15m.length-1];

      const open4 = Number(last4[1]), high4=Number(last4[2]), low4=Number(last4[3]), close4=Number(last4[4]);
      const body4 = Math.abs(close4 - open4) || 1e-9;
      const wickTop4 = Math.max(0, high4 - Math.max(open4, close4));
      const wickRatio4 = wickTop4 / body4;

      const volMA4 = sma(vols4h, Math.min(10, vols4h.length)) || 0;
      const volSpike4 = volMA4>0 ? Number((Number(last4[5]) / volMA4).toFixed(2)) : 1;

      const ema70_4 = ema(closes4h, 70) || ema(closes4h, Math.min(21, closes4h.length));
      const emaDistPct = ema70_4 ? Number(pct(close4, ema70_4).toFixed(2)) : 0;

      const rsi1d = rsiFromCloses(closes1d,14);
      const rsi4h = rsiFromCloses(closes4h,14);

      const prevHigh = Number(prev4[2]);
      const lowerHigh = high4 < prevHigh;

      const fundingRate = (fundingData && fundingData.length) ? Number(fundingData[0].fundingRate) : 0;

      // 15m acceleration slope: close now / close 6 candles ago
      const slope15 = closes15.length>6 ? close4 / closes15[closes15.length - 7] : 1;

      // recent range and volatility on 15m
      const recentHigh15 = Math.max(...k15m.slice(-24).map(k=>Number(k[2])));
      const recentLow15 = Math.min(...k15m.slice(-24).map(k=>Number(k[3])));
      const range15 = recentHigh15 - recentLow15;
      const recentVolSpike15 = (sma(vols15, Math.min(10, vols15.length)) || 1) ? Number((vols15[vols15.length-1] / (sma(vols15, Math.min(10, vols15.length)) || 1)).toFixed(2)) : 1;

      // Score rules (original logic)
      let score=0;
      const signals = {};
      if(rsi1d !== null && rsi1d >= 88){ score++; signals.rsi1d=true; } else signals.rsi1d=false;
      if(rsi4h !== null && rsi4h >= 80){ score++; signals.rsi4h=true; } else signals.rsi4h=false;
      if(volSpike4 >= 1.8){ score++; signals.volSpike=true; } else signals.volSpike=false;
      if(wickRatio4 >= 1.2){ score++; signals.wickTop=true; } else signals.wickTop=false;
      if(emaDistPct >= 50){ score++; signals.emaDist=true; } else signals.emaDist=false;
      if(lowerHigh){ score++; signals.lowerHigh=true; } else signals.lowerHigh=false;
      if(typeof fundingRate === 'number' && fundingRate < -0.0005){ score++; signals.fundingConfirm=true; } else signals.fundingConfirm=false;
      signals.funding = fundingRate;

      // Gather result object used for further detection
      results.push({
        symbol,
        score,
        signals,
        rsi1d, rsi4h,
        volSpike4, volSpike15: recentVolSpike15,
        wickRatio4,
        ema70DistPct: emaDistPct,
        lowerHigh,
        fundingRate,
        closeNow: close4,
        slope15,
        range15,
        recentHigh15,
        recentLow15,
        k4h, k15m // include raw candles for phase detection
      });

    } catch(err){
      el.debug.innerText += `\nError ${symbol}: ${err.message}`;
    }
  });
}

// ---------- Phase detection (7-step) ----------
function detectPhaseForSymbol(item){
  // Input: item contains k4h and k15m arrays, plus features computed earlier
  // Output: {phaseLabel, phaseScore (0-100), reasons[]}
  try{
    const k4 = item.k4h || [];
    const k15 = item.k15m || item.k15m; // in case it's present
    // use features
    const rsi4h = item.rsi4h || 0;
    const vol = item.volSpike4 || 1;
    const wick = item.wickRatio4 || 0;
    const emaStretch = item.ema70DistPct || 0;
    const funding = item.fundingRate || 0;
    const slope15 = item.slope15 || 1;
    const range15 = item.range15 || 0;

    // helper counts
    const recentHigh = item.recentHigh15, recentLow = item.recentLow15;
    const lastClose = item.closeNow || (k4.length? Number(k4[k4.length-1][4]) : 0);

    const reasons = [];
    let score = 0;

    // Phase heuristics:
    // 1) Acceleration â€” fast vertical moves: high slope, high volume but not wick yet
    if(slope15 > 1.6 && vol >= 1.6 && wick < 1.0){
      score += 2; reasons.push('Acceleration: steep short-term slope & high volume');
    }
    // 2) Climax candle â€” large wick/top, massive volume spike, RSI very high
    if(wick >= 1.8 && vol >= 3 && rsi4h >= 85){
      score += 3; reasons.push('Climax candle: big upper wick, volume climax, overbought');
    }
    // 3) Distribution â€” sideways top: range contraction, multiple indecisive candles after wick
    // detect recent horizontal movement on 15m: small range relative to higher timeframe
    if(range15 > 0){
      const relRange = Math.abs(range15) / (recentLow || 1);
      if(relRange <= 0.12 && k4.length>6 && rsi4h >= 60 && rsi4h <= 85){
        score += 2; reasons.push('Distribution / sideways top: range contracted after peak');
      }
    }
    // 4) Breakdown â€” clear lower highs on 4h and breach of short EMAs
    // detect three consecutive lower highs on 4h
    const highs = k4.slice(-6).map(k=>Number(k[2]));
    let lowerHCount = 0;
    for(let i=1;i<highs.length;i++) if(highs[i] < highs[i-1]) lowerHCount++;
    if(lowerHCount >= 3){
      score += 2; reasons.push('Breakdown: 4H lower highs forming');
    }
    // 5) Capitulation A â€” fast drop: large % drop from local peak with huge volume spike
    // compute drop from highest in last 15m window or 4h window
    const highest4h = Math.max(...k4.map(k=>Number(k[2])));
    const dropPctFromPeak = highest4h ? Math.abs((lastClose - highest4h)/highest4h)*100 : 0;
    if(dropPctFromPeak >= 20 && vol >= 2.5){
      score += 3; reasons.push(`Capitulation: drop ${dropPctFromPeak.toFixed(1)}% from recent high with volume`);
    }
    // 6) Dead-cat bounce â€” quick retrace 10-40% of drop after capitulation
    // check last 10 15m candles: if there was a big drop and then a bounce
    const closes15 = k15.map(k=>Number(k[4]));
    const len = closes15.length;
    let deadCat = false;
    if(len > 20){
      // find local min in last 20
      const recentSlice = closes15.slice(-20);
      const localMin = Math.min(...recentSlice);
      const afterMin = recentSlice.slice(recentSlice.indexOf(localMin)+1);
      if(afterMin.length){
        const bouncePct = ((afterMin[afterMin.length-1] - localMin)/localMin)*100;
        if(bouncePct >= 8 && bouncePct <= 60){
          deadCat = true; score += 1; reasons.push(`Dead-cat bounce: retrace ${bouncePct.toFixed(1)}% after drop`);
        }
      }
    }
    // 7) Final capitulation wick â€” last hammer wick with high volume and RSI low
    // detect long lower wick in recent 15m or 4h with high volume and RSI low
    const last15 = k15[k15.length-1] || [];
    if(last15.length){
      const o = Number(last15[1]), h=Number(last15[2]), l=Number(last15[3]), c=Number(last15[4]);
      const lowerWick = Math.max(0, Math.min(o,c) - l);
      const body = Math.abs(c - o) || 1e-9;
      const lowerWickRatio = lowerWick / body;
      const vol15 = Number(last15[5]) || 0;
      const volMA15 = sma(k15.map(k=>Number(k[5])), Math.min(10, k15.length)) || 1;
      if(lowerWickRatio >= 1.5 && vol15 / volMA15 >= 2 && (rsi4h < 40 || (rsi4h >= 40 && dropPctFromPeak >= 30))){
        score += 3; reasons.push('Final capitulation wick: long lower wick with volume');
      }
    }

    // Mapping final combined phase label
    // Use heuristic ranking of scores and presence of signals:
    // Highest weight map:
    const phaseCandidates = [];
    if(score >= 7 && reasons.some(r=>r.includes('Final capitulation'))) phaseCandidates.push({phase:'Final capitulation wick',priority:9});
    if(score >= 6 && reasons.some(r=>r.includes('Capitulation'))) phaseCandidates.push({phase:'Capitulation A',priority:8});
    if(score >= 5 && reasons.some(r=>r.includes('Breakdown'))) phaseCandidates.push({phase:'Breakdown',priority:7});
    if(score >= 4 && reasons.some(r=>r.includes('Distribution'))) phaseCandidates.push({phase:'Distribution / sideways top',priority:6});
    if(score >= 4 && reasons.some(r=>r.includes('Climax'))) phaseCandidates.push({phase:'Climax candle (blowoff wick)',priority:5});
    if(score >= 3 && reasons.some(r=>r.includes('Acceleration'))) phaseCandidates.push({phase:'Acceleration (vertical move)',priority:4});
    if(deadCat) phaseCandidates.push({phase:'Dead-cat bounce',priority:3});

    // If none matched specific text-based candidates, use numeric thresholds:
    if(phaseCandidates.length === 0){
      if(dropPctFromPeak >= 25 && vol >= 1.8) phaseCandidates.push({phase:'Capitulation A',priority:8});
      else if(wick >= 1.6 && rsi4h >= 85) phaseCandidates.push({phase:'Climax candle (blowoff wick)',priority:6});
      else if(rsi4h >= 78 && vol >= 2.0) phaseCandidates.push({phase:'Climax candle (blowoff wick)',priority:5});
      else if(range15 <= (Math.max(1, Math.abs(item.recentLow15||1))*0.08) && rsi4h >= 60) phaseCandidates.push({phase:'Distribution / sideways top',priority:6});
      else if(lowerHCount>=2) phaseCandidates.push({phase:'Breakdown',priority:7});
      else if(slope15 > 1.5) phaseCandidates.push({phase:'Acceleration (vertical move)',priority:4});
      else phaseCandidates.push({phase:'Normal/Trending',priority:1});
    }

    // pick top candidate by priority
    phaseCandidates.sort((a,b)=>b.priority - a.priority);
    const chosen = phaseCandidates[0].phase || 'Unknown';
    // Estimate confidence from score
    const conf = Math.min(98, Math.round((score/12)*100));
    return {phase: chosen, confidence: conf, reasons: reasons, dropPctFromPeak: Math.round(dropPctFromPeak*100)/100};
  } catch(e){
    return {phase:'Unknown', confidence:0, reasons:[], dropPctFromPeak:0};
  }
}

// ---------- PIPPIN similarity: find PIPPIN vector and compute cosine similarity ----------
function makeFeatureVector(item){
  // features: normalized vector elements in fixed order:
  // [rsi4h (0-100)/100, volSpike4 normalized (divided by 5), wickRatio (capped 0-5)/5, ema70DistPct normalized (div by 200), fundingSign * abs(funding*1000), slope15 normalized (div2), dropPctNormalized]
  const rsi4h = Math.min(100, item.rsi4h || 0)/100;
  const vol = Math.min(10, item.volSpike4 || 1)/5; // scale so typical values map ~0-2
  const wick = Math.min(10, item.wickRatio4 || 0)/5;
  const ema = Math.min(500, Math.abs(item.ema70DistPct || 0))/200; // big stretches scale down
  const funding = (item.fundingRate || 0) * 1000; // negative values large negative, positive else
  const slope = Math.min(4, Math.max(0, (item.slope15 || 1)/1.5))/2; // normalize
  const drop = Math.min(100, item.dropPctFromPeak || 0)/100;
  // ensure vector length >=1
  return [rsi4h, vol, wick, ema, funding, slope, drop];
}

// ---------- Rule-based AI explanation (existing + some phase context) ----------
function explainBlowoff(item){
  const p = item;
  let pts = 0;
  const reasons = [];
  if(p.rsi1d !== null && p.rsi1d >= 88){ pts += 2; reasons.push(`1D RSI very high (${p.rsi1d.toFixed(1)})`); }
  else if(p.rsi1d !== null && p.rsi1d >= 80){ pts += 1; reasons.push(`1D RSI high (${p.rsi1d.toFixed(1)})`); }
  if(p.rsi4h !== null && p.rsi4h >= 85){ pts += 1; reasons.push(`4H RSI overbought (${p.rsi4h.toFixed(1)})`); }
  if(p.volSpike4 >= 3){ pts += 2; reasons.push(`Volume climax Ã—${p.volSpike4}`); }
  else if(p.volSpike4 >= 1.8){ pts += 1; reasons.push(`Volume spike Ã—${p.volSpike4}`); }
  if(p.wickRatio4 >= 2.0){ pts += 2; reasons.push(`Large upper wick (ratio ${p.wickRatio4.toFixed(2)})`); }
  else if(p.wickRatio4 >= 1.2){ pts += 1; reasons.push(`Upper wick present (ratio ${p.wickRatio4.toFixed(2)})`); }
  if(p.ema70DistPct >= 150){ pts += 2; reasons.push(`Extreme EMA stretch (${p.ema70DistPct}% above EMA70)`); }
  else if(p.ema70DistPct >= 50){ pts += 1; reasons.push(`Price stretched from EMA (${p.ema70DistPct}% )`); }
  if(typeof p.fundingRate === 'number'){
    if(p.fundingRate < -0.001){ pts += 2; reasons.push(`Funding strongly negative (${(p.fundingRate*100).toFixed(3)}%)`); }
    else if(p.fundingRate < -0.0005){ pts += 1; reasons.push(`Funding negative (${(p.fundingRate*100).toFixed(3)}%)`); }
  }
  if(p.lowerHigh){ pts += 1; reasons.push('Lower high formed'); }
  if(typeof p.score === 'number'){
    if(p.score >= 6) pts += 2;
    else if(p.score >= 4) pts += 1;
  }
  // map to label
  let label='None', color='#9fb3cc', prob=5;
  if(pts >= 10){ label='Extreme'; color='#e74c3c'; prob=92; }
  else if(pts >= 7){ label='High'; color='#ff6b43'; prob=78; }
  else if(pts >= 4){ label='Medium'; color='#ffd966'; prob=55; }
  else if(pts >= 2){ label='Low'; color='#7bd389'; prob=25; }
  else { label='None'; color='#9fb3cc'; prob=5; }
  const topReasons = reasons.slice(0,4);
  const explanation = topReasons.length ? `${topReasons.join('; ')}. Estimated reversal probability: ${prob}%.` : `No clear exhaustion signals detected.`;
  return {pts, label, color, prob, explanation, reasons: topReasons};
}

// ---------- Rendering (table + cards) ----------
function renderTable(results, pippinVectorName){
  // results sorted by score desc then similarity
  results.sort((a,b)=> (b.score - a.score) || ((b.similarity||0) - (a.similarity||0)) || (b.ema70DistPct - a.ema70DistPct));
  const threshold = parseInt(el.threshold.value,10) || 4;
  const rows = results.map(r=>{
    const expl = explainBlowoff(r);
    const phaseInfo = r.phase || {phase:'Unknown',confidence:0};
    let statusHtml = `<span class="small">normal</span>`;
    let bg = 'background:rgba(255,255,255,0.02)';
    let cls = '';
    if(r.score >= threshold){
      statusHtml = `<span style="background:#ff4d4d;padding:4px 8px;border-radius:6px;font-size:11px;font-weight:bold;">ðŸ”¥ BLOWOFF</span>`;
      bg = 'background:rgba(255,40,40,0.12)';
      if(!prevBlowoffSet.has(r.symbol)) cls='blink';
    } else if(r.score === threshold-1){
      statusHtml = `<span style="background:#ffd966;padding:4px 8px;border-radius:6px;font-size:11px;font-weight:bold;color:black;">âš  POTENTIAL</span>`;
      bg = 'background:rgba(255,200,0,0.10)';
    }
    const simPct = r.similarity ? Math.round(r.similarity*100) : 0;
    const simHtml = `<div class="small">PIPPIN similarity: <strong>${simPct}%</strong></div>`;

    // Phase badge color logic
    let phaseColor = '#9fb3cc';
    if(phaseInfo.phase.includes('Capitulation')) phaseColor='#e74c3c';
    else if(phaseInfo.phase.includes('Climax') || phaseInfo.phase.includes('Acceleration')) phaseColor='#ff6b43';
    else if(phaseInfo.phase.includes('Distribution')) phaseColor='#ffd966';
    else if(phaseInfo.phase.includes('Dead-cat')) phaseColor='#7bd389';

    return `
      <tr class="${cls}" style="${bg}">
        <td><strong>${r.symbol}</strong><br>${statusHtml} <span class="phaseTag" style="background:${phaseColor}; color:black;margin-left:8px">${phaseInfo.phase} (${phaseInfo.confidence}%)</span></td>
        <td>${r.closeNow}</td>
        <td class="${(r.rsi4h||0)>=80?'green':''}">${r.rsi4h? r.rsi4h.toFixed(1):'n/a'}</td>
        <td class="small">volÃ—${r.volSpike4} wick:${(r.wickRatio4||0).toFixed(2)} ema:${r.ema70DistPct}%</td>
        <td class="small">${(r.fundingRate||0).toFixed(6)}<br>${simHtml}</td>
      </tr>
      <tr style="background:rgba(255,255,255,0.01)"><td colspan="5" style="padding:8px 12px;color:${expl.color}">
        <strong>${expl.label}</strong> â€” ${expl.explanation}
        ${r.phase? `<div style="margin-top:6px;color:#cfe8ff">Phase: <strong>${r.phase.phase}</strong> (${r.phase.confidence}%) â€¢ ${r.phase.reasons.join('; ')}</div>` : ''}
      </td></tr>
    `;
  }).join('');

  el.tableView.innerHTML = `<div class="card-panel"><table><thead><tr><th>Symbol / Status</th><th>Last</th><th>RSI4H</th><th>Signals</th><th>Funding / PIPPIN</th></tr></thead><tbody>${rows}</tbody></table></div>`;

  setTimeout(()=>{ const nodes=document.querySelectorAll('tr.blink'); nodes.forEach(n=>n.classList.remove('blink')); }, 3000);
}

function renderCards(results){
  results.sort((a,b)=> (b.score - a.score) || ((b.similarity||0) - (a.similarity||0)));
  let html='';
  results.forEach(r=>{
    const expl = explainBlowoff(r);
    const phase = r.phase || {phase:'Unknown', confidence:0, reasons:[]};
    const simPct = Math.round((r.similarity||0)*100);
    let badge = `<span class="small" style="color:var(--muted)">normal</span>`;
    let bc = '';
    if(r.score >= (parseInt(el.threshold.value,10)||4)){ badge = `<span class="blowBadge">ðŸ”¥ Blowoff</span>`; bc='blink'; }
    else if(r.score === (parseInt(el.threshold.value,10)||4)-1){ badge = `<span class="potBadge">âš  Potential</span>`; }
    html += `
      <div class="coinCard ${bc}">
        <div class="coinRow1"><div class="coinSymbol">${r.symbol}</div><div class="coinScore">${r.score}/8</div></div>
        <div style="margin-top:6px">${badge} <span style="margin-left:8px;font-size:12px;background:var(--glass);padding:4px 8px;border-radius:8px">${phase.phase} ${phase.confidence}%</span></div>
        <div class="sigList">
          Last: ${r.closeNow}<br>
          RSI4H: ${r.rsi4h? r.rsi4h.toFixed(1):'n/a'} â€¢ VolÃ—${r.volSpike4} â€¢ Wick:${(r.wickRatio4||0).toFixed(2)}<br>
          EMAâˆ†: ${r.ema70DistPct}% â€¢ Funding: ${(r.fundingRate||0).toFixed(6)}<br>
          <small style="color:#cfe8ff">PIPPIN similarity: <strong>${simPct}%</strong></small>
        </div>
        <div style="margin-top:8px;padding-top:8px;border-top:1px dashed rgba(255,255,255,0.03);">
          <div style="color:${expl.color};font-weight:700">${expl.label} â€” ${expl.prob}% chance of near-term reversal</div>
          <div style="color:#cfe8ff;font-size:13px;margin-top:6px">${expl.explanation}</div>
          ${phase.reasons && phase.reasons.length ? `<div style="color:#cfe8ff;margin-top:6px">Phase reasons:<br>â€¢ ${phase.reasons.join('<br>â€¢ ')}</div>` : ''}
        </div>
      </div>
    `;
  });
  el.cardView.innerHTML = `<div class="card-panel">${html}</div>`;
  setTimeout(()=>{ const nodes=document.querySelectorAll('.coinCard.blink'); nodes.forEach(n=>n.classList.remove('blink')); }, 3000);
}

// ---------- Update progress ----------
function updateProgress(){
  const pct = totalTasks ? Math.round((doneTasks/totalTasks)*100) : 0;
  el.bar.style.width = pct + '%';
  el.message.innerText = `Scanning ${doneTasks}/${totalTasks} (${pct}%) â€” delay ${el.delay.value}ms`;
  el.safetyStatus.innerText = `Req/min: ${requestsThisWindow}`;
}

// ---------- Countdown ----------
function startCountdown(sec){
  if(countdownTimer) clearInterval(countdownTimer);
  const end = Date.now() + sec*1000;
  countdownTimer = setInterval(()=>{
    const left = Math.max(0, Math.round((end - Date.now())/1000));
    el.countdown.innerText = `Next scan in: ${left}s`;
    if(left <= 0){ clearInterval(countdownTimer); el.countdown.innerText = 'Running...'; }
  }, 500);
}

// ---------- Main run ----------
async function runScan(once=false){
  try{
    running=true; el.startBtn.disabled=true; el.stopBtn.disabled=false; el.debug.innerText='';
    resetWindow();
    el.message.innerText = 'Fetching top symbols...';
    const N = Math.max(5, Math.min(60, parseInt(el.prefilter.value,10) || 30));
    const delayMs = Math.max(50, Math.min(2000, parseInt(el.delay.value,10) || 450));
    const intervalSec = Math.max(10, Math.min(3600, parseInt(el.interval.value,10) || 60));

    // get top candidates
    const top = await getTopN(N);

    queue = []; totalTasks = top.length; doneTasks = 0; updateProgress();
    const results = [];

    // schedule analysis jobs
    top.forEach(t => queueSymbolAnalysis(t.symbol, results));

    // start countdown
    if(!once) startCountdown(intervalSec);

    // process queue (rate limited)
    while(queue.length && running){
      if(checkSafetyAndMaybePause()) break;
      const job = queue.shift();
      try{ await job(); } catch(e){ el.debug.innerText += `\nJob error: ${e.message}`; }
      doneTasks++; updateProgress();
      await delay(delayMs);
    }

    // post-processing: compute phases and similarity
    // first locate PIPPIN vector from results
    const pippinEntry = results.find(r=> r.symbol === 'PIPPINUSDT') || null;
    // compute dropPctFromPeak for each item used in vector
    results.forEach(r=> { r.phase = detectPhaseForSymbol(r); r.dropPctFromPeak = r.phase.dropPctFromPeak; });

    let pippinVector = null;
    if(pippinEntry){
      pippinEntry.dropPctFromPeak = pippinEntry.phase.dropPctFromPeak;
      pippinVector = makeFeatureVector(pippinEntry);
    } else {
      // if PIPPIN not present in topN, fetch its features live to set as template
      try{
        const tmpResults = [];
        await new Promise(res=>{ // small helper to reuse queueSymbolAnalysis
          const q = [];
          q.push(async ()=>{
            const [k1d,k4h,k15,f] = await Promise.all([
              safeFetch(`${API_BASE}/fapi/v1/klines?symbol=PIPPINUSDT&interval=1d&limit=9`),
              safeFetch(`${API_BASE}/fapi/v1/klines?symbol=PIPPINUSDT&interval=4h&limit=30`),
              safeFetch(`${API_BASE}/fapi/v1/klines?symbol=PIPPINUSDT&interval=15m&limit=80`),
              safeFetch(`${API_BASE}/fapi/v1/fundingRate?symbol=PIPPINUSDT&limit=1`)
            ]);
            // compute features quickly
            const closes4 = k4h.map(k=>Number(k[4]));
            const last4 = k4h[k4h.length-1];
            const open4 = Number(last4[1]), high4 = Number(last4[2]), low4 = Number(last4[3]), close4 = Number(last4[4]);
            const body4 = Math.abs(close4-open4)||1e-9;
            const wick4 = Math.max(0, high4 - Math.max(open4,close4))/body4;
            const volMA4 = sma(k4h.map(k=>Number(k[5])), Math.min(10,k4h.length))||1;
            const volSpike4 = Number((Number(last4[5]) / volMA4).toFixed(2));
            const ema70 = ema(closes4,70)||ema(closes4,Math.min(21,closes4.length));
            const emaDist = ema70 ? Number(pct(close4, ema70).toFixed(2)) : 0;
            const rsi4 = rsiFromCloses(k1d.map(k=>Number(k[4])),14);
            const fundingRate = (f && f.length)? Number(f[0].fundingRate):0;
            tmpResults.push({
              rsi4h: rsi4,
              volSpike4,
              wickRatio4: wick4,
              ema70DistPct: emaDist,
              fundingRate,
              slope15: 1,
              dropPctFromPeak: 0
            });
            res();
          });
          // run the only job
          (async ()=>{ for(const j of q) await j(); })();
        });
        if(tmpResults.length) pippinVector = makeFeatureVector(tmpResults[0]);
      } catch(e){}
    }

    // compute similarity to pippin vector (if available)
    if(pippinVector){
      results.forEach(r=>{
        r.similarity = cosineSim(makeFeatureVector(r), pippinVector);
      });
    } else {
      results.forEach(r=> r.similarity = 0);
    }

    // set prev blowoff set for highlights
    prevBlowoffSet = new Set(results.filter(r=> r.score >= (parseInt(el.threshold.value,10)||4)).map(r=>r.symbol));

    // render results in hybrid UI
    if(window.innerWidth >= 680) renderTable(results);
    else renderCards(results);

    // alerts
    const flagged = results.filter(r=> r.score >= (parseInt(el.threshold.value,10)||4));
    if(flagged.length){
      try{ const audio = new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg'); audio.volume=0.7; audio.play().catch(()=>{});}catch(e){}
      if(Notification && Notification.permission === 'granted') new Notification('ðŸ”¥ Blowoff Detected', {body: flagged.map(f=>f.symbol).slice(0,4).join(', ')});
      else if(Notification && Notification.permission !== 'denied') Notification.requestPermission();
    }

    // schedule next run
    if(!once){
      if(requestsThisWindow > SAFETY_MAX){ el.debug.innerText += '\nAuto-paused due to safety'; }
      else {
        if(autoTimer) clearTimeout(autoTimer);
        autoTimer = setTimeout(()=>{ if(requestsThisWindow <= SAFETY_MAX) runScan(false); }, intervalSec * 1000);
        startCountdown(intervalSec);
      }
    }

    running=false; el.startBtn.disabled=false; el.stopBtn.disabled=true;
  } catch(e){
    el.debug.innerText += `\nRun error: ${e.message}`;
    running=false; el.startBtn.disabled=false; el.stopBtn.disabled=true;
  }
}

// ---------- UI events ----------
el.startBtn.addEventListener('click', ()=>{ if(running) return; prevBlowoffSet = new Set(); runScan(false); });
el.stopBtn.addEventListener('click', ()=>{ running=false; queue=[]; el.startBtn.disabled=false; el.stopBtn.disabled=true; if(autoTimer) clearTimeout(autoTimer); if(countdownTimer) clearInterval(countdownTimer); el.countdown.innerText='Next scan in: -'; el.message.innerText='Stopped.'; });
el.oneShot.addEventListener('click', ()=>{ if(running) return; runScan(true); });

// request notification permission
if('Notification' in window){ try{ Notification.requestPermission().catch(()=>{}); } catch(e){} }

// initial ping (CORS dip)
(async function ping(){ try{ await fetch(API_BASE + '/fapi/v1/ping'); } catch(e){ console.warn('ping failed', e); } })();

</script>

<footer class="small">
  Blowoff Top Detector â€” Hybrid AI Mode â€¢ Phase detection & PIPPIN similarity added.<br>
  Run from a local server (e.g. <code>python -m http.server</code>) to avoid CORS issues.
</footer>
</body>
</html>
