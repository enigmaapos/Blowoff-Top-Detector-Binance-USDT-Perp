<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Blowoff Top Detector — Phase, PIPPIN, Multi-TF Accumulation, & Alerts</title>
<style>
  :root{
    --bg:#07101a;
    --card:#0b1220;
    --muted:#9fb3cc;
    --accent:#2dd4bf;
    --danger:#ff7b7b;
    --glass: rgba(255,255,255,0.03);
  }
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:#e6eef8;margin:12px}
  .card-panel{background:var(--card);border:1px solid #172033;padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,.6);margin-bottom:14px}
  h1{margin:0;font-size:18px}
  .controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;align-items:center}
  label{font-size:13px;color:var(--muted)}
  input,select{background:#071722;border:1px solid #243241;color:#e6eef8;padding:6px;border-radius:6px}
  button{background:#1f6feb;border:none;color:white;padding:8px 10px;border-radius:6px;cursor:pointer}
  button.alt{background:#2b3947}
  .status{margin-top:8px;color:var(--muted);font-size:13px;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .progress{height:8px;background:#05101a;border-radius:4px;margin-top:8px;overflow:hidden;flex:1}
  .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#60a5fa);width:0%}
  .countdown{font-weight:700;color:#cfe8ff}
  .mutedBadge{background:var(--glass);color:var(--muted);padding:4px 8px;border-radius:8px;font-size:12px}
  table{width:100%;border-collapse:collapse;margin-top:12px;font-size:13px;min-width:720px}
  th,td{padding:8px 10px;border-bottom:1px dashed #122331;text-align:left;vertical-align:top}
  th{color:var(--muted);font-size:12px}
  .green{color:#66f9a1}
  .red{color:var(--danger)}
  .small{font-size:12px;color:var(--muted)}
  .badge{display:inline-block;padding:4px 8px;border-radius:12px;background:#0f2430;color:#bfeee1;font-size:12px}
  .blink{animation: blinkHighlight 1.8s ease-in-out 3}
  @keyframes blinkHighlight {0%{box-shadow:0 0 0 rgba(255,80,80,0)}50%{box-shadow:0 0 12px rgba(255,80,80,0.35)}100%{box-shadow:0 0 0 rgba(255,80,80,0)}}
  /* mobile card UI */
  #tableView{display:block} #cardView{display:none}
  @media (max-width:680px){
    #tableView{display:none} #cardView{display:block}
    .coinCard{background:var(--card);border:1px solid #172033;padding:12px;border-radius:10px;margin-bottom:10px}
    .coinRow1{display:flex;justify-content:space-between;align-items:center}
    .coinSymbol{font-size:16px;font-weight:700}
    .coinScore{font-size:14px;font-weight:700}
    .blowBadge{background:#ff4d4d;padding:4px 8px;border-radius:6px;color:white;font-size:12px;font-weight:700}
    .potBadge{background:#ffd966;padding:4px 8px;border-radius:6px;color:black;font-size:12px;font-weight:700}
    .accBadge{background:#2dd4bf;padding:4px 8px;border-radius:6px;color:#04221a;font-size:12px;font-weight:700}
    .sigList{margin-top:8px;font-size:13px;line-height:18px;color:#cfe8ff}
  }
  footer.small{margin-top:12px;color:var(--muted);font-size:12px}
  .phaseTag{display:inline-block;padding:4px 8px;border-radius:8px;font-weight:700;font-size:12px;margin-left:6px}
  .tfToggle{display:inline-flex;gap:6px;align-items:center;margin-left:8px}
  .sensitivity{width:160px}
  .oneLineRec{font-weight:700;color:#cfe8ff;margin-top:6px}
  .recBox{margin-top:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px}
  .finalRec{margin-top:8px;color:#8bffc0;font-weight:700}
  .shortRec{margin-top:8px;color:#ffd966;font-weight:700}
  /* trading interpretation panel */
  .tradePanel{margin-top:12px;padding:12px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03)}
  .tradePanel h3{margin:0 0 8px 0;font-size:15px}
  .tradePanel p{margin:4px 0;color:#cfe8ff}
  .tradeList{margin:8px 0;padding-left:18px}
  .mutedNote{color:var(--muted);font-size:12px;margin-top:8px}
</style>
</head>
<body>
<div class="card-panel">
  <h1>Blowoff Top Detector — Multi-TF Accumulation & Conditional Alerts</h1>
  <div class="small" style="margin-top:6px;color:var(--muted)">
    Multi-timeframe accumulation detector (15m / 1h / 4h), sensitivity slider, conditional alert (blowoff + accumulation) and AI recommendations (long-term + short-term).
    Run on a local server to avoid CORS (e.g., <code>python -m http.server</code>).
  </div>

  <div class="controls">
    <label>Prefilter (top by 24h) <input id="prefilter" type="number" value="30" min="5" max="60"/></label>
    <label>Delay (ms) <input id="delay" type="number" value="450" min="50" max="2000"/></label>
    <label>Refresh (sec) <input id="interval" type="number" value="60" min="10" max="3600"/></label>
    <label>Score ≥ <input id="threshold" type="number" value="4" min="1" max="8"/></label>

    <!-- Sorting controls (ADDED) -->
    <label style="margin-left:8px">Sort by
      <select id="sortBy" style="margin-left:6px">
        <option value="score">Score</option>
        <option value="similarity">PIPPIN similarity</option>
        <option value="accum">Accum confidence</option>
        <option value="preCrash">Pre-crash confidence</option>
        <option value="rsi4h">RSI (4H)</option>
        <option value="ema70DistPct">EMA stretch %</option>
        <option value="last">Last price</option>
        <option value="symbol">Symbol</option>
      </select>
    </label>
    <button id="sortDir" class="alt" title="Toggle sort direction" style="margin-left:6px">Desc</button>
    <!-- end sorting -->

    <button id="startBtn">Start</button>
    <button id="stopBtn" class="alt" disabled>Stop</button>
    <button id="oneShot" class="alt">Run Once</button>
  </div>

  <div class="controls" style="margin-top:10px">
    <label style="margin-right:8px">Accumulation TFs:</label>
    <div class="tfToggle">
      <label><input type="checkbox" id="tf15" checked> 15m</label>
      <label><input type="checkbox" id="tf1h" checked style="margin-left:6px"> 1h</label>
      <label><input type="checkbox" id="tf4h" checked style="margin-left:6px"> 4h</label>
    </div>

    <label style="margin-left:12px">Sensitivity <span id="sensVal" class="small" style="margin-left:6px">50</span></label>
    <input id="sensitivity" class="sensitivity" type="range" min="0" max="100" value="50" style="margin-left:8px">

    <label style="margin-left:12px">Alert when:</label>
    <label style="margin-left:6px"><input type="checkbox" id="condAlert"> Blowoff HIGH + Accum ≥</label>
    <input id="accumAlertThreshold" type="number" value="50" min="0" max="100" style="width:64px;margin-left:6px">

    <label style="margin-left:12px"><input type="checkbox" id="showShort" checked> Show short-term plans</label>
  </div>

  <div class="status">
    <div id="message">Ready.</div>
    <div class="progress"><i id="bar"></i></div>
    <div id="countdown" class="countdown">Next scan in: -</div>
    <div id="safetyStatus" class="mutedBadge">Safety OK</div>
  </div>

  <!-- Symbol search (paste inside the .controls block) -->
<label style="margin-left:8px">
  Search symbol:
  <input id="symbolSearch" placeholder="e.g. BTCUSDT or PIPPINUSDT" style="margin-left:6px;width:150px"/>
</label>
<button id="symbolSearchBtn" class="alt" title="Analyze symbol">Analyze</button>
<button id="symbolClearCache" class="alt" title="Clear symbol cache" style="margin-left:6px">Clear cache</button>
<div id="symbolStatus" class="small" style="margin-left:8px;color:var(--muted)"> </div>
  <button id="scanAllBtn" class="alt">Scan All USDT Blowoff Forming</button>

  <div id="tableView"></div>
  <div id="cardView"></div>

  <!-- NEW: Quick Trading Interpretation -->
  <div id="tradeInterpret" class="tradePanel" style="display:none">
    <!-- content injected dynamically -->
  </div>

  <div id="debug" class="small" style="margin-top:8px"></div>
</div>

<script>
/* ======================================================
   Full detector with sorting added (client-side).
   ====================================================== */

const API_BASE = 'https://fapi.binance.com';
const blacklist = ["ALPACAUSDT","BNXUSDT","ALPHAUSDT","OCEANUSDT","DGBUSDT","AGIXUSDT","LINAUSDT","LOKAUSDT","KEYUSDT","MDTUSDT","LOOMUSDT","RENUSDT","OMNIUSDT","SLERFUSDT","STMXUSDT","UXLINKUSDT","BSWUSDT","NEIROETHUSDT","VIDTUSDT","TROYUSDT","BAKEUSDT","AMBUSDT","MEMEFIUSDT","NULSUSDT","HIFIUSDT","LEVERUSDT","XEMUSDT","STRAXUSDT","COMBOUSDT","AI16ZUSDT"];

const el = {
  prefilter: document.getElementById('prefilter'),
  delay: document.getElementById('delay'),
  interval: document.getElementById('interval'),
  threshold: document.getElementById('threshold'),
  startBtn: document.getElementById('startBtn'),
  stopBtn: document.getElementById('stopBtn'),
  oneShot: document.getElementById('oneShot'),
  message: document.getElementById('message'),
  bar: document.getElementById('bar'),
  tableView: document.getElementById('tableView'),
  cardView: document.getElementById('cardView'),
  debug: document.getElementById('debug'),
  safetyStatus: document.getElementById('safetyStatus'),
  countdown: document.getElementById('countdown'),
  tf15: document.getElementById('tf15'),
  tf1h: document.getElementById('tf1h'),
  tf4h: document.getElementById('tf4h'),
  sensitivity: document.getElementById('sensitivity'),
  sensVal: document.getElementById('sensVal'),
  condAlert: document.getElementById('condAlert'),
  accumAlertThreshold: document.getElementById('accumAlertThreshold'),
  showShort: document.getElementById('showShort'),
  tradeInterpret: document.getElementById('tradeInterpret'),
  // sorting elements (populated below)
  sortBy: document.getElementById('sortBy'),
  sortDir: document.getElementById('sortDir')
};

  // ---------------------- Symbol search + single-symbol analyzer ----------------------
// Wire new elements
el.symbolSearch = document.getElementById('symbolSearch');
el.symbolSearchBtn = document.getElementById('symbolSearchBtn');
el.symbolClearCache = document.getElementById('symbolClearCache');
el.symbolStatus = document.getElementById('symbolStatus');

// Simple in-memory cache for symbol analysis & exchangeInfo
const symbolCache = new Map(); // key -> { ts, data }
const CACHE_TTL = 1000 * 60 * 5; // 5 minutes TTL

// Small rate-limiter for manual symbol lookups (token bucket-ish)
let lastSymbolReq = 0;
const MIN_MS_BETWEEN_SYMBOL_REQ = 800; // 0.8s between manual lookups (adjust as needed)

// Optional: cached exchangeInfo to validate symbol (fetch once, lazy)
let exchangeInfoCache = null;
async function ensureExchangeInfo() {
  if(exchangeInfoCache && (Date.now() - exchangeInfoCache.ts) < 1000*60*30) return exchangeInfoCache.data;
  try {
    const data = await safeFetch(API_BASE + '/fapi/v1/exchangeInfo', { allowIfNotRunning: true });
    exchangeInfoCache = { ts: Date.now(), data };
    return data;
  } catch(e){
    // if fails, we won't block symbol analysis — just proceed (we'll try to fetch klines)
    console.warn('exchangeInfo fetch failed:', e.message);
    return null;
  }
}

// Validate quick: symbol must end with USDT for futures perpetual USDT pairs
function looksLikeUSDTPerp(sym) {
  if(!sym) return false;
  // common convention: futures perpetual on Binance use USDT pairs and show in /fapi endpoints
  return sym.toUpperCase().endsWith('USDT');
}

// Helper: read & set cache
function getCachedSymbol(sym) {
  const k = sym.toUpperCase();
  const row = symbolCache.get(k);
  if(!row) return null;
  if(Date.now() - row.ts > CACHE_TTL) { symbolCache.delete(k); return null; }
  return row.data;
}
function setCachedSymbol(sym, data) {
  const k = sym.toUpperCase();
  symbolCache.set(k, { ts: Date.now(), data });
}

// Clear cache button
el.symbolClearCache.addEventListener('click', () => {
  symbolCache.clear();
  exchangeInfoCache = null;
  el.symbolStatus.innerText = 'Symbol cache cleared.';
  setTimeout(()=> el.symbolStatus.innerText = '', 2600);
});

  function classifySimilarityPhase(sim) {
  if (sim < 0.20) return "Trend / Early Pump";
  if (sim < 0.35) return "Blowoff Forming";
  if (sim < 0.55) return "Blowoff / Distribution";
  if (sim < 0.80) return "Breakdown / Crash Phase";
  return "Flatline / Post-Crash";
  }

// The main single-symbol analyzer; returns the result object in same shape as `results` entries
async function analyzeSymbol(symbol, opts = { allowIfNotRunning: true }) {
  const sym = (symbol || '').toUpperCase();
  if(!sym) throw new Error('Symbol empty');
  // quick check and safety
  if(!looksLikeUSDTPerp(sym)) {
    // try to still proceed but warn user
    el.symbolStatus.innerText = `Warning: "${sym}" does not end with USDT — will attempt fetch anyway.`;
  }


  // UI: Add wiring for new controls (create these in your HTML or skip if you already have similar)
el.scanAllBtn = document.getElementById('scanAllBtn');        // <button id="scanAllBtn">Scan All USDT Blowoff</button>
el.scanCancelBtn = document.getElementById('scanCancelBtn');  // <button id="scanCancelBtn">Cancel Scan</button>
el.scanProgress = document.getElementById('scanProgress');    // optional small progress text

// Config - tweak these to taste
const ALL_SCAN_BATCH_SIZE = 5;      // concurrent analyzeSymbol() calls per batch
const ALL_SCAN_DELAY_BETWEEN = 220; // ms delay between individual symbol analyze starts
const ALL_SCAN_BLACKLIST = new Set(blacklist || []); // reuse your blacklist
let allScanAbort = false;

async function fetchAllUSDTSymbols() {
  // Use exchangeInfo (cached via ensureExchangeInfo)
  const info = await ensureExchangeInfo();
  if(!info || !Array.isArray(info.symbols)) throw new Error('exchangeInfo unavailable');
  // Filter perpetual USDT pairs - relax rules if you want to include non-perpetual
  const syms = info.symbols
    .filter(s => s.symbol && s.symbol.endsWith('USDT') && !ALL_SCAN_BLACKLIST.has(s.symbol))
    .map(s => ({ symbol: s.symbol, status: s.status || 'UNKNOWN', quoteAsset: s.quoteAsset || '' }));
  return syms.map(x => x.symbol);
}

async function analyzeSymbolsInBatches(symbols, opts = { allowIfNotRunning: true, phaseFilterText: 'Blowoff Forming' }) {
  allScanAbort = false;
  const total = symbols.length;
  let processed = 0;
  const matched = [];
  const errors = [];

  // helper to update UI progress
  function updateUI() {
    if(el.scanProgress) el.scanProgress.innerText = `Processed ${processed}/${total} — Found ${matched.length}`;
    if(el.symbolStatus) el.symbolStatus.innerText = `Scanning ${processed}/${total} — matched ${matched.length}`;
  }

  // iterate in windows of size ALL_SCAN_BATCH_SIZE
  for (let i = 0; i < symbols.length; i += ALL_SCAN_BATCH_SIZE) {
    if(allScanAbort) break;
    // before starting a batch, check safety and maybe pause
    if(checkSafetyAndMaybePause()) {
      // if safety triggered, stop scan
      el.symbolStatus && (el.symbolStatus.innerText = 'Scan paused by safety. Aborting.');
      break;
    }
    const batch = symbols.slice(i, i + ALL_SCAN_BATCH_SIZE);
    // map to promises but start them staggered to avoid bursts
    const proms = batch.map(async (sym, idx) => {
      if(allScanAbort) return null;
      // Respect small offset so not all requests start at same ms
      await delay(idx * Math.max(0, Math.floor(ALL_SCAN_DELAY_BETWEEN / 2)));
      try {
        // reuse analyzeSymbol which uses symbolCache
        const res = await analyzeSymbol(sym, { allowIfNotRunning: opts.allowIfNotRunning });
        // filter match: check phase label OR simPhase
        const phaseName = (res.phase && res.phase.phase) ? res.phase.phase : '';
        const simPhase = res.simPhase || '';
        const matches = (phaseName.toLowerCase().includes(opts.phaseFilterText.toLowerCase())
                        || simPhase.toLowerCase().includes(opts.phaseFilterText.toLowerCase()));
        if(matches) {
          matched.push(res);
        }
        processed++;
        updateUI();
        // small safety delay between resolutions to help not exceed req/min
        await delay(ALL_SCAN_DELAY_BETWEEN);
        return res;
      } catch(err) {
        processed++;
        errors.push({ symbol: sym, error: err.message });
        updateUI();
        return null;
      }
    });

    // await entire batch
    await Promise.allSettled(proms);

    // optional small cooling off after each batch
    await delay(ALL_SCAN_DELAY_BETWEEN);
  }

  // sort + render results
  window.lastScanResults = matched;
  sortResults(window.lastScanResults || []);
  if(window.innerWidth >= 680) renderTable(window.lastScanResults);
  else renderCards(window.lastScanResults);
  updateTradingInterpretation(window.lastScanResults);

  // final UI
  if(el.symbolStatus) el.symbolStatus.innerText = `Scan complete. Found ${matched.length}/${total}.`;
  if(el.scanProgress) el.scanProgress.innerText = `Done — matched ${matched.length} / ${total}`;
  return { matched, errors, total };
}

// Hook buttons (if present)
if(el.scanAllBtn) {
  el.scanAllBtn.addEventListener('click', async () => {
    try {
      el.scanAllBtn.disabled = true;
      el.scanCancelBtn && (el.scanCancelBtn.disabled = false);
      if(el.symbolStatus) el.symbolStatus.innerText = 'Fetching symbol list...';
      const symbols = await fetchAllUSDTSymbols();
      if(el.symbolStatus) el.symbolStatus.innerText = `Found ${symbols.length} USDT pairs — scanning...`;
      await analyzeSymbolsInBatches(symbols, { allowIfNotRunning: true, phaseFilterText: 'Blowoff Forming' });
    } catch(err) {
      console.error('scanAll error', err);
      if(el.symbolStatus) el.symbolStatus.innerText = `Scan error: ${err.message}`;
    } finally {
      el.scanAllBtn.disabled = false;
      if(el.scanCancelBtn) el.scanCancelBtn.disabled = true;
    }
  });
}

if(el.scanCancelBtn) {
  el.scanCancelBtn.addEventListener('click', () => {
    allScanAbort = true;
    if(el.symbolStatus) el.symbolStatus.innerText = 'Scan cancelled by user.';
  });
}
  
  // respect cache
  const cached = getCachedSymbol(sym);
  if(cached) {
    el.symbolStatus.innerText = `Loaded ${sym} from cache (${Math.round((Date.now()-cached._cachedAt)/1000)}s ago)`;
    return cached;
  }

  // rate-limit manual lookups to avoid bursts (user clicks many times)
  const since = Date.now() - lastSymbolReq;
  if(since < MIN_MS_BETWEEN_SYMBOL_REQ) {
    const wait = MIN_MS_BETWEEN_SYMBOL_REQ - since;
    await delay(wait);
  }
  lastSymbolReq = Date.now();

  // validate symbol exists (lazy)
  const exch = await ensureExchangeInfo().catch(()=>null);
  if(exch && Array.isArray(exch.symbols)) {
    const found = exch.symbols.find(s => s.symbol === sym);
    if(!found) {
      el.symbolStatus.innerText = `Symbol ${sym} not found in exchangeInfo (not listed?)`;
      // still proceed to try fetch; maybe it's a newly-listed token
    } else {
      // optional: ensure quoteAsset is USDT
      if(found.quoteAsset !== 'USDT') {
        el.symbolStatus.innerText = `Symbol ${sym} found but quoteAsset=${found.quoteAsset}. Expected USDT. Proceeding anyway.`;
      }
    }
  }

  el.symbolStatus.innerText = `Fetching ${sym} data...`;

  try {
    // Fetch only what's needed (4h, 1h, 15m klines + funding)
    const promises = [
      safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${sym}&interval=4h&limit=40`, { allowIfNotRunning: opts.allowIfNotRunning }),
      safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${sym}&interval=1h&limit=60`, { allowIfNotRunning: opts.allowIfNotRunning }),
      safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${sym}&interval=15m&limit=80`, { allowIfNotRunning: opts.allowIfNotRunning }),
      safeFetch(`${API_BASE}/fapi/v1/fundingRate?symbol=${sym}&limit=1`, { allowIfNotRunning: opts.allowIfNotRunning })
    ];
    const [k4h, k1h, k15, f] = await Promise.all(promises);

    // build features just like queueSymbolAnalysis
    const closes4h = (k4h||[]).map(k=>Number(k[4])); const highs4h=(k4h||[]).map(k=>Number(k[2])); const lows4h=(k4h||[]).map(k=>Number(k[3])); const vols4h=(k4h||[]).map(k=>Number(k[5]));
    const closes1h = (k1h||[]).map(k=>Number(k[4])); const highs1h=(k1h||[]).map(k=>Number(k[2])); const lows1h=(k1h||[]).map(k=>Number(k[3])); const vols1h=(k1h||[]).map(k=>Number(k[5]));
    const closes15 = (k15||[]).map(k=>Number(k[4])); const highs15=(k15||[]).map(k=>Number(k[2])); const lows15=(k15||[]).map(k=>Number(k[3])); const vols15=(k15||[]).map(k=>Number(k[5]));

    const last4 = (k4h && k4h.length) ? k4h[k4h.length-1] : null;
    if(!last4) throw new Error('No 4H candles returned');

    const open4 = Number(last4[1]), high4 = Number(last4[2]), low4 = Number(last4[3]), close4 = Number(last4[4]);
    const body4 = Math.abs(close4 - open4) || 1e-9;
    const wickTop4 = Math.max(0, high4 - Math.max(open4, close4));
    const wickRatio4 = wickTop4 / body4;
    const volMA4 = sma(vols4h, Math.min(10, vols4h.length)) || 1;
    const volSpike4 = Number((Number(last4[5]) / volMA4).toFixed(2));
    const ema70_4 = ema(closes4h, 70) || ema(closes4h, Math.min(21, closes4h.length));
    const emaDistPct = ema70_4 ? Number(pct(close4, ema70_4).toFixed(2)) : 0;
    const rsi4h = rsiFromCloses(closes4h, 14);
    const rsi1d = rsiFromCloses(closes4h.slice(-9).map(v=>v), 14);
    const lowerHigh = (k4h && k4h.length>1) ? Number(high4) < Number(k4h[k4h.length-2][2]) : false;
    const fundingRate = (f && f.length) ? Number(f[0].fundingRate) : 0;
    const rsi1h = rsiFromCloses(closes1h, 14);
    const rsi15 = rsiFromCloses(closes15, 14);
    const volMA15 = sma(vols15, Math.min(10, vols15.length)) || 1;
    const volSpike15 = Number((Number(closes15.length ? vols15[vols15.length-1] : 1) / volMA15).toFixed(2));

    // accumulation checks
    const sens = parseInt(el.sensitivity.value,10) || 50;
    const acc15 = detectAccumulationGeneric(closes15, highs15, lows15, vols15, 30, sens);
    const acc1h = detectAccumulationGeneric(closes1h, highs1h, lows1h, vols1h, 30, sens);
    const acc4h = detectAccumulationGeneric(closes4h, highs4h, lows4h, vols4h, 20, sens);
    const tfChecks = [
      { tf:'15m', result: acc15 },
      { tf:'1h', result: acc1h },
      { tf:'4h', result: acc4h }
    ];
    let combinedConfidence = 0;
    if(tfChecks.length){
      let weightSum = 0;
      tfChecks.forEach(t=>{
        const w = (t.tf === '4h') ? 1.2 : (t.tf === '1h' ? 1.0 : 0.8);
        combinedConfidence += (t.result.confidence || 0) * w;
        weightSum += w;
      });
      combinedConfidence = Math.round(combinedConfidence / weightSum);
    }

    const preCrash = detectPreCrash({
      rsi4h,
      volSpike4,
      wickRatio4,
      ema70DistPct: emaDistPct,
      dropPctFromPeak: pct(close4, ema70_4) || 0,
      fundingRate,
      k4h
    });

    // build the result object (compatible shape)
    const result = {
      symbol: sym,
      score: 0, // we didn't run the multi-signal score aggregator here; you can run detectPhaseForSymbol if you want
      signals: {},
      rsi1d, rsi4h, rsi1h, rsi15,
      volSpike4, volSpike15,
      wickRatio4,
      ema70DistPct: emaDistPct,
      lowerHigh,
      fundingRate,
      closeNow: close4,
      k4h, k1h, k15m: k15,
      accumChecks: tfChecks,
      accumCombined: { confidence: combinedConfidence, isAccum: combinedConfidence >= Math.max(45, (100 - sens) * 0.6) },
      preCrash,
      // annotate detection results:
      phase: detectPhaseForSymbol({
        rsi4h, wickRatio4, volSpike4, accumCombined: { confidence: combinedConfidence, isAccum: combinedConfidence >= Math.max(45, (100 - sens) * 0.6) },
        k4h, k15m: k15, closeNow: close4, ema70DistPct: emaDistPct
      }),
      returnToNormal: detectReturnToNormal({ k4h, rsi4h, closeNow: close4 }, { sensitivity: sens })
    };

// --- FIXED FULL-CYCLE REFERENCE VECTOR ---
const FIXED_FULL_CYCLE = {
  rsi4h: 30,
  volSpike4: 5.0,
  wickRatio4: 6.0,
  ema70DistPct: 150,
  fundingRate: -0.2,
  slope15: -1,
  dropPctFromPeak: 85,
  accumCombined: { confidence: 20, isAccum: false }
};

// Build the static reference vector
let baseVector = makeFeatureVector(FIXED_FULL_CYCLE);

// Compute similarity for THIS symbol only
try {
  const v = makeFeatureVector(result);
  result.similarity = cosineSim(v, baseVector);
  result.simPhase = classifySimilarityPhase(result.similarity);
} catch(err) {
  result.similarity = 0;
  result.simPhase = classifySimilarityPhase(0);
}
    
    // final recommendations, targets, short-term rec
    result.expl = explainBlowoff(result);
    result.finalRec = getFinalRecommendation(result);
    result.shortRec = getShortTermRecommendation(result);
    result.longTargets = getLongTermTargets(result);

    // save to cache
    result._cachedAt = Date.now();
    setCachedSymbol(sym, result);

    el.symbolStatus.innerText = `Analyzed ${sym} • accum ${result.accumCombined.confidence}% • rsi4h ${Math.round(result.rsi4h||0)}`;
    return result;
  } catch(err){
    el.symbolStatus.innerText = `Analyze ${sym} failed: ${err.message}`;
    throw err;
  }
}

// UI: analyze button
el.symbolSearchBtn.addEventListener('click', async () => {
  const sym = (el.symbolSearch.value || '').trim().toUpperCase();
  if(!sym){ el.symbolStatus.innerText = 'Enter a symbol (e.g. BTCUSDT)'; return; }
  try {
    el.symbolSearchBtn.disabled = true;
    const res = await analyzeSymbol(sym, { allowIfNotRunning: true });
    // render result in the tradeInterpret panel and also show the card view for the single symbol
    updateTradingInterpretation([res]); // will show this item as the interpretation
    // render as single-card UI: reuse renderCards with [res]
    if(window.innerWidth >= 680) {
      // render table view with one row
      renderTable([res]);
    } else {
      renderCards([res]);
    }
  } catch(e) {
    console.warn('symbol analysis error', e);
  } finally {
    el.symbolSearchBtn.disabled = false;
  }
});

// bonus: support pressing Enter in input to search
el.symbolSearch.addEventListener('keydown', (ev) => {
  if(ev.key === 'Enter') { ev.preventDefault(); el.symbolSearchBtn.click(); }
});

let running=false, queue=[], totalTasks=0, doneTasks=0, autoTimer=null, countdownTimer=null;
let requestsThisWindow=0, windowStart=Date.now(), SAFETY_WINDOW_MS=60000, SAFETY_MAX=900, SAFETY_PAUSE=30;
let prevBlowoffSet = new Set();
window.lastScanResults = null; // persist latest results for sorting/re-render

/* ---------- UTIL ---------- */
function delay(ms){ return new Promise(r=>setTimeout(r,ms)); }
function sma(arr,n){ if(!arr||arr.length<n) return null; let s=0; for(let i=arr.length-n;i<arr.length;i++) s+=arr[i]; return s/n; }
function ema(arr,p){ if(!arr||arr.length===0) return null; const k=2/(p+1); let e=arr[0]; for(let i=1;i<arr.length;i++) e = arr[i]*k + e*(1-k); return e; }
function rsiFromCloses(closes,period=14){ if(!closes||closes.length<=period) return null; let g=0,l=0; for(let i=closes.length-period;i<closes.length;i++){ const d=closes[i]-closes[i-1]; if(d>0) g+=d; else l+=Math.abs(d);} const ag=g/period, al=l/period; if(al===0) return 100; const rs=ag/al; return 100 - (100/(1+rs)); }
function pct(a,b){ return b===0?0:((a-b)/b)*100; }
function stdDev(arr){ if(!arr||arr.length===0) return 0; const mean = arr.reduce((s,x)=>s+x,0)/arr.length; const v = arr.reduce((s,x)=>s+Math.pow(x-mean,2),0)/arr.length; return Math.sqrt(v); }
function dot(a,b){ let s=0; for(let i=0;i<a.length;i++) s+=a[i]*b[i]; return s; }
function norm(a){ return Math.sqrt(a.reduce((s,x)=>s+x*x,0)); }
function cosineSim(a,b){ const n=dot(a,b); const d=norm(a)*norm(b); return d===0?0:n/d; }

/* ------------------------------
   RETURN TO NORMAL DETECTOR
   (same as before)
   ------------------------------ */
function detectReturnToNormal(item, opts = {}) {
  const o = Object.assign({
    lookback4h: 12,
    emaSlopeWindow: 6,
    volWindow: 8,
    rsiMax: 70,
    relSdMaxPct: 10,
    higherLowPct: 0.0,
    sensitivity: 50
  }, opts);

  try {
    const k4 = item.k4h || [];
    const close = item.closeNow || (k4.length ? Number(k4[k4.length-1][4]) : 0);

    if(!k4 || k4.length < Math.max(8, o.lookback4h)) {
      return {isReturn:false, score:0, reasons:['insufficient 4H candles'], confidence:0, meta:{}};
    }

    const closes4 = k4.map(k => Number(k[4]));
    const vols4  = k4.map(k => Number(k[5]));

    // higher-low: split the lookback window in two halves and compare minima
    const look = Math.min(o.lookback4h, closes4.length - 1);
    const slice = closes4.slice(-look - 1);
    const half = Math.floor(slice.length/2);
    const left = slice.slice(0, half);
    const right = slice.slice(half);
    const leftMin = left.length ? Math.min(...left) : Math.min(...slice);
    const rightMin = right.length ? Math.min(...right) : Math.min(...slice);
    const higherLow = rightMin >= leftMin * (1 - o.higherLowPct);

    // EMA slope approximate
    const closesForSlope = closes4.slice(-o.emaSlopeWindow - 1);
    const lastEma14 = (() => {
      const arr = closesForSlope.slice(-o.emaSlopeWindow);
      if(!arr.length) return null;
      return ema(arr, 14);
    })();
    const prevEma14 = (() => {
      const arr = closesForSlope.slice(0, Math.max(0, closesForSlope.length - 1));
      if(!arr.length) return null;
      return ema(arr, 14);
    })();
    const emaSlope = (lastEma14 && prevEma14) ? (lastEma14 - prevEma14) : 0;

    // relative stddev
    const recentCloses = closes4.slice(-o.lookback4h);
    const relSD = (() => {
      const sd = stdDev(recentCloses);
      const mean = recentCloses.reduce((s,x)=>s+x,0)/recentCloses.length;
      return mean ? (sd/mean)*100 : 999;
    })();

    // volume taper
    const volMA = sma(vols4, Math.min(o.volWindow, vols4.length)) || 1;
    const lastVol = vols4[vols4.length-1] || 0;
    const volTaper = lastVol < volMA * (1 + (50 - o.sensitivity)/200);

    // rsi moderate
    const rsi4 = item.rsi4h || rsiFromCloses(closes4, 14) || 50;
    const rsiOK = rsi4 <= Math.max(65, o.rsiMax);

    let score = 0; const reasons = [];
    if(higherLow){ score += 3; reasons.push('higher-low structure'); } else reasons.push('no clear higher-low');
    if(emaSlope > 0){ score += 2; reasons.push('EMA slope up'); }
    else if(Math.abs(emaSlope) < (Math.max(1e-6, Math.abs(lastEma14||1)) * 0.001)) { score += 1; reasons.push('EMAs flattening'); }
    if(relSD <= o.relSdMaxPct){ score += 2; reasons.push(`low volatility ${relSD.toFixed(2)}%`); }
    else if(relSD <= o.relSdMaxPct * 1.6){ score += 1; reasons.push('reduced volatility'); }
    if(volTaper){ score += 1; reasons.push('volume taper (absorption)'); }
    if(rsiOK){ score += 1; reasons.push(`RSI ${Math.round(rsi4)}`); }

    const maxScore = 9;
    const confidence = Math.round((score / maxScore) * 100);
    const isReturn = score >= Math.max(4, Math.round(4 * (0.8 + (50 - o.sensitivity)/200)));
    const meta = {higherLow, emaSlope, relSD, volMA, lastVol, rsi4, score, lookback:o.lookback4h};

    return {isReturn, score, reasons, confidence, meta};
  } catch(err) {
    return {isReturn:false, score:0, reasons:[`error ${err.message}`], confidence:0, meta:{}};
  }
}

/* --------------------------
   PRE-CRASH / BLOWOFF DETECTOR
-------------------------- */
function detectPreCrash(item, opts={}) {
  const sensitivity = parseInt(el.sensitivity.value,10) || 50;
  const t = {
    rsi4h: 78 - Math.round((sensitivity-50)/2),
    volSpike4: 2.0 - (sensitivity-50)/250,
    wickRatio: 1.2 - (sensitivity-50)/500,
    emaDistPct: 40 - Math.round((sensitivity-50)/1.5),
    dropFromPeak: 8 - Math.round((sensitivity-50)/10)
  };

  try {
    const rsi4h = item.rsi4h || 0;
    const vol = Number(item.volSpike4 || 0);
    const wick = Number(item.wickRatio4 || 0);
    const emaDist = Math.abs(Number(item.ema70DistPct || 0));
    const dropPct = Number(item.dropPctFromPeak || 0);
    const funding = item.fundingRate || 0;

    // lower-highs count from k4h if present
    let lowerHCount = 0;
    if(Array.isArray(item.k4h) && item.k4h.length >= 6){
      const highs = item.k4h.slice(-8).map(k => Number(k[2]));
      for(let i=1;i<highs.length;i++) if(highs[i] < highs[i-1]) lowerHCount++;
    }

    let score = 0; const reasons = [];

    // core blowoff signals
    if(vol >= Math.max(1.8, t.volSpike4)){ score += 3; reasons.push(`Vol spike ×${vol}`); }
    else if(vol >= Math.max(1.2, t.volSpike4*0.7)){ score += 1; reasons.push(`Vol uptick ×${vol}`); }

    if(wick >= Math.max(1.2, t.wickRatio)){ score += 3; reasons.push(`Upper wick ratio ${wick.toFixed(2)}`); }
    else if(wick >= Math.max(0.9, t.wickRatio*0.7)){ score += 1; reasons.push(`Wick present ${wick.toFixed(2)}`); }

    if(rsi4h >= t.rsi4h){ score += 2; reasons.push(`RSI4H ${Math.round(rsi4h)}`); }
    else if(rsi4h >= t.rsi4h - 8){ score += 1; reasons.push(`RSI elevated ${Math.round(rsi4h)}`); }

    if(emaDist >= Math.max(30, t.emaDistPct)){ score += 2; reasons.push(`EMA stretch ${Math.round(emaDist)}%`); }

    if(lowerHCount >= 2){ score += 2; reasons.push(`Lower highs (${lowerHCount})`); }
    if(dropPct >= Math.max(6, t.dropFromPeak)){ score += 1; reasons.push(`Drop from peak ${dropPct.toFixed(1)}%`); }

    if(typeof funding === 'number' && funding < -0.001){ score += 1; reasons.push(`Funding neg ${(funding*100).toFixed(3)}%`); }

    // reduce score if accumulation looks strong
    const accumConf = item.accumCombined ? (item.accumCombined.confidence || 0) : 0;
    if(accumConf >= 60){ score = Math.max(0, score - 2); reasons.push('Strong accumulation reduces immediate crash odds'); }

    const maxScore = 13;
    const confidence = Math.round((score / maxScore) * 100);
    const likely = (score >= 7 && confidence >= 45 && accumConf < 65) || (score >= 9);

    return { likely, score, reasons, confidence, meta: { rsi4h, vol, wick, emaDist, dropPct, funding, lowerHCount, accumConf } };
  } catch(err){
    return { likely:false, score:0, reasons:[`error ${err.message}`], confidence:0, meta:{} };
  }
}

  // ------------------------ SCAN ALL USDT PERPETUAL FOR BLOWOFF FORMING ------------------------

async function scanAllUSDTBlowoffForming() {
    el.message.innerText = "Scanning all USDT perpetual pairs...";
    el.tableView.innerHTML = "";
    el.cardView.innerHTML = "";

    try {
        // 1. Load all Binance USDT perpetual symbols
        const info = await safeFetch(API_BASE + "/fapi/v1/exchangeInfo", { allowIfNotRunning: true });
        const symbols = info.symbols
            .filter(s => s.contractType === "PERPETUAL" && s.quoteAsset === "USDT")
            .map(s => s.symbol);

        el.message.innerText = `Scanning ${symbols.length} symbols...`;

        const results = [];

        for (let i = 0; i < symbols.length; i++) {
            const sym = symbols[i];
            el.message.innerText = `Scanning ${i+1}/${symbols.length}: ${sym}...`;

            try {
                // use your existing single-symbol analyzer
                const r = await analyzeSymbol(sym, { allowIfNotRunning: true });

                // include similarity-phase AND blowoff-phase
                const phaseName = (r.phase && r.phase.name) ? r.phase.name.toLowerCase() : "";
                const simPhase = (r.simPhase || "").toLowerCase();

                const isBlowoffForming =
                    phaseName.includes("blowoff forming") ||
                    simPhase.includes("blowoff forming");

                if (isBlowoffForming) {
                    results.push(r);
                }
            } catch (err) {
                console.warn("scan error:", sym, err.message);
            }

            await delay(300); // prevent rate-limit
        }

        el.message.innerText = `Found ${results.length} blowoff-forming coins.`;

        if (results.length === 0) {
            el.tableView.innerHTML = "<div style='padding:10px'>No blowoff-forming symbols found.</div>";
            return;
        }

        renderTable(results);
        renderCards(results);

    } catch (e) {
        el.message.innerText = "Scan failed: " + e.message;
    }
}

// wire button
document.getElementById("scanAllBtn").addEventListener("click", scanAllUSDTBlowoffForming);

/* ---------- SAFE FETCH ---------- */
async function safeFetch(url, opts = { allowIfNotRunning: false }) {
  if(!running && !opts.allowIfNotRunning) throw new Error('Not running (call Start first)');
  try {
    requestsThisWindow++;
    const r = await fetch(url);
    if(!r.ok) {
      const body = await r.text().catch(()=>'<no body>');
      throw new Error(`HTTP ${r.status} ${r.statusText} — ${body.slice(0,200)}`);
    }
    return await r.json();
  } catch (err) {
    throw new Error(`fetch error for ${url} → ${err.message}`);
  }
}

function resetWindow(){ requestsThisWindow=0; windowStart=Date.now(); }
function checkSafetyAndMaybePause(){
  const now=Date.now();
  if(now-windowStart > SAFETY_WINDOW_MS){ resetWindow(); el.safetyStatus.innerText='Safety OK'; return false; }
  if(requestsThisWindow > SAFETY_MAX){
    running=false;
    el.safetyStatus.innerText = `Auto-paused: ${requestsThisWindow} req/min`;
    el.message.innerText = `Auto-paused ${SAFETY_PAUSE}s to avoid rate limit.`;
    el.startBtn.disabled=false; el.stopBtn.disabled=true;
    setTimeout(()=>{ resetWindow(); const cur = Math.max(200, parseInt(el.delay.value,10)||450); el.delay.value = Math.min(2000, Math.round(cur * 1.5)); el.safetyStatus.innerText='Resumed after pause'; el.message.innerText='Resumed'; }, SAFETY_PAUSE*1000);
    return true;
  }
  el.safetyStatus.innerText = `Req/min: ${requestsThisWindow}`;
  return false;
}

/* ---------- TOP N ---------- */
async function getTopN(n){
  const tickers = await safeFetch(API_BASE + '/fapi/v1/ticker/24hr');
  const usdt = tickers.filter(t => t.symbol && t.symbol.endsWith('USDT') && !blacklist.includes(t.symbol));
  usdt.sort((a,b)=> parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent));
  return usdt.slice(0,n).map(x=>({symbol:x.symbol, last: Number(x.lastPrice), change24: Number(x.priceChangePercent)}));
}

/* ---------- ACCUMULATION DETECTOR ---------- */
// ... same detectAccumulationGeneric function from original (kept as-is)
function detectAccumulationGeneric(closes, highs, lows, vols, period=30, sensitivity=50){
  const len = Math.min(period, closes.length);
  if(len < 10) return {isAccum:false, score:0, reasons:[], confidence:0, relSD:0};
  const sliceC = closes.slice(-len), sliceH = highs.slice(-len), sliceL = lows.slice(-len), sliceV = vols.slice(-len);
  const mean = sliceC.reduce((s,x)=>s+x,0)/sliceC.length;
  const sd = stdDev(sliceC);
  const relSD = mean? (sd/mean)*100 : 0;
  const reasons = [];
  let score = 0;
  const relSD_threshold_strict = 2.5;
  const relSD_threshold_loose = 6.0;
  const relSD_threshold = relSD_threshold_strict + (1 - (sensitivity/100)) * (relSD_threshold_loose - relSD_threshold_strict);
  if(relSD <= relSD_threshold){ score += 3; reasons.push(`low volatility ${relSD.toFixed(2)}% ≤ ${relSD_threshold.toFixed(2)}%`); }
  else if(relSD <= relSD_threshold*1.6){ score += 1; reasons.push(`reduced volatility ${relSD.toFixed(2)}%`); }
  let lowerLowCount=0;
  for(let i=1;i<sliceL.length;i++) if(sliceL[i] < sliceL[i-1]) lowerLowCount++;
  const lowerLow_max = 2 + Math.round((100 - sensitivity)/50);
  if(lowerLowCount <= lowerLow_max){ score += 2; reasons.push(`limited lower-lows (${lowerLowCount} ≤ ${lowerLow_max})`); }
  else reasons.push(`lower-lows (${lowerLowCount})`);
  const volBaseline = sma(sliceV, Math.min(8, sliceV.length)) || 0.000001;
  let upCount = 0, upVolHigher = 0;
  for(let i=1;i<sliceC.length;i++){
    if(sliceC[i] > sliceC[i-1]){ upCount++; if(sliceV[i] > volBaseline * (1 + (50 - sensitivity)/200)) upVolHigher++; }
  }
  if(upCount >= 3 && upVolHigher >= Math.max(1, Math.round(upCount*0.4))){ score += 3; reasons.push(`buyers on higher-volume up-bars (${upVolHigher}/${upCount})`); }
  else if(upCount >= 2){ score += 1; reasons.push(`some up bars (${upCount})`); }
  const e14 = ema(sliceC, Math.min(14, sliceC.length));
  const e21 = ema(sliceC, Math.min(21, sliceC.length));
  if(e14 && e21){
    const slope = e14 - e21;
    const slopeThreshold = (sensitivity/100) * (e21 * 0.01);
    if(slope >= -slopeThreshold){ score += 2; reasons.push('EMAs flat/turning up'); }
    else if(Math.abs(slope) < (e21*0.002 || 0.0001)){ score += 1; reasons.push('EMAs flattening'); }
  }
  const rsi = rsiFromCloses(closes, 14);
  if(rsi && rsi >= 36 - (sensitivity/20)) { score += 1; reasons.push(`RSI stabilizing (${rsi.toFixed(1)})`); }
  const peak = Math.max(...sliceC);
  const latest = sliceC[sliceC.length-1];
  const dropPct = peak? ((peak - latest)/peak)*100 : 0;
  const requiredDrop = 8 - Math.round(sensitivity/20);
  if(dropPct >= Math.max(4, requiredDrop)){ score += 1; reasons.push(`follows drop ${dropPct.toFixed(1)}% (req ${Math.max(4, requiredDrop)}%)`); }
  const maxScore = 12;
  const confidence = Math.min(99, Math.round((score/maxScore)*100));
  const isAccum = score >= Math.max(6, Math.round(6 * (0.8 + (50 - sensitivity)/200)));
  return {isAccum, score, reasons, confidence, relSD};
}

/* ---------- QUEUE ANALYSIS (fetch klines & compute features) ---------- */
function queueSymbolAnalysis(symbol, results){
  queue.push(async ()=>{
    try{
      const promises = [];
      promises.push(safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=4h&limit=40`));
      promises.push(safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=1h&limit=60`));
      promises.push(safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=15m&limit=80`));
      promises.push(safeFetch(`${API_BASE}/fapi/v1/fundingRate?symbol=${symbol}&limit=1`));
      const [k4h, k1h, k15, f] = await Promise.all(promises);

      const closes4h = k4h.map(k=>Number(k[4])); const highs4h = k4h.map(k=>Number(k[2])); const lows4h = k4h.map(k=>Number(k[3])); const vols4h = k4h.map(k=>Number(k[5]));
      const closes1h = k1h.map(k=>Number(k[4])); const highs1h = k1h.map(k=>Number(k[2])); const lows1h = k1h.map(k=>Number(k[3])); const vols1h = k1h.map(k=>Number(k[5]));
      const closes15 = k15.map(k=>Number(k[4])); const highs15 = k15.map(k=>Number(k[2])); const lows15 = k15.map(k=>Number(k[3])); const vols15 = k15.map(k=>Number(k[5]));

      const last4 = k4h[k4h.length-1], prev4 = k4h[k4h.length-2] || last4;
      const open4 = Number(last4[1]), high4 = Number(last4[2]), low4 = Number(last4[3]), close4 = Number(last4[4]);
      const body4 = Math.abs(close4 - open4) || 1e-9;
      const wickTop4 = Math.max(0, high4 - Math.max(open4, close4));
      const wickRatio4 = wickTop4 / body4;
      const volMA4 = sma(vols4h, Math.min(10, vols4h.length)) || 1;
      const volSpike4 = Number((Number(last4[5]) / volMA4).toFixed(2));
      const ema70_4 = ema(closes4h, 70) || ema(closes4h, Math.min(21, closes4h.length));
      const emaDistPct = ema70_4 ? Number(pct(close4, ema70_4).toFixed(2)) : 0;
      const rsi4h = rsiFromCloses(closes4h, 14);
      const rsi1d = rsiFromCloses(closes4h.slice(-9).map((v,i)=>v), 14);
      const lowerHigh = Number(high4) < Number(prev4[2]);
      const fundingRate = (f && f.length) ? Number(f[0].fundingRate) : 0;

      // short-term features (from 15m / 1h)
      const rsi1h = rsiFromCloses(closes1h, 14);
      const rsi15 = rsiFromCloses(closes15, 14);
      const volMA15 = sma(vols15, Math.min(10, vols15.length)) || 1;
      const volSpike15 = Number((Number(closes15.length ? vols15[vols15.length-1] : 1) / volMA15).toFixed(2));

      let score=0;
      const signals={};
      if(rsi1d !== null && rsi1d >= 88){ score++; signals.rsi1d=true; } else signals.rsi1d=false;
      if(rsi4h !== null && rsi4h >= 80){ score++; signals.rsi4h=true; } else signals.rsi4h=false;
      if(volSpike4 >= 1.8){ score++; signals.volSpike=true; } else signals.volSpike=false;
      if(wickRatio4 >= 1.2){ score++; signals.wickTop=true; } else signals.wickTop=false;
      if(emaDistPct >= 50){ score++; signals.emaDist=true; } else signals.emaDist=false;
      if(lowerHigh){ score++; signals.lowerHigh=true; } else signals.lowerHigh=false;
      if(typeof fundingRate === 'number' && fundingRate < -0.0005){ score++; signals.fundingConfirm=true; } else signals.fundingConfirm=false;
      signals.funding = fundingRate;

      const sens = parseInt(el.sensitivity.value,10) || 50;
      const tfChecks = [];
      if(el.tf15.checked){
        const acc15 = detectAccumulationGeneric(closes15, highs15, lows15, vols15, 30, sens);
        tfChecks.push({tf:'15m', result:acc15});
      }
      if(el.tf1h.checked){
        const acc1h = detectAccumulationGeneric(closes1h, highs1h, lows1h, vols1h, 30, sens);
        tfChecks.push({tf:'1h', result:acc1h});
      }
      if(el.tf4h.checked){
        const acc4h = detectAccumulationGeneric(closes4h, highs4h, lows4h, vols4h, 20, sens);
        tfChecks.push({tf:'4h', result:acc4h});
      }

      let combinedConfidence = 0;
      if(tfChecks.length){
        let weightSum = 0;
        tfChecks.forEach(t=>{
          const w = (t.tf === '4h') ? 1.2 : (t.tf === '1h' ? 1.0 : 0.8);
          combinedConfidence += (t.result.confidence || 0) * w;
          weightSum += w;
        });
        combinedConfidence = Math.round(combinedConfidence / weightSum);
      }

      // --- add preCrash detection (insert BEFORE results.push)
      const preCrash = detectPreCrash({
        rsi4h,
        volSpike4,
        wickRatio4,
        ema70DistPct: emaDistPct,
        dropPctFromPeak: pct(close4, ema70_4) || 0,
        fundingRate,
        k4h
      });

      results.push({
        symbol,
        score,
        signals,
        rsi1d, rsi4h,
        rsi1h, rsi15,
        volSpike4, volSpike15,
        wickRatio4,
        ema70DistPct: emaDistPct,
        lowerHigh,
        fundingRate,
        closeNow: close4,
        k4h, k1h, k15m: k15,
        accumChecks: tfChecks,
        accumCombined: { confidence: combinedConfidence, isAccum: combinedConfidence >= Math.max(45, (100 - sens) * 0.6) },
        preCrash
      });

    } catch(err){
      el.debug.innerText += `\nError ${symbol}: ${err.message}`;
    }
  });
}

/* ---------- PHASE DETECTION & HELPERS ---------- */
function detectPhaseForSymbol(item){
  try{
    const k4 = item.k4h || [], k15 = item.k15m || [];
    const rsi4h = item.rsi4h || 0;
    const vol = item.volSpike4 || 1;
    const wick = item.wickRatio4 || 0;
    const reasons = [];
    let score = 0;

    const highs = k4.slice(-8).map(k=>Number(k[2]));
    let lowerHCount=0; for(let i=1;i<highs.length;i++) if(highs[i]<highs[i-1]) lowerHCount++;

    const highest4h = k4.length ? Math.max(...k4.map(k=>Number(k[2]))) : (item.closeNow || 0);
    const lastClose = item.closeNow || 0;
    const dropPctFromPeak = highest4h ? Math.abs((lastClose - highest4h)/highest4h)*100 : 0;

    if(item.accumCombined && item.accumCombined.isAccum){ reasons.push(`Accumulation seen (combined ${item.accumCombined.confidence}%)`); score += 4; }

    if(wick >= 1.8 && vol >= 3 && rsi4h >= 85){ score += 3; reasons.push('Climax candle'); }
    const recentHigh15 = k15.length ? Math.max(...k15.map(k=>Number(k[2]))) : 0;
    const recentLow15 = k15.length ? Math.min(...k15.map(k=>Number(k[3]))) : 0;
    const range15 = recentHigh15 - recentLow15;
    if(range15 > 0 && (Math.abs(range15) / (recentLow15 || 1)) <= 0.12 && rsi4h >= 60){ score += 2; reasons.push('Distribution'); }
    if(lowerHCount >= 3){ score += 2; reasons.push('Breakdown: lower highs'); }
    if(dropPctFromPeak >= 20 && vol >= 2.5){ score += 3; reasons.push('Capitulation A'); }
    if(k15.length > 20){
      const closes15 = k15.map(k=>Number(k[4]));
      const recentSlice = closes15.slice(-20);
      const localMin = Math.min(...recentSlice);
      const afterMin = recentSlice.slice(recentSlice.indexOf(localMin)+1);
      if(afterMin.length){
        const bouncePct = ((afterMin[afterMin.length-1] - localMin)/localMin)*100;
        if(bouncePct >= 8 && bouncePct <= 60){ score += 1; reasons.push(`Dead-cat bounce ${bouncePct.toFixed(1)}%`); }
      }
    }

    const candidates = [];
    if(item.accumCombined && item.accumCombined.isAccum) candidates.push({phase:'Accumulation / Re-accumulation', priority:9});
    if(score >= 9 && reasons.some(r=>r.includes('Final capitulation'))) candidates.push({phase:'Final capitulation wick', priority:8});
    if(score >= 7 && reasons.some(r=>r.includes('Capitulation'))) candidates.push({phase:'Capitulation A', priority:7});
    if(score >= 5 && reasons.some(r=>r.includes('Breakdown'))) candidates.push({phase:'Breakdown', priority:6});
    if(score >= 5 && reasons.some(r=>r.includes('Distribution'))) candidates.push({phase:'Distribution / sideways top', priority:5});
    if(score >= 4 && reasons.some(r=>r.includes('Climax'))) candidates.push({phase:'Climax candle (blowoff wick)', priority:5});
    if(score >= 3 && reasons.some(r=>r.includes('Acceleration'))) candidates.push({phase:'Acceleration (vertical move)', priority:4});
    if(reasons.some(r=>r.includes('Dead-cat'))) candidates.push({phase:'Dead-cat bounce', priority:3});
    if(candidates.length === 0){
      if(dropPctFromPeak >= 25 && vol >= 1.8) candidates.push({phase:'Capitulation A', priority:7});
      else if(wick >= 1.6 && rsi4h >= 85) candidates.push({phase:'Climax candle (blowoff wick)', priority:6});
      else if(item.accumCombined && item.accumCombined.confidence >= 55) candidates.push({phase:'Accumulation / Re-accumulation',priority:5});
      else if(range15 <= (Math.max(1,Math.abs(recentLow15||1))*0.08) && rsi4h >= 60) candidates.push({phase:'Distribution / sideways top',priority:5});
      else if(lowerHCount>=2) candidates.push({phase:'Breakdown',priority:6});
      else candidates.push({phase:'Normal/Trending',priority:1});
    }
    candidates.sort((a,b)=> b.priority - a.priority);
    const chosen = candidates[0].phase || 'Unknown';
    const conf = Math.min(98, Math.round((score/14)*100) + (item.accumCombined && item.accumCombined.confidence ? Math.round(item.accumCombined.confidence*0.2) : 0));
    return {phase: chosen, confidence: conf, reasons: reasons, dropPctFromPeak: Math.round(dropPctFromPeak*100)/100};
  } catch(e){
    return {phase:'Unknown', confidence:0, reasons:[], dropPctFromPeak:0};
  }
}

function makeFeatureVector(item){
  const rsi4h = Math.min(100, item.rsi4h || 0)/100;
  const vol = Math.min(10, item.volSpike4 || 1)/5;
  const wick = Math.min(10, item.wickRatio4 || 0)/5;
  const ema = Math.min(500, Math.abs(item.ema70DistPct || 0))/200;
  const funding = (item.fundingRate || 0) * 1000;
  const slope = Math.min(4, Math.max(0, (item.slope15 || 1)/1.5))/2;
  const drop = Math.min(100, item.dropPctFromPeak || 0)/100;
  const accumConf = item.accumCombined ? (item.accumCombined.confidence || 0)/100 : 0;
  return [rsi4h, vol, wick, ema, funding, slope, drop, accumConf];
}

function explainBlowoff(item){
  const p = item;
  let pts=0; const reasons=[];
  if(p.rsi1d !== null && p.rsi1d >= 88){ pts+=2; reasons.push(`1D RSI ${p.rsi1d.toFixed(1)}`); } else if(p.rsi1d !== null && p.rsi1d >= 80){ pts+=1; reasons.push(`1D RSI ${p.rsi1d.toFixed(1)}`); }
  if(p.rsi4h !== null && p.rsi4h >= 85){ pts+=1; reasons.push(`4H RSI ${p.rsi4h.toFixed(1)}`); }
  if(p.volSpike4 >= 3){ pts+=2; reasons.push(`Vol climax ×${p.volSpike4}`);} else if(p.volSpike4 >= 1.8){ pts+=1; reasons.push(`Vol spike ×${p.volSpike4}`);}
  if(p.wickRatio4 >= 2.0){ pts+=2; reasons.push(`Upper wick ratio ${p.wickRatio4.toFixed(2)}`);} else if(p.wickRatio4 >= 1.2){ pts+=1; reasons.push(`Upper wick ${p.wickRatio4.toFixed(2)}`);}
  if(p.ema70DistPct >= 150){ pts+=2; reasons.push(`EMA stretch ${p.ema70DistPct}%`);} else if(p.ema70DistPct >= 50){ pts+=1; reasons.push(`EMA stretch ${p.ema70DistPct}%`);}
  if(typeof p.fundingRate === 'number'){ if(p.fundingRate < -0.001){ pts+=2; reasons.push(`Funding strongly negative ${(p.fundingRate*100).toFixed(3)}%`);} else if(p.fundingRate < -0.0005){ pts+=1; reasons.push(`Funding negative ${(p.fundingRate*100).toFixed(3)}%`);} }
  if(p.lowerHigh){ pts+=1; reasons.push('Lower high'); }
  if(typeof p.score === 'number'){ if(p.score >= 6) pts+=2; else if(p.score >= 4) pts+=1; }
  let label='None', color='#9fb3cc', prob=5;
  if(pts >= 10){ label='Extreme'; color='#e74c3c'; prob=92; } else if(pts >= 7){ label='High'; color='#ff6b43'; prob=78; } else if(pts >= 4){ label='Medium'; color='#ffd966'; prob=55; } else if(pts >= 2){ label='Low'; color='#7bd389'; prob=25; }
  const topReasons = reasons.slice(0,4);
  const explanation = topReasons.length ? `${topReasons.join('; ')}. Estimated reversal probability: ${prob}%.` : `No clear exhaustion signals detected.`;
  return {pts, label, color, prob, explanation, reasons: topReasons};
}

/* ============================================================
   Long-term targets, recommendations, short-term recs kept same...
   (omitted here for brevity but included below - full original code preserved)
   ============================================================ */

/* ---------- (functions getLongTermTargets, getFinalRecommendation,
   getShortTermRecommendation, renderTable, renderCards, buildTradingInterpretation,
   updateTradingInterpretation) ---------- */
/* For brevity in this block I've preserved the original implementations
   exactly as in your prior code — they follow immediately below. */

/* ============================================================
   NEW: Sorting helpers — inserted now
   ============================================================ */

let sortDesc = true; // default Desc
// helper to extract value for sort key
function getValueForKey(r, key) {
  if(!r) return null;
  switch(key){
    case 'score': return r.score || 0;
    case 'similarity': return (r.similarity||0);
    case 'accum': return (r.accumCombined && r.accumCombined.confidence) ? r.accumCombined.confidence : 0;
    case 'preCrash': return (r.preCrash && (typeof r.preCrash.confidence !== 'undefined')) ? r.preCrash.confidence : ((r.preCrash && typeof r.preCrash.score !== 'undefined') ? r.preCrash.score : 0);
    case 'rsi4h': return r.rsi4h || 0;
    case 'ema70DistPct': return Math.abs(r.ema70DistPct || 0);
    case 'last': return r.closeNow || 0;
    case 'symbol': return (r.symbol || '').toUpperCase();
    default: return 0;
  }
}

function sortResults(results) {
  const key = (el.sortBy && el.sortBy.value) ? el.sortBy.value : 'score';
  results.sort((a,b) => {
    const A = getValueForKey(a,key);
    const B = getValueForKey(b,key);

    // alphabetical
    if(key === 'symbol'){
      if(A < B) return sortDesc ? 1 : -1;
      if(A > B) return sortDesc ? -1 : 1;
      return 0;
    }

    // numeric
    if(typeof A === 'number' && typeof B === 'number'){
      if(A === B){
        // tiebreakers: score desc, then similarity desc
        const t = (b.score||0) - (a.score||0);
        if(t !== 0) return t;
        const s = (b.similarity||0) - (a.similarity||0);
        return s;
      }
      return sortDesc ? (B - A) : (A - B);
    }

    // fallback string
    if(String(A) < String(B)) return sortDesc ? 1 : -1;
    if(String(A) > String(B)) return sortDesc ? -1 : 1;
    return 0;
  });
}

/* ============================================================
   Now inject event handlers for the sort controls (wires up to re-render)
   ============================================================ */
if(el.sortDir){
  el.sortDir.addEventListener('click', () => {
    sortDesc = !sortDesc;
    el.sortDir.innerText = sortDesc ? 'Desc' : 'Asc';
    if(window.lastScanResults){
      sortResults(window.lastScanResults);
      if(window.innerWidth >= 680) renderTable(window.lastScanResults);
      else renderCards(window.lastScanResults);
      updateTradingInterpretation(window.lastScanResults);
    }
  });
}
if(el.sortBy){
  el.sortBy.addEventListener('change', () => {
    if(window.lastScanResults){
      sortResults(window.lastScanResults);
      if(window.innerWidth >= 680) renderTable(window.lastScanResults);
      else renderCards(window.lastScanResults);
      updateTradingInterpretation(window.lastScanResults);
    }
  });
}

/* ============================================================
   (Below: original rendering & recommendation functions)
   For readability in this response I will include them verbatim,
   exactly as in your previous file so the app logic remains identical.
   ============================================================ */

/* ---------- Long-term target generator ---------- */
function getLongTermTargets(item){
  try{
    const k4 = item.k4h || [];
    const lastClose = item.closeNow || (k4.length ? Number(k4[k4.length-1][4]) : 0);
    const windowSize = Math.min(40, k4.length);
    const recent = k4.slice(-windowSize);

    let recentHigh = lastClose, recentLow = lastClose;
    if(recent.length){
      recentHigh = Math.max(...recent.map(k => Number(k[2])));
      recentLow = Math.min(...recent.map(k => Number(k[3])));
    }

    let swingHigh = recentHigh;
    if(recent.length >= 6){
      const last24 = recent.slice(-Math.min(24,recent.length));
      const histHigh = Math.max(...last24.map(k=>Number(k[2])));
      swingHigh = histHigh;
    }

    const baseline = Math.max(lastClose, swingHigh * 0.92);
    const t1 = +(Math.max(swingHigh, lastClose) * 1.05).toFixed(6);
    const t2 = +(Math.max(swingHigh, lastClose) * 1.25).toFixed(6);
    const t3 = +(Math.max(swingHigh, lastClose) * 1.6).toFixed(6);

    let volMA = 0;
    try{ volMA = sma((k4||[]).map(k=>Number(k[5])), Math.min(10, k4.length)) || 0; }catch(e){}
    const lastVol = k4.length ? Number(k4[k4.length-1][5]) : 0;
    const volBoost = (volMA && lastVol > volMA*1.8) ? 1.03 : 1.0;

    const t1b = +(t1 * volBoost).toFixed(6);
    const t2b = +(t2 * volBoost).toFixed(6);
    const t3b = +(t3 * volBoost).toFixed(6);

    const s1 = +(recentLow.toFixed(6));
    const s2 = +((recentLow) * 0.92).toFixed(6);
    const s3 = +((recentLow) * 0.80).toFixed(6);

    const fallbackPercent = (p) => +(lastClose * p).toFixed(6);
    return {
      t1: t1b || fallbackPercent(1.05),
      t2: t2b || fallbackPercent(1.25),
      t3: t3b || fallbackPercent(1.6),
      s1: (s1 && s1>0) ? s1 : +((lastClose*0.92).toFixed(6)),
      s2: (s2 && s2>0) ? s2 : +((lastClose*0.85).toFixed(6)),
      s3: (s3 && s3>0) ? s3 : +((lastClose*0.75).toFixed(6)),
      recentHigh, recentLow, swingHigh
    };
  } catch(e){
    const lastClose = item.closeNow || 0;
    return {
      t1: +(lastClose * 1.05).toFixed(6),
      t2: +(lastClose * 1.25).toFixed(6),
      t3: +(lastClose * 1.6).toFixed(6),
      s1: +(lastClose * 0.92).toFixed(6),
      s2: +(lastClose * 0.85).toFixed(6),
      s3: +(lastClose * 0.75).toFixed(6),
      recentHigh: lastClose, recentLow: lastClose, swingHigh: lastClose
    };
  }
}

/* ---------- Final AI recommendation (long-term) ---------- */
function getFinalRecommendation(item){
  const sim = Math.round((item.similarity||0)*100);
  const phase = item.phase && item.phase.phase ? item.phase.phase : (item.phase || 'Unknown');
  let accum = item.accumCombined ? (item.accumCombined.confidence || 0) : 0;
  if(item.returnToNormal && item.returnToNormal.isReturn){
    accum = Math.min(100, accum + Math.round(item.returnToNormal.confidence * 0.12));
  }
  const rsi4h = item.rsi4h || 0;
  const rsi1d = item.rsi1d || 0;
  const wick = item.wickRatio4 || 0;
  const vol = item.volSpike4 || 1;
  const funding = item.fundingRate || 0;
  const drop = item.dropPctFromPeak || 0;
  let sentence = '';
  let rationale = '';
  if(accum >= 65 && phase.includes('Accumulation')){
    sentence = `PIPPIN sim ${sim}% and multi-TF accumulation (${accum}%) suggest early re-accumulation — consider staged long-term entries (starter now, add on 4H/1D confirmation).`;
    rationale = 'Strong accumulation confirmed';
  }
  else if(sim >= 70 && accum >= 50){
    sentence = `High PIPPIN similarity (${sim}%) plus moderate accumulation (${accum}%) — use a small starter, protect with a 4H stop, and scale in after sustained volume and 4H confirmation.`;
    rationale = 'High similarity + moderate accumulation';
  }
  else if((rsi4h >= 78 || wick >= 1.8 || vol >= 3 || funding < -0.001) && accum < 50){
    sentence = `Because 4H is overbought (RSI ${Math.round(rsi4h)}) and accumulation is weak (${accum}%), avoid full long-term positions now; if needed, use a small starter and tight 4H stop — only add after clear 4H/daily accumulation.`;
    rationale = 'Overbought + weak accumulation';
  }
  else if(phase.includes('Distribution') || phase.includes('Breakdown') || phase.includes('Capitulation')){
    sentence = `Distribution/breakdown phase detected — expect further downside pressure; avoid long-term buys until a stable accumulation base and flattening EMAs appear on 4H/1D.`;
    rationale = 'Distribution/Breakdown';
  }
  else if(phase.includes('Dead-cat') || (drop > 10 && accum < 55)){
    sentence = `Looks like a short-lived bounce (dead-cat) with limited accumulation (${accum}%) — do not treat this as a long-term base; wait for a sideways 4H/1D structure.`;
    rationale = 'Dead-cat bounce';
  }
  else if(sim >= 50 && rsi4h < 75 && accum >= 45 && vol >= 1.2){
    sentence = `Structure appears healthy enough for longer-term exposure — consider standard sized positions and add on confirmed 4H higher lows or daily accumulation confirmation.`;
    rationale = 'Healthy trending structure';
  }
  else {
    sentence = `No clear long-term buy signal: use a small starter (if any), protect with a tight stop, and scale in only after clear 4H/1D accumulation and rising green-volume.`;
    rationale = 'Conservative fallback';
  }
  return {sentence, rationale, sim, accum, phase};
}

/* ---------- Short-term recommendation generator ---------- */
function getShortTermRecommendation(item){
  const rsi15 = item.rsi15 || 0;
  const rsi1h = item.rsi1h || 0;
  const rsi4h = item.rsi4h || 0;
  const vol15 = item.volSpike15 || 1;
  const vol4 = item.volSpike4 || 1;
  const wick = item.wickRatio4 || 0;
  const accum = item.accumCombined ? item.accumCombined.confidence : 0;
  const phase = item.phase && item.phase.phase ? item.phase.phase : item.phase || 'Unknown';
  const close = Number(item.closeNow || 0) || 0;

  function recentLowFrom(karr, lookback=12){
    if(!Array.isArray(karr) || karr.length===0) return null;
    const slice = karr.slice(-Math.min(lookback, karr.length));
    const lows = slice.map(k => Number(k[3] || k[3] === 0 ? k[3] : NaN)).filter(v => !isNaN(v));
    if(!lows.length) return null;
    return Math.min(...lows);
  }

  const low15 = recentLowFrom(item.k15m, 20);
  const low1h = recentLowFrom(item.k1h, 12);
  const low4h = recentLowFrom(item.k4h, 6);

  const targets = [];
  if(low15 && close > 0 && low15 < close) targets.push(Number(low15.toFixed(6)));
  if(low1h && close > 0 && low1h < close && (targets.indexOf(Number(low1h.toFixed(6))) === -1)) targets.push(Number(low1h.toFixed(6)));
  if(low4h && close > 0 && low4h < close && (targets.indexOf(Number(low4h.toFixed(6))) === -1)) targets.push(Number(low4h.toFixed(6)));

  if(targets.length < 3 && close > 0){
    const percCandidates = [
      +(close * (1 - 0.05)).toFixed(6),
      +(close * (1 - 0.12)).toFixed(6),
      +(close * (1 - 0.20)).toFixed(6)
    ];
    percCandidates.forEach(p => { if(targets.length < 3) targets.push(p); });
  }

  const fmtTargets = targets.map(t => {
    if(typeof t !== 'number' || isNaN(t)) return '—';
    return (Math.abs(t) < 0.0001) ? t.toExponential(6) : (Number(t.toFixed(6)));
  });

  let bias = 'Neutral';
  let sentence = '';
  let plan = '';

  if(phase.includes('Dead-cat') || phase.includes('Breakdown') || (rsi4h >= 78 && accum < 50) || (wick >= 1.0 && vol4 < 1.0 && rsi4h >= 75)){
    bias = 'Bearish';
    sentence = `Short-term bias: Bearish — bounce likely temporary; prefer shorting the rally or waiting for lower re-entry.`;
    plan = `If shorting: enter on a failed bounce or rejection; stop above the recent 4H swing high; take partial profits at first support, trail rest.`;
  } else if(accum >= 60 && rsi15 <= 45 && rsi4h < 65){
    bias = 'Bullish';
    sentence = `Short-term bias: Bullish — corrective pullback with rising accumulation; consider small scalp/long with tight stop.`;
    plan = `Starter on confirmed 15m higher low + green-volume; stop below local 15m low; target near prior 15m/1h resistance.`;
  } else {
    bias = 'Neutral';
    sentence = `Short-term: Neutral—no clean short or long edge. Prefer to wait for a tradeable structure (rejection or 15m higher-low).`;
    plan = `Wait for either a clear rejection (short) or 15m/1h higher-low with volume (long).`;
  }

  return {
    bias,
    sentence,
    plan,
    targets: fmtTargets,
    accum,
    rsi15,
    rsi1h,
    rsi4h,
    vol15,
    vol4
  };
}

/* ---------- RENDER TABLE & CARDS (updated to use window.lastScanResults) ---------- */
function renderTable(results){
  // results expected already sorted by sortResults()
  const threshold = parseInt(el.threshold.value,10)||4;
  const showShort = el.showShort.checked;
  const rows = results.map(r=>{
    const expl = explainBlowoff(r);
    const phaseInfo = r.phase || {phase:'Unknown', confidence:0};
    const accum = r.accumCombined || {confidence:0, isAccum:false};
    const rec = getFinalRecommendation(r);
    const shortRec = getShortTermRecommendation(r);
    const longTargets = getLongTermTargets(r);

    // RTN badge
    const rtnBadge = (r.returnToNormal && r.returnToNormal.isReturn) ? `<span class="phaseTag" style="background:#2dd4bf;color:#04221a;margin-left:6px">Return-to-normal ${r.returnToNormal.confidence}%</span>` : '';

    let statusHtml = `<span class="small">normal</span>`; let bg='background:rgba(255,255,255,0.02)'; let cls='';
    if(r.score >= threshold){ statusHtml = `<span style="background:#ff4d4d;padding:4px 8px;border-radius:6px;font-size:11px;font-weight:bold;">🔥 BLOWOFF</span>`; bg='background:rgba(255,40,40,0.12)'; if(!prevBlowoffSet.has(r.symbol)) cls='blink'; }
    else if(r.score === threshold-1){ statusHtml = `<span style="background:#ffd966;padding:4px 8px;border-radius:6px;font-size:11px;font-weight:bold;color:black;">⚠ POTENTIAL</span>`; bg='background:rgba(255,200,0,0.10)'; }

    const simPct = r.similarity ? Math.round(r.similarity*100) : 0;
    const accumHtml = accum.isAccum ? `<div class="small" style="color:#2dd4bf">Accum: ${accum.confidence}%</div>` : `<div class="small" style="color:var(--muted)">Accum: ${accum.confidence}%</div>`;
    const tfList = (r.accumChecks || []).map(t => `${t.tf}:${t.result.confidence}%${t.result.isAccum? '✓':''}`).join(' | ');
    let phaseColor = '#9fb3cc';
    if(phaseInfo.phase.includes('Capitulation')) phaseColor='#e74c3c';
    else if(phaseInfo.phase.includes('Climax')||phaseInfo.phase.includes('Acceleration')) phaseColor='#ff6b43';
    else if(phaseInfo.phase.includes('Distribution')) phaseColor='#ffd966';
    else if(phaseInfo.phase.includes('Dead-cat')) phaseColor='#7bd389';

    const shortHtml = showShort ? `
      <div class="shortRec">🔎 Short-term: ${shortRec.sentence}</div>
      <div class="recBox" style="background:rgba(255,255,255,0.01)">
        <strong>Short-term Plan:</strong> ${shortRec.plan}<br>
        <strong>Targets:</strong> ${shortRec.targets.join(' • ')}
        <br><em style="color:var(--muted)">Short-term bias: ${shortRec.bias} • RSI15:${Math.round(shortRec.rsi15||0)} • accum:${shortRec.accum}%</em>
      </div>
    ` : '';

    const longTargetsHtml = `
      <div style="margin-top:8px;">
        <strong>Targets (long-term):</strong>
        <div class="recBox">
          <strong>Upside Targets:</strong> ${longTargets.t1} • ${longTargets.t2} • ${longTargets.t3}
          <br><strong>Safety levels:</strong> ${longTargets.s1} • ${longTargets.s2} • ${longTargets.s3}
          <br><em style="color:var(--muted)">Recent H/L: ${longTargets.recentHigh}/${longTargets.recentLow} • SwingHigh:${longTargets.swingHigh}</em>
        </div>
      </div>
    `;

    return `
      <tr class="${cls}" style="${bg}">
        <td>
          <strong>${r.symbol}</strong><br>
          ${statusHtml}
          ${ r.preCrash && r.preCrash.likely ? `<span style="background:#ff5c5c;color:white;padding:4px 6px;border-radius:6px;margin-left:8px">⚠ Pre-crash ${r.preCrash.confidence}%</span>` : '' }
          <span class="phaseTag" style="background:${phaseColor}; color:black;margin-left:8px">${phaseInfo.phase} (${phaseInfo.confidence}%)</span>
          ${rtnBadge}
        </td>
        <td>${r.closeNow}</td>
        <td class="${(r.rsi4h||0)>=80?'green':''}">${r.rsi4h? r.rsi4h.toFixed(1):'n/a'}</td>
        <td class="small">vol×${r.volSpike4} wick:${(r.wickRatio4||0).toFixed(2)} ema:${r.ema70DistPct}%</td>
        <td class="small">${(r.fundingRate||0).toFixed(6)}<br>Cycle sim: <strong>${simPct}%</strong><br>${accumHtml}<div class="small" style="color:#9fb3cc">TFs: ${tfList || '—'}</div></td>
      </tr>
      <div class="small" style="color:#7edcff">
  Cycle Match: <strong>${simPct}%</strong> —
  <span>${r.simPhase || classifySimilarityPhase(r.similarity)}</span>
</div>
      <tr style="background:rgba(255,255,255,0.01)"><td colspan="5" style="padding:8px 12px;color:${expl.color}">
        <strong>${expl.label}</strong> — ${expl.explanation}
        ${r.phase? `<div style="margin-top:6px;color:#cfe8ff">Phase: <strong>${r.phase.phase}</strong> (${r.phase.confidence}%) • ${r.phase.reasons.join('; ')}</div>` : ''}
        ${r.accumCombined && r.accumCombined.isAccum ? `<div style="margin-top:6px;color:#cfe8ff">Accumulation combined: ${r.accumCombined.confidence}% • reasons: ${ (r.accumChecks||[]).map(t => `${t.tf}:${t.result.reasons.join(',')}`).join(' || ') }</div>` : `<div style="margin-top:6px;color:var(--muted)">Accumulation combined: ${r.accumCombined.confidence}%</div>`}
        ${ r.preCrash ? `<div style="margin-top:6px;color:#ffd9d9"><strong>Pre-crash signals:</strong> ${r.preCrash.reasons.join('; ') || '—'} • score ${r.preCrash.score}</div>` : '' }
        <div class="finalRec">🧠 Final AI Recommendation: <strong>${rec.sentence}</strong></div>
        ${longTargetsHtml}
        ${shortHtml}
        <div class="recBox"><strong>Plan (long-term):</strong><br>Starter: ~10% of planned allocation.<br>Stop: below recent 4H consolidation low (use tight stop).<br>Add rules: add only after 2 of — 4H higher low; Volume on green candles ≥ 1.5× volMA; Accumulation confidence ≥ 70% on 4H/combined TFs.<br><em style="color:var(--muted)">Rationale: sim ${rec.sim}%, phase "${rec.phase}", accum ${rec.accum}%</em></div>
      </td></tr>
    `;
  }).join('');
  el.tableView.innerHTML = `<div class="card-panel"><table><thead><tr><th>Symbol / Status</th><th>Last</th><th>RSI4H</th><th>Signals</th><th>Funding / PIPPIN / Accum</th></tr></thead><tbody>${rows}</tbody></table></div>`;
  setTimeout(()=>{ const nodes=document.querySelectorAll('tr.blink'); nodes.forEach(n=>n.classList.remove('blink')); }, 3000);
}

function renderCards(results){
  // assumes results already sorted
  const showShort = el.showShort.checked;
  let html='';
  results.forEach(r=>{
    const expl = explainBlowoff(r); const phase = r.phase || {phase:'Unknown', confidence:0}; const accum = r.accumCombined || {confidence:0, isAccum:false};
    const simPct = Math.round((r.similarity||0)*100);
    const rec = getFinalRecommendation(r);
    const srec = getShortTermRecommendation(r);
    const longTargets = getLongTermTargets(r);
    let badge = `<span class="small" style="color:var(--muted)">normal</span>`; let bc='';
    if(r.score >= (parseInt(el.threshold.value,10)||4)){ badge = `<span class="blowBadge">🔥 Blowoff</span>`; bc='blink'; } else if(r.score === (parseInt(el.threshold.value,10)||4)-1){ badge = `<span class="potBadge">⚠ Potential</span>`; }
    const accBadge = accum.isAccum ? `<span class="accBadge">✔ Accum ${accum.confidence}%</span>` : `<span class="small" style="color:var(--muted)">Accum ${accum.confidence}%</span>`;

    const rtnBadge = (r.returnToNormal && r.returnToNormal.isReturn) ? `<span class="phaseTag" style="background:#2dd4bf;color:#04221a;margin-left:6px">Return-to-normal ${r.returnToNormal.confidence}%</span>` : '';

    const shortHtml = showShort ? `
      <div class="shortRec">🔎 Short-term: ${srec.sentence}</div>
      <div class="recBox" style="background:rgba(255,255,255,0.01)">
        <strong>Short-term Plan:</strong> ${srec.plan}<br>
        <strong>Targets:</strong> ${srec.targets.join(' • ')}
        <br><em style="color:var(--muted)">Bias: ${srec.bias} • RSI15:${Math.round(srec.rsi15||0)} • accum:${srec.accum}%</em>
      </div>
    ` : '';
    html += `
      <div class="coinCard ${bc}">
        <div class="coinRow1"><div class="coinSymbol">${r.symbol}</div><div class="coinScore">${r.score}/8</div></div>
        <div style="margin-top:6px">
          ${badge} ${accBadge}
          ${ r.preCrash && r.preCrash.likely ? `<span style="background:#ff5c5c;color:white;padding:4px 8px;border-radius:6px;margin-left:8px">⚠ Pre-crash ${r.preCrash.confidence}%</span>` : '' }
          ${rtnBadge} <span style="margin-left:8px;font-size:12px;background:var(--glass);padding:4px 8px;border-radius:8px">${phase.phase} ${phase.confidence}%</span>
        </div>
        <div class="sigList">
          Last: ${r.closeNow}<br>
          RSI4H: ${r.rsi4h? r.rsi4h.toFixed(1):'n/a'} • Vol×${r.volSpike4} • Wick:${(r.wickRatio4||0).toFixed(2)}<br>
          EMA∆: ${r.ema70DistPct}% • Funding: ${(r.fundingRate||0).toFixed(6)}<br>
          <small style="color:#cfe8ff">Cycle similarity: <strong>${simPct}%</strong></small>
        </div>
        <div class="small" style="color:#7edcff">
  Cycle Match: <strong>${simPct}%</strong> —
  <span>${r.simPhase || classifySimilarityPhase(r.similarity)}</span>
</div>
        <div style="margin-top:8px;padding-top:8px;border-top:1px dashed rgba(255,255,255,0.03);">
          <div style="color:${expl.color};font-weight:700">${expl.label} — ${expl.prob}% reversal chance</div>
          <div style="color:#cfe8ff;font-size:13px;margin-top:6px">${expl.explanation}</div>
          ${phase.reasons && phase.reasons.length ? `<div style="color:#cfe8ff;margin-top:6px">Phase reasons:<br>• ${phase.reasons.join('<br>• ')}</div>` : ''}
          ${accum.isAccum ? `<div style="color:#cfe8ff;margin-top:6px">Accumulation combined: ${accum.confidence}% • TFs: ${(r.accumChecks||[]).map(t => `${t.tf}:${t.result.confidence}%${t.result.isAccum? '✓':''}`).join(' | ')}</div>` : ''}
          ${ r.preCrash ? `<div style="margin-top:6px;color:#ffd9d9"><strong>Pre-crash signals:</strong> ${r.preCrash.reasons.join('; ') || '—'} • score ${r.preCrash.score}</div>` : '' }
          <div class="finalRec">🧠 Final AI Recommendation: <strong>${rec.sentence}</strong></div>
          ${shortHtml}
          <div style="margin-top:8px">
            <strong>Targets (long-term):</strong>
            <div class="recBox">
              <strong>Upside:</strong> ${longTargets.t1} • ${longTargets.t2} • ${longTargets.t3}
              <br><strong>Safety levels:</strong> ${longTargets.s1} • ${longTargets.s2} • ${longTargets.s3}
              <br><em style="color:var(--muted)">Recent H/L: ${longTargets.recentHigh}/${longTargets.recentLow} • SwingHigh:${longTargets.swingHigh}</em>
            </div>
          </div>
          <div class="recBox"><strong>Plan (long-term):</strong><br>Starter: ~10% of planned allocation.<br>Stop: below recent 4H consolidation low (use tight stop).<br>Add rules: add only after 2 of — 4H higher low; Volume on green candles ≥ 1.5× volMA; Accumulation confidence ≥ 70% on 4H/combined TFs.<br><em style="color:var(--muted)">Rationale: sim ${rec.sim}%, phase "${rec.phase}", accum ${rec.accum}%</em></div>
        </div>
      </div>
    `;
  });
  el.cardView.innerHTML = `<div class="card-panel">${html}</div>`;
  setTimeout(()=>{ const nodes=document.querySelectorAll('.coinCard.blink'); nodes.forEach(n=>n.classList.remove('blink')); }, 3000);
}

/* ---------- Trading interpretation renderer ---------- */
function buildTradingInterpretation(item){
  if(!item) return `<h3>No symbol to interpret</h3><p class="mutedNote">No results yet — run a scan.</p>`;

  const shortRec = getShortTermRecommendation(item);
  const expl = explainBlowoff(item);
  const phase = item.phase ? item.phase.phase : 'Unknown';
  const accum = item.accumCombined ? item.accumCombined.confidence : 0;
  const rsi4h = Math.round((item.rsi4h || 0));
  const funding = typeof item.fundingRate === 'number' ? (item.fundingRate*100).toFixed(3) + '%' : 'n/a';
  const drop = item.dropPctFromPeak || 0;
  const blowoffScore = item.score || 0;
  const wick = (item.wickRatio4||0).toFixed(2);
  const prob = expl.prob || 0;
  const longTargets = getLongTermTargets(item);

  const html = `
    <h3>Quick Trading Interpretation — ${item.symbol}</h3>
    <p><strong>Short-term bias:</strong> <span style="color:${shortRec.bias==='Bearish' ? '#ff9b9b' : (shortRec.bias==='Bullish' ? '#9bffcf' : '#cfe8ff')}">${shortRec.bias}</span></p>

    <div>
      <strong>Why:</strong>
      <ul class="tradeList">
        ${expl.reasons.length ? `<li>${expl.reasons.join('</li><li>')}</li>` : `<li>No major exhaustion points, see signals below.</li>`}
        <li>Dead-cat / structure: ${phase}</li>
        <li>4H RSI: ${rsi4h} (overbought threshold typically ≥75–80)</li>
        <li>Accumulation: ${accum}%</li>
        <li>Funding: ${funding} (negative indicates short pressure)</li>
        <li>Blowoff score: ${blowoffScore}/8 • Wick ratio: ${wick} • Estimated reversal chance: ${prob}%</li>
      </ul>
    </div>

    <div style="margin-top:8px">
      <strong>Short-term trade recommendation</strong>
      <p>${shortRec.sentence}</p>
      <div class="recBox">
        <strong>Plan:</strong> ${shortRec.plan}
        <div style="margin-top:6px"><strong>Targets:</strong> ${shortRec.targets.join(' • ')}</div>
        <div class="mutedNote">Starter size and stop depend on your risk profile. This is NOT financial advice.</div>
      </div>
    </div>

    <div style="margin-top:8px">
      <strong>Long-term plan & targets</strong>
      <div class="recBox">
        <strong>Starter:</strong> ~10% of planned allocation.<br>
        <strong>Stop:</strong> below recent 4H consolidation low.<br>
        <strong>Upside Targets:</strong> ${longTargets.t1} • ${longTargets.t2} • ${longTargets.t3}<br>
        <strong>Downside / Safety levels:</strong> ${longTargets.s1} • ${longTargets.s2} • ${longTargets.s3}<br>
        <em style="color:var(--muted)">Recent H/L: ${longTargets.recentHigh}/${longTargets.recentLow} • SwingHigh:${longTargets.swingHigh}</em>
      </div>
    </div>

    <div style="margin-top:8px">
      <strong>When short-term becomes bullish again</strong>
      <ul class="tradeList">
        <li>4H RSI drops below ~60</li>
        <li>Accumulation rises to ≥ 60–70%</li>
        <li>Confirmed 4H higher lows / rising green-volume</li>
        <li>Funding normalizes (less negative)</li>
      </ul>
    </div>

    <div class="mutedNote">Quick summary: <strong>${shortRec.bias}</strong>. Use small starters, tight stops, and confirm with 4H structure before scaling.</div>
  `;
  return html;
}

function updateTradingInterpretation(results){
  if(!results || !results.length){
    el.tradeInterpret.style.display = 'none';
    el.tradeInterpret.innerHTML = '';
    return;
  }
  const sorted = results.slice().sort((a,b)=> {
    if(b.score !== a.score) return b.score - a.score;
    if((b.similarity||0) !== (a.similarity||0)) return (b.similarity||0) - (a.similarity||0);
    return (b.ema70DistPct||0) - (a.ema70DistPct||0);
  });
  const top = sorted[0];
  el.tradeInterpret.style.display = 'block';
  el.tradeInterpret.innerHTML = buildTradingInterpretation(top);
}

/* ---------- Progress & countdown ---------- */
function updateProgress(){ const pct = totalTasks ? Math.round((doneTasks/totalTasks)*100) : 0; el.bar.style.width = pct + '%'; el.message.innerText = `Scanning ${doneTasks}/${totalTasks} (${pct}%) — delay ${el.delay.value}ms`; el.safetyStatus.innerText = `Req/min: ${requestsThisWindow}`; }
function startCountdown(sec){ if(countdownTimer) clearInterval(countdownTimer); const end = Date.now() + sec*1000; countdownTimer = setInterval(()=>{ const left = Math.max(0, Math.round((end - Date.now())/1000)); el.countdown.innerText = `Next scan in: ${left}s`; if(left <= 0){ clearInterval(countdownTimer); el.countdown.innerText='Running...'; } }, 500); }

/* ---------- MAIN RUN ---------- */
async function runScan(once=false){
  try{
    running=true; el.startBtn.disabled=true; el.stopBtn.disabled=false; el.debug.innerText=''; resetWindow(); el.message.innerText='Fetching top symbols...';
    const N = Math.max(5, Math.min(60, parseInt(el.prefilter.value,10) || 30));
    const delayMs = Math.max(50, Math.min(2000, parseInt(el.delay.value,10) || 450));
    const intervalSec = Math.max(10, Math.min(3600, parseInt(el.interval.value,10) || 60));

    const top = await getTopN(N);
    queue = []; totalTasks = top.length; doneTasks = 0; updateProgress(); const results = [];

    top.forEach(t => queueSymbolAnalysis(t.symbol, results));
    if(!once) startCountdown(intervalSec);

    while(queue.length && running){
      if(checkSafetyAndMaybePause()) break;
      const job = queue.shift();
      try{ await job(); } catch(e){ el.debug.innerText += `\nJob error: ${e.message}`; }
      doneTasks++; updateProgress();
      await delay(delayMs);
    }

    // core phase detection
    results.forEach(r => { r.phase = detectPhaseForSymbol(r); r.dropPctFromPeak = r.phase.dropPctFromPeak || 0; });

    // RUN RETURN-TO-NORMAL DETECTOR & ANNOTATE
    results.forEach(r => {
      const rtn = detectReturnToNormal(r, {sensitivity: parseInt(el.sensitivity.value,10) || 50});
      r.returnToNormal = rtn;
      if(rtn.isReturn){
        if(r.phase && r.phase.reasons) r.phase.reasons.unshift(`Return-to-normal (${rtn.confidence}%)`);
        else r.phase = {phase: 'Return-to-normal', confidence: rtn.confidence, reasons: [`Return-to-normal (${rtn.confidence}%)`] };
        r.phase.isReturnToNormal = true;
      }
    });

    // ---------------------------
// Fixed “Full Cycle” reference vector (parabolic → blowoff → long decay → dead-flat)
// This is a static template derived from the screenshot cycles (MAVIA, COAI, SOON, JELLY, EVAA)
// ---------------------------
const referenceFullCycleVector = {
  // these values are tuned to represent a completed blowoff + decay cycle
  rsi4h: 30,              // washed-out RSI after the decay
  volSpike4: 5.0,         // large spike at blowoff
  wickRatio4: 6.0,        // big upper wick at the top
  ema70DistPct: 150,      // large EMA stretch at peak (in %)
  fundingRate: -0.2,      // negative funding typical post-blowoff
  slope15: -1,            // short-term slope negative (decay)
  dropPctFromPeak: 85,    // huge drop from peak (in %)
  accumCombined: { confidence: 20, isAccum: false } // low accumulation after full flattening
};

// Build a feature vector from the fixed template and compute similarity for every result
try {
  const pippinVector = makeFeatureVector(referenceFullCycleVector);
  results.forEach(r => {
    // ensure makeFeatureVector can accept objects with missing keys safely (it already does)
    r.similarity = cosineSim(makeFeatureVector(r), pippinVector);
  });
} catch(err) {
  console.warn('Error computing static template similarity:', err.message);
  results.forEach(r => r.similarity = 0);
}
    
    // store latest results globally and sort using user's choice
    window.lastScanResults = results;
    sortResults(window.lastScanResults);

    prevBlowoffSet = new Set(window.lastScanResults.filter(r=> r.score >= (parseInt(el.threshold.value,10)||4)).map(r=>r.symbol));
    if(window.innerWidth >= 680) renderTable(window.lastScanResults); else renderCards(window.lastScanResults);

    // update interpretation panel
    updateTradingInterpretation(window.lastScanResults);

    // alerts (same behavior as before)
    const condEnabled = el.condAlert.checked;
    const accumThreshold = Math.max(0, Math.min(100, parseInt(el.accumAlertThreshold.value,10) || 50));
    const blowoffThreshold = parseInt(el.threshold.value,10) || 4;
    const flagged = window.lastScanResults.filter(r => r.score >= blowoffThreshold);
    const flaggedCond = flagged.filter(r => r.accumCombined && r.accumCombined.confidence >= accumThreshold);

    if(condEnabled && flaggedCond.length){
      try{ const audio = new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg'); audio.volume=0.85; audio.play().catch(()=>{}); }catch(e){}
      if(Notification && Notification.permission === 'granted') new Notification('Blowoff+Accum Alert', { body: flaggedCond.map(x => `${x.symbol} acc:${x.accumCombined.confidence}%`).slice(0,6).join(', ') });
      else if(Notification && Notification.permission !== 'denied') Notification.requestPermission();
    } else if(!condEnabled && flagged.length){
      try{ const audio = new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg'); audio.volume=0.7; audio.play().catch(()=>{}); }catch(e){}
      if(Notification && Notification.permission === 'granted') new Notification('Blowoff Detected', { body: flagged.map(f=>f.symbol).slice(0,6).join(', ') });
      else if(Notification && Notification.permission !== 'denied') Notification.requestPermission();
    }

    if(!once){
      if(requestsThisWindow > SAFETY_MAX){ el.debug.innerText += '\nAuto-paused due to safety'; }
      else { if(autoTimer) clearTimeout(autoTimer); autoTimer = setTimeout(()=>{ if(requestsThisWindow <= SAFETY_MAX) runScan(false); }, intervalSec * 1000); startCountdown(intervalSec); }
    }

    running=false; el.startBtn.disabled=false; el.stopBtn.disabled=true;
  } catch(e){
    el.debug.innerText += `\nRun error: ${e.message}`;
    running=false; el.startBtn.disabled=false; el.stopBtn.disabled=true;
  }
}

/* UI events */
el.startBtn.addEventListener('click', ()=>{ if(running) return; prevBlowoffSet = new Set(); runScan(false); });
el.stopBtn.addEventListener('click', ()=>{ running=false; queue=[]; el.startBtn.disabled=false; el.stopBtn.disabled=true; if(autoTimer) clearTimeout(autoTimer); if(countdownTimer) clearInterval(countdownTimer); el.countdown.innerText='Next scan in: -'; el.message.innerText='Stopped.'; });
el.oneShot.addEventListener('click', ()=>{ if(running) return; runScan(true); });
el.sensitivity.addEventListener('input', ()=>{ el.sensVal.innerText = el.sensitivity.value; });
if('Notification' in window){ try{ Notification.requestPermission().catch(()=>{}); } catch(e){} }
(async function ping(){ try{ await fetch(API_BASE + '/fapi/v1/ping'); } catch(e){ console.warn('ping failed', e); } })();

</script>

<footer class="small">Multi-TF accumulation detector + sensitivity + conditional alerts + long-term AI recommendation + short-term trade guidance. Long-term targets (upside) + safety levels included. Run from a local server to avoid CORS.</footer>
</body>
</html>
