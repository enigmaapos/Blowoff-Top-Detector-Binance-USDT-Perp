<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Blowoff Top Detector — Phase, PIPPIN, Multi-TF Accumulation, & Alerts</title>
<style>
  :root{
    --bg:#07101a;
    --card:#0b1220;
    --muted:#9fb3cc;
    --accent:#2dd4bf;
    --danger:#ff7b7b;
    --glass: rgba(255,255,255,0.03);
  }
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:#e6eef8;margin:12px}
  .card-panel{background:var(--card);border:1px solid #172033;padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,.6);margin-bottom:14px}
  h1{margin:0;font-size:18px}
  .controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;align-items:center}
  label{font-size:13px;color:var(--muted)}
  input,select{background:#071722;border:1px solid #243241;color:#e6eef8;padding:6px;border-radius:6px}
  button{background:#1f6feb;border:none;color:white;padding:8px 10px;border-radius:6px;cursor:pointer}
  button.alt{background:#2b3947}
  .status{margin-top:8px;color:var(--muted);font-size:13px;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .progress{height:8px;background:#05101a;border-radius:4px;margin-top:8px;overflow:hidden;flex:1}
  .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#60a5fa);width:0%}
  .countdown{font-weight:700;color:#cfe8ff}
  .mutedBadge{background:var(--glass);color:var(--muted);padding:4px 8px;border-radius:8px;font-size:12px}
  table{width:100%;border-collapse:collapse;margin-top:12px;font-size:13px;min-width:720px}
  th,td{padding:8px 10px;border-bottom:1px dashed #122331;text-align:left;vertical-align:top}
  th{color:var(--muted);font-size:12px}
  .green{color:#66f9a1}
  .red{color:var(--danger)}
  .small{font-size:12px;color:var(--muted)}
  .badge{display:inline-block;padding:4px 8px;border-radius:12px;background:#0f2430;color:#bfeee1;font-size:12px}
  .blink{animation: blinkHighlight 1.8s ease-in-out 3}
  @keyframes blinkHighlight {0%{box-shadow:0 0 0 rgba(255,80,80,0)}50%{box-shadow:0 0 12px rgba(255,80,80,0.35)}100%{box-shadow:0 0 0 rgba(255,80,80,0)}}
  /* mobile card UI */
  #tableView{display:block} #cardView{display:none}
  @media (max-width:680px){
    #tableView{display:none} #cardView{display:block}
    .coinCard{background:var(--card);border:1px solid #172033;padding:12px;border-radius:10px;margin-bottom:10px}
    .coinRow1{display:flex;justify-content:space-between;align-items:center}
    .coinSymbol{font-size:16px;font-weight:700}
    .coinScore{font-size:14px;font-weight:700}
    .blowBadge{background:#ff4d4d;padding:4px 8px;border-radius:6px;color:white;font-size:12px;font-weight:700}
    .potBadge{background:#ffd966;padding:4px 8px;border-radius:6px;color:black;font-size:12px;font-weight:700}
    .accBadge{background:#2dd4bf;padding:4px 8px;border-radius:6px;color:#04221a;font-size:12px;font-weight:700}
    .sigList{margin-top:8px;font-size:13px;line-height:18px;color:#cfe8ff}
  }
  footer.small{margin-top:12px;color:var(--muted);font-size:12px}
  .phaseTag{display:inline-block;padding:4px 8px;border-radius:8px;font-weight:700;font-size:12px;margin-left:6px}
  .tfToggle{display:inline-flex;gap:6px;align-items:center;margin-left:8px}
  .sensitivity{width:160px}
  .oneLineRec{font-weight:700;color:#cfe8ff;margin-top:6px}
  .recBox{margin-top:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px}
  .finalRec{margin-top:8px;color:#8bffc0;font-weight:700}
  .shortRec{margin-top:8px;color:#ffd966;font-weight:700}
  /* trading interpretation panel */
  .tradePanel{margin-top:12px;padding:12px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03)}
  .tradePanel h3{margin:0 0 8px 0;font-size:15px}
  .tradePanel p{margin:4px 0;color:#cfe8ff}
  .tradeList{margin:8px 0;padding-left:18px}
  .mutedNote{color:var(--muted);font-size:12px;margin-top:8px}
</style>
</head>
<body>
<div class="card-panel">
  <h1>Blowoff Top Detector — Multi-TF Accumulation & Conditional Alerts</h1>
  <div class="small" style="margin-top:6px;color:var(--muted)">
    Multi-timeframe accumulation detector (15m / 1h / 4h), sensitivity slider, conditional alert (blowoff + accumulation) and AI recommendations (long-term + short-term).
    Run on a local server to avoid CORS (e.g., <code>python -m http.server</code>).
  </div>

  <div class="controls">
    <label>Prefilter (top by 24h) <input id="prefilter" type="number" value="30" min="5" max="60"/></label>
    <label>Delay (ms) <input id="delay" type="number" value="450" min="50" max="2000"/></label>
    <label>Refresh (sec) <input id="interval" type="number" value="60" min="10" max="3600"/></label>
    <label>Score ≥ <input id="threshold" type="number" value="4" min="1" max="8"/></label>

    <!-- Sorting controls (ADDED) -->
    <label style="margin-left:8px">Sort by
      <select id="sortBy" style="margin-left:6px">
        <option value="score">Score</option>
        <option value="similarity">Cycle similarity</option>
        <option value="accum">Accum confidence</option>
        <option value="preCrash">Pre-crash confidence</option>
        <option value="rsi4h">RSI (4H)</option>
        <option value="ema70DistPct">EMA stretch %</option>
        <option value="last">Last price</option>
        <option value="symbol">Symbol</option>
      </select>
    </label>
    <button id="sortDir" class="alt" title="Toggle sort direction" style="margin-left:6px">Desc</button>
    <!-- end sorting -->

    <button id="startBtn">Start</button>
    <button id="stopBtn" class="alt" disabled>Stop</button>
    <button id="oneShot" class="alt">Run Once</button>
  </div>

  <div class="controls" style="margin-top:10px">
    <label style="margin-right:8px">Accumulation TFs:</label>
    <div class="tfToggle">
      <label><input type="checkbox" id="tf15" checked> 15m</label>
      <label><input type="checkbox" id="tf1h" checked style="margin-left:6px"> 1h</label>
      <label><input type="checkbox" id="tf4h" checked style="margin-left:6px"> 4h</label>
    </div>

    <label style="margin-left:12px">Sensitivity <span id="sensVal" class="small" style="margin-left:6px">50</span></label>
    <input id="sensitivity" class="sensitivity" type="range" min="0" max="100" value="50" style="margin-left:8px">

    <label style="margin-left:12px">Alert when:</label>
    <label style="margin-left:6px"><input type="checkbox" id="condAlert"> Blowoff HIGH + Accum ≥</label>
    <input id="accumAlertThreshold" type="number" value="50" min="0" max="100" style="width:64px;margin-left:6px">

    <label style="margin-left:12px"><input type="checkbox" id="showShort" checked> Show short-term plans</label>
  </div>

  <div class="status">
    <div id="message">Ready.</div>
    <div class="progress"><i id="bar"></i></div>
    <div id="countdown" class="countdown">Next scan in: -</div>
    <div id="safetyStatus" class="mutedBadge">Safety OK</div>
  </div>

  <!-- Symbol search (paste inside the .controls block) -->
<label style="margin-left:8px">
  Search symbol:
  <input id="symbolSearch" placeholder="e.g. BTCUSDT or PIPPINUSDT" style="margin-left:6px;width:150px"/>
</label>
<button id="symbolSearchBtn" class="alt" title="Analyze symbol">Analyze</button>
<button id="symbolClearCache" class="alt" title="Clear symbol cache" style="margin-left:6px">Clear cache</button>
<div id="symbolStatus" class="small" style="margin-left:8px;color:var(--muted)"> </div>

  <!-- add next to symbolSearch / symbolClearCache -->
<button id="scanTopGreenBtn">Scan Top30 ▲ (24h +)</button>
<button id="scanTopRedBtn">Scan Top30 ▼ (24h -)</button>
<div id="scanStatus" style="margin-top:6px;color:#888;"></div>

  <!-- EMA Cross Scanner (paste into your page) -->
<div id="emaCrossPanel" style="padding:10px;border:1px solid #ddd;margin:8px 0;">
  <strong>EMA70/EMA200 Cross Scanner (15m)</strong><br>
  <label><input type="radio" name="ec_mode" value="gainers" checked> Top 30 Gainers (24h)</label>
  <label style="margin-left:12px;"><input type="radio" name="ec_mode" value="losers"> Top 30 Losers (24h)</label>
  <button id="runEmaScanBtn">Run EMA Cross Scan</button>
  <span id="emaScanStatus" style="margin-left:12px;color:#444"></span>
  <div id="emaScanResults" style="margin-top:8px"></div>
</div>

  <div id="tableView"></div>
  <div id="cardView"></div>

  <!-- NEW: Quick Trading Interpretation -->
  <div id="tradeInterpret" class="tradePanel" style="display:none">
    <!-- content injected dynamically -->
  </div>

  <div id="debug" class="small" style="margin-top:8px"></div>
</div>

<script>
/* ======================================================
   Full detector with sorting added (client-side).
   ====================================================== */

const API_BASE = 'https://fapi.binance.com';
const blacklist = ["ALPACAUSDT","BNXUSDT","ALPHAUSDT","OCEANUSDT","DGBUSDT","AGIXUSDT","LINAUSDT","LOKAUSDT","KEYUSDT","MDTUSDT","LOOMUSDT","RENUSDT","OMNIUSDT","SLERFUSDT","STMXUSDT","UXLINKUSDT","BSWUSDT","NEIROETHUSDT","VIDTUSDT","TROYUSDT","BAKEUSDT","AMBUSDT","MEMEFIUSDT","NULSUSDT","HIFIUSDT","LEVERUSDT","XEMUSDT","STRAXUSDT","COMBOUSDT","AI16ZUSDT"];

const el = {
  prefilter: document.getElementById('prefilter'),
  delay: document.getElementById('delay'),
  interval: document.getElementById('interval'),
  threshold: document.getElementById('threshold'),
  startBtn: document.getElementById('startBtn'),
  stopBtn: document.getElementById('stopBtn'),
  oneShot: document.getElementById('oneShot'),
  message: document.getElementById('message'),
  bar: document.getElementById('bar'),
  tableView: document.getElementById('tableView'),
  cardView: document.getElementById('cardView'),
  debug: document.getElementById('debug'),
  safetyStatus: document.getElementById('safetyStatus'),
  countdown: document.getElementById('countdown'),
  tf15: document.getElementById('tf15'),
  tf1h: document.getElementById('tf1h'),
  tf4h: document.getElementById('tf4h'),
  sensitivity: document.getElementById('sensitivity'),
  sensVal: document.getElementById('sensVal'),
  condAlert: document.getElementById('condAlert'),
  accumAlertThreshold: document.getElementById('accumAlertThreshold'),
  showShort: document.getElementById('showShort'),
  tradeInterpret: document.getElementById('tradeInterpret'),
  // sorting elements (populated below)
  sortBy: document.getElementById('sortBy'),
  sortDir: document.getElementById('sortDir')
};

  // ---------------------- Symbol search + single-symbol analyzer ----------------------
// Wire new elements
el.symbolSearch = document.getElementById('symbolSearch');
el.symbolSearchBtn = document.getElementById('symbolSearchBtn');
el.symbolClearCache = document.getElementById('symbolClearCache');
el.symbolStatus = document.getElementById('symbolStatus');

// Simple in-memory cache for symbol analysis & exchangeInfo
const symbolCache = new Map(); // key -> { ts, data }
const CACHE_TTL = 1000 * 60 * 5; // 5 minutes TTL

// Small rate-limiter for manual symbol lookups (token bucket-ish)
let lastSymbolReq = 0;
const MIN_MS_BETWEEN_SYMBOL_REQ = 800; // 0.8s between manual lookups (adjust as needed)

// Optional: cached exchangeInfo to validate symbol (fetch once, lazy)
let exchangeInfoCache = null;
async function ensureExchangeInfo() {
  if(exchangeInfoCache && (Date.now() - exchangeInfoCache.ts) < 1000*60*30) return exchangeInfoCache.data;
  try {
    const data = await safeFetch(API_BASE + '/fapi/v1/exchangeInfo', { allowIfNotRunning: true });
    exchangeInfoCache = { ts: Date.now(), data };
    return data;
  } catch(e){
    // if fails, we won't block symbol analysis — just proceed (we'll try to fetch klines)
    console.warn('exchangeInfo fetch failed:', e.message);
    return null;
  }
}

// Validate quick: symbol must end with USDT for futures perpetual USDT pairs
function looksLikeUSDTPerp(sym) {
  if(!sym) return false;
  // common convention: futures perpetual on Binance use USDT pairs and show in /fapi endpoints
  return sym.toUpperCase().endsWith('USDT');
}

// Helper: read & set cache
function getCachedSymbol(sym) {
  const k = sym.toUpperCase();
  const row = symbolCache.get(k);
  if(!row) return null;
  if(Date.now() - row.ts > CACHE_TTL) { symbolCache.delete(k); return null; }
  return row.data;
}
function setCachedSymbol(sym, data) {
  const k = sym.toUpperCase();
  symbolCache.set(k, { ts: Date.now(), data });
}

// Clear cache button
el.symbolClearCache.addEventListener('click', () => {
  symbolCache.clear();
  exchangeInfoCache = null;
  el.symbolStatus.innerText = 'Symbol cache cleared.';
  setTimeout(()=> el.symbolStatus.innerText = '', 2600);
});

  // Helper: cheap fallback scoring when res.score is missing
function computeSimpleScore(res){
  // simple heuristic — tuned to mimic blowoff-ish signals enough for badges
  let s = 0;
  const v = res || {};
  const volSpike = Number(v.volSpike4 || v.volSpike || 0);
  const rsi4 = Number(v.rsi4h || v.rsi || 0);
  const wick = Number(v.wickRatio4 || 0);
  const emaDist = Number(v.ema70DistPct || 0);

  if(volSpike >= 5) s += 3;
  else if(volSpike >= 3) s += 2;
  else if(volSpike >= 1.5) s += 1;

  if(rsi4 >= 95) s += 3;
  else if(rsi4 >= 85) s += 2;
  else if(rsi4 >= 70) s += 1;

  if(wick >= 4) s += 2;
  else if(wick >= 2) s += 1;

  if(emaDist >= 100) s += 2;
  else if(emaDist >= 50) s += 1;

  // clamp to small integer
  return Math.max(0, Math.min(10, Math.round(s)));
}

  function classifySimilarityPhase(sim) {
  if (sim < 0.20) return "Trend / Early Pump";
  if (sim < 0.35) return "Blowoff Forming";
  if (sim < 0.55) return "Blowoff / Distribution";
  if (sim < 0.80) return "Breakdown / Crash Phase";
  return "Flatline / Post-Crash";
  }


  // ------------------- Top30 Gainers/Losers scanner & resistance/bearish filter -------------------

// convenience: fetch all 24h tickers (futures perpetual)
async function fetch24hTickers() {
  // note: original failed sometimes due to CORS / network; allowIfNotRunning passed if you use safeFetch
  const url = `${API_BASE}/fapi/v1/ticker/24hr`;
  return await safeFetch(url, { allowIfNotRunning: true });
}

// pick top-n by priceChangePercent
function getTopNByChange(tickers, n = 30, positive = true) {
  if(!Array.isArray(tickers)) return [];
  // ensure numeric and symbol ends with USDT (optional)
  const filtered = tickers
    .map(t => {
      return { symbol: t.symbol, priceChangePercent: Number(t.priceChangePercent || 0), lastPrice: Number(t.lastPrice || 0) };
    })
    .filter(t => t.symbol && t.symbol.endsWith('USDT') && isFinite(t.priceChangePercent));
  // sort descending for gainers, ascending for losers
  filtered.sort((a,b) => positive ? b.priceChangePercent - a.priceChangePercent : a.priceChangePercent - b.priceChangePercent);
  return filtered.slice(0, n);
}

// Run safe batch analysis with rate limit to avoid API throttling
async function analyzeSymbolBatch(symbols, opts = { mode:'resistance', minDelay: 300 }) {
  const results = [];
  for(let i=0;i<symbols.length;i++){
    const sym = (symbols[i].symbol || symbols[i]).toUpperCase();
    try{
      // small delay to avoid bursts
      if(i>0) await delay(opts.minDelay);
      el.scanStatus.innerText = `Analyzing ${i+1}/${symbols.length} • ${sym}`;
      const res = await analyzeSymbol(sym, { allowIfNotRunning: true });

      // decide if it matches mode filters
      // resistance mode -> look for Blowoff / Blowoff Forming / Mania / Distribution (peak/resistance)
      // bearish mode -> look for Breakdown / Capitulation / Post-Crash (bearish at support)
      // --- robust phase extraction + matching ---
function normalizePhaseField(val){
  if(!val) return '';
  if(typeof val === 'string') return val.toLowerCase();
  if(typeof val === 'object'){
    if(typeof val.phase === 'string') return val.phase.toLowerCase();
    if(typeof val.phaseName === 'string') return val.phaseName.toLowerCase();
    try { return JSON.stringify(val).toLowerCase(); } catch(e){ return ''; }
  }
  return String(val).toLowerCase();
}

const RESISTANCE_KEYWORDS = [
  'blowoff','climax','distribution','mania','bull','top',
  'blowoff forming','takeoff/early pump','climax candle',
  'blowoff / mania','distribution / breakdown'
];

const BEARISH_KEYWORDS = [
  'breakdown','capitulation','post-crash','flatline','despair',
  'selloff','distribution','breakdown / crash','capitulation / despair'
];

const rawPhase = res.phase;
const rawSim = res.simPhase || res.sim;
const phaseStr = normalizePhaseField(rawPhase);
const simStr = normalizePhaseField(rawSim);

function anyMatch(str, keywords){
  if(!str) return false;
  return keywords.some(k => str.includes(k));
}


let keep = false;
let keepReason = 'no-match';

// mode logic
if(opts.mode === 'resistance'){
  if(anyMatch(phaseStr, RESISTANCE_KEYWORDS)) { keep = true; keepReason='phase-match'; }
  else if(anyMatch(simStr, RESISTANCE_KEYWORDS)) { keep = true; keepReason='simPhase-match'; }
}
else if(opts.mode === 'bearish'){
  if(anyMatch(phaseStr, BEARISH_KEYWORDS)) { keep = true; keepReason='phase-match'; }
  else if(anyMatch(simStr, BEARISH_KEYWORDS)) { keep = true; keepReason='simPhase-match'; }
}
else {
  keep = true; keepReason='mode-all';
}

console.log(`scan ${sym} -> phase="${phaseStr}" sim="${simStr}" keep=${keep} reason=${keepReason}`);

if(keep){
  res._scanMode = opts.mode;
  res._matchedBy = keepReason;
  results.push(res);
}

    } catch(err) {
      console.warn('batch analyze error', sym, err.message);
      // continue
    }
  }
  el.scanStatus.innerText = `Batch analysis done: ${results.length} matches`;
  return results;
}

// top-level orchestrator: fetch tickers, pick top30 gainers or losers, analyze and render matches
async function runTop30Scan({ positive = true, mode = 'resistance' } = {}) {
  try{
    el.scanStatus.innerText = 'Fetching 24h tickers...';
    const tickers = await fetch24hTickers();
    if(!tickers || !tickers.length){
      el.scanStatus.innerText = 'Failed to fetch 24h tickers.';
      return;
    }
    const top = getTopNByChange(tickers, 30, positive);
    el.scanStatus.innerText = `Found ${top.length} symbols — starting analysis...`;
    // Build minimal list: we can pass array of objects with symbol property
    const matches = await analyzeSymbolBatch(top, { mode: mode, minDelay: 600 /* adjust for safe */});
    // render using your existing renderer
    if(matches.length) {
      updateTradingInterpretation(matches); // will show cards
      if(window.innerWidth >= 680) renderTable(matches); else renderCards(matches);
    } else {
      el.scanStatus.innerText = 'No matches found for filters.';
    }
  } catch(e){
    console.error('runTop30Scan error', e);
    el.scanStatus.innerText = `Scan failed: ${e.message}`;
  }
  } 


// The main single-symbol analyzer; returns the result object in same shape as `results` entries
async function analyzeSymbol(symbol, opts = { allowIfNotRunning: true }) {
  const sym = (symbol || '').toUpperCase();
  if(!sym) throw new Error('Symbol empty');
  // quick check and safety
  if(!looksLikeUSDTPerp(sym)) {
    // try to still proceed but warn user
    el.symbolStatus.innerText = `Warning: "${sym}" does not end with USDT — will attempt fetch anyway.`;
  }
  
  // respect cache
  const cached = getCachedSymbol(sym);
  if(cached) {
    el.symbolStatus.innerText = `Loaded ${sym} from cache (${Math.round((Date.now()-cached._cachedAt)/1000)}s ago)`;
    return cached;
  }

  // rate-limit manual lookups to avoid bursts (user clicks many times)
  const since = Date.now() - lastSymbolReq;
  if(since < MIN_MS_BETWEEN_SYMBOL_REQ) {
    const wait = MIN_MS_BETWEEN_SYMBOL_REQ - since;
    await delay(wait);
  }
  lastSymbolReq = Date.now();

  // validate symbol exists (lazy)
  const exch = await ensureExchangeInfo().catch(()=>null);
  if(exch && Array.isArray(exch.symbols)) {
    const found = exch.symbols.find(s => s.symbol === sym);
    if(!found) {
      el.symbolStatus.innerText = `Symbol ${sym} not found in exchangeInfo (not listed?)`;
      // still proceed to try fetch; maybe it's a newly-listed token
    } else {
      // optional: ensure quoteAsset is USDT
      if(found.quoteAsset !== 'USDT') {
        el.symbolStatus.innerText = `Symbol ${sym} found but quoteAsset=${found.quoteAsset}. Expected USDT. Proceeding anyway.`;
      }
    }
  }

  el.symbolStatus.innerText = `Fetching ${sym} data...`;

  try {
    // Fetch only what's needed (4h, 1h, 15m klines + funding)
    const promises = [
      safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${sym}&interval=4h&limit=40`, { allowIfNotRunning: opts.allowIfNotRunning }),
      safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${sym}&interval=1h&limit=60`, { allowIfNotRunning: opts.allowIfNotRunning }),
      safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${sym}&interval=15m&limit=80`, { allowIfNotRunning: opts.allowIfNotRunning }),
      safeFetch(`${API_BASE}/fapi/v1/fundingRate?symbol=${sym}&limit=1`, { allowIfNotRunning: opts.allowIfNotRunning })
    ];
    const [k4h, k1h, k15, f] = await Promise.all(promises);

    // build features just like queueSymbolAnalysis
    const closes4h = (k4h||[]).map(k=>Number(k[4])); const highs4h=(k4h||[]).map(k=>Number(k[2])); const lows4h=(k4h||[]).map(k=>Number(k[3])); const vols4h=(k4h||[]).map(k=>Number(k[5]));
    const closes1h = (k1h||[]).map(k=>Number(k[4])); const highs1h=(k1h||[]).map(k=>Number(k[2])); const lows1h=(k1h||[]).map(k=>Number(k[3])); const vols1h=(k1h||[]).map(k=>Number(k[5]));
    const closes15 = (k15||[]).map(k=>Number(k[4])); const highs15=(k15||[]).map(k=>Number(k[2])); const lows15=(k15||[]).map(k=>Number(k[3])); const vols15=(k15||[]).map(k=>Number(k[5]));

    const last4 = (k4h && k4h.length) ? k4h[k4h.length-1] : null;
    if(!last4) throw new Error('No 4H candles returned');

    const open4 = Number(last4[1]), high4 = Number(last4[2]), low4 = Number(last4[3]), close4 = Number(last4[4]);
    const body4 = Math.abs(close4 - open4) || 1e-9;
    const wickTop4 = Math.max(0, high4 - Math.max(open4, close4));
    const wickRatio4 = wickTop4 / body4;
    const volMA4 = sma(vols4h, Math.min(10, vols4h.length)) || 1;
    const volSpike4 = Number((Number(last4[5]) / volMA4).toFixed(2));
    const ema70_4 = ema(closes4h, 70) || ema(closes4h, Math.min(21, closes4h.length));
    const emaDistPct = ema70_4 ? Number(pct(close4, ema70_4).toFixed(2)) : 0;
    const rsi4h = rsiFromCloses(closes4h, 14);
    const rsi1d = rsiFromCloses(closes4h.slice(-9).map(v=>v), 14);
    const lowerHigh = (k4h && k4h.length>1) ? Number(high4) < Number(k4h[k4h.length-2][2]) : false;
    const fundingRate = (f && f.length) ? Number(f[0].fundingRate) : 0;
    const rsi1h = rsiFromCloses(closes1h, 14);
    const rsi15 = rsiFromCloses(closes15, 14);
    const volMA15 = sma(vols15, Math.min(10, vols15.length)) || 1;
    const volSpike15 = Number((Number(closes15.length ? vols15[vols15.length-1] : 1) / volMA15).toFixed(2));

    // --- EMACROSS: detect short-term EMA cross (put this after you compute closes4h, rsi4h, etc.)
const ema14_4 = (closes4h.length >= 14) ? ema(closes4h, 14) : null;
const ema21_4 = (closes4h.length >= 21) ? ema(closes4h, 21) : null;
// previous period EMAs (prev candle) - safe guards
let ema14_prev = null, ema21_prev = null;
if(closes4h.length >= 15){
  const prevSlice = closes4h.slice(0, -1); // all except last
  ema14_prev = ema(prevSlice.slice(-14), 14) || null;
  ema21_prev = ema(prevSlice.slice(-21), 21) || null;
}

// cross detection (true only if both previous & current EMAs exist)
const emaCross = { crossUp:false, crossDown:false, ema14:ema14_4, ema21:ema21_4 };
if(ema14_prev !== null && ema21_prev !== null && ema14_4 !== null && ema21_4 !== null){
  // bullish cross: ema14 moved above ema21
  if(ema14_prev <= ema21_prev && ema14_4 > ema21_4) emaCross.crossUp = true;
  // bearish cross: ema14 moved below ema21
  if(ema14_prev >= ema21_prev && ema14_4 < ema21_4) emaCross.crossDown = true;
}

// attach to the result object you'll return
// later you can check result.emaCross.crossUp / .crossDown

    // accumulation checks
    const sens = parseInt(el.sensitivity.value,10) || 50;
    const acc15 = detectAccumulationGeneric(closes15, highs15, lows15, vols15, 30, sens);
    const acc1h = detectAccumulationGeneric(closes1h, highs1h, lows1h, vols1h, 30, sens);
    const acc4h = detectAccumulationGeneric(closes4h, highs4h, lows4h, vols4h, 20, sens);
    const tfChecks = [
      { tf:'15m', result: acc15 },
      { tf:'1h', result: acc1h },
      { tf:'4h', result: acc4h }
    ];
    let combinedConfidence = 0;
    if(tfChecks.length){
      let weightSum = 0;
      tfChecks.forEach(t=>{
        const w = (t.tf === '4h') ? 1.2 : (t.tf === '1h' ? 1.0 : 0.8);
        combinedConfidence += (t.result.confidence || 0) * w;
        weightSum += w;
      });
      combinedConfidence = Math.round(combinedConfidence / weightSum);
    }

    const preCrash = detectPreCrash({
      rsi4h,
      volSpike4,
      wickRatio4,
      ema70DistPct: emaDistPct,
      dropPctFromPeak: pct(close4, ema70_4) || 0,
      fundingRate,
      k4h
    });

    // build the result object (compatible shape)
    const result = {
      symbol: sym,
      score: 0, // we didn't run the multi-signal score aggregator here; you can run detectPhaseForSymbol if you want
      signals: {},
      rsi1d, rsi4h, rsi1h, rsi15,
      volSpike4, volSpike15,
      wickRatio4,
      ema70DistPct: emaDistPct, 
      lowerHigh,
      fundingRate,
      closeNow: close4,
      k4h, k1h, k15m: k15,
      accumChecks: tfChecks,
      accumCombined: { confidence: combinedConfidence, isAccum: combinedConfidence >= Math.max(45, (100 - sens) * 0.6) },
      preCrash,
      emaCross,
      // annotate detection results:
      phase: detectPhaseForSymbol({
        rsi4h, wickRatio4, volSpike4, accumCombined: { confidence: combinedConfidence, isAccum: combinedConfidence >= Math.max(45, (100 - sens) * 0.6) },
        k4h, k15m: k15, closeNow: close4, ema70DistPct: emaDistPct
      }),
      returnToNormal: detectReturnToNormal({ k4h, rsi4h, closeNow: close4 }, { sensitivity: sens })
    };

    // ===== compute a blowoff-style score (same logic as queueSymbolAnalysis) =====
let s = 0;
// stricter 1D extreme
if(result.rsi1d !== null && result.rsi1d >= 88) s++;
// 4H overbought
if(result.rsi4h !== null && result.rsi4h >= 80) s++;
// volume spike
if(result.volSpike4 !== null && result.volSpike4 >= 1.8) s++;
// wick/climax
if(result.wickRatio4 !== null && result.wickRatio4 >= 1.6) s++;
// big EMA stretch (tweak threshold to match your queue logic)
if(result.ema70DistPct && Math.abs(result.ema70DistPct) >= 20) s++;
// lower highs / breakdown
if(result.lowerHigh) s++;
// add other checks your queue uses (capitulation, dead-cat etc.)
/* e.g.:
if(result.preCrash && result.preCrash.someFlag) s++;
*/
result.score = s;

      // --- FIXED FULL-CYCLE REFERENCE VECTOR ---
const FIXED_FULL_CYCLE = {
  rsi4h: 30,
  volSpike4: 5.0,
  wickRatio4: 6.0,
  ema70DistPct: 150,
  fundingRate: -0.2,
  slope15: -1,
  dropPctFromPeak: 85,
  accumCombined: { confidence: 20, isAccum: false }
};

// Build the static reference vector
let baseVector = makeFeatureVector(FIXED_FULL_CYCLE);

// Compute similarity for THIS symbol only
try {
  const v = makeFeatureVector(result);
  result.similarity = cosineSim(v, baseVector);
  result.simPhase = classifySimilarityPhase(result.similarity);
} catch(err) {
  result.similarity = 0;
  result.simPhase = classifySimilarityPhase(0);
}
    
    // final recommendations, targets, short-term rec
    result.expl = explainBlowoff(result);
    result.finalRec = getFinalRecommendation(result);
    result.shortRec = getShortTermRecommendation(result);
    result.longTargets = getLongTermTargets(result);

    // save to cache
    result._cachedAt = Date.now();
    setCachedSymbol(sym, result);

    el.symbolStatus.innerText = `Analyzed ${sym} • accum ${result.accumCombined.confidence}% • rsi4h ${Math.round(result.rsi4h||0)}`;
    return result;
  } catch(err){
    el.symbolStatus.innerText = `Analyze ${sym} failed: ${err.message}`;
    throw err;
  }
}

// UI: analyze button
el.symbolSearchBtn.addEventListener('click', async () => {
  const sym = (el.symbolSearch.value || '').trim().toUpperCase();
  if(!sym){ el.symbolStatus.innerText = 'Enter a symbol (e.g. BTCUSDT)'; return; }
  try {
    el.symbolSearchBtn.disabled = true;
    const res = await analyzeSymbol(sym, { allowIfNotRunning: true });
    // render result in the tradeInterpret panel and also show the card view for the single symbol
    updateTradingInterpretation([res]); // will show this item as the interpretation
    // render as single-card UI: reuse renderCards with [res]
    if(window.innerWidth >= 680) {
      // render table view with one row
      renderTable([res]);
    } else {
      renderCards([res]);
    }
  } catch(e) {
    console.warn('symbol analysis error', e);
  } finally {
    el.symbolSearchBtn.disabled = false;
  }
});

// bonus: support pressing Enter in input to search
el.symbolSearch.addEventListener('keydown', (ev) => {
  if(ev.key === 'Enter') { ev.preventDefault(); el.symbolSearchBtn.click(); }
});

let running=false, queue=[], totalTasks=0, doneTasks=0, autoTimer=null, countdownTimer=null;
let requestsThisWindow=0, windowStart=Date.now(), SAFETY_WINDOW_MS=60000, SAFETY_MAX=900, SAFETY_PAUSE=30;
let prevBlowoffSet = new Set();
window.lastScanResults = null; // persist latest results for sorting/re-render

/* ---------- UTIL ---------- */
function delay(ms){ return new Promise(r=>setTimeout(r,ms)); }
function sma(arr,n){ if(!arr||arr.length<n) return null; let s=0; for(let i=arr.length-n;i<arr.length;i++) s+=arr[i]; return s/n; }
function ema(arr,p){ if(!arr||arr.length===0) return null; const k=2/(p+1); let e=arr[0]; for(let i=1;i<arr.length;i++) e = arr[i]*k + e*(1-k); return e; }
function rsiFromCloses(closes,period=14){ if(!closes||closes.length<=period) return null; let g=0,l=0; for(let i=closes.length-period;i<closes.length;i++){ const d=closes[i]-closes[i-1]; if(d>0) g+=d; else l+=Math.abs(d);} const ag=g/period, al=l/period; if(al===0) return 100; const rs=ag/al; return 100 - (100/(1+rs)); }
function pct(a,b){ return b===0?0:((a-b)/b)*100; }
function stdDev(arr){ if(!arr||arr.length===0) return 0; const mean = arr.reduce((s,x)=>s+x,0)/arr.length; const v = arr.reduce((s,x)=>s+Math.pow(x-mean,2),0)/arr.length; return Math.sqrt(v); }
function dot(a,b){ let s=0; for(let i=0;i<a.length;i++) s+=a[i]*b[i]; return s; }
function norm(a){ return Math.sqrt(a.reduce((s,x)=>s+x*x,0)); }
function cosineSim(a,b){ const n=dot(a,b); const d=norm(a)*norm(b); return d===0?0:n/d; }

/* ------------------------------
   RETURN TO NORMAL DETECTOR
   (same as before)
   ------------------------------ */
function detectReturnToNormal(item, opts = {}) {
  try {
    const k4 = item.k4h || [];
    if(k4.length < 20) {
      return { isReturn:false, score:0, reasons:["not enough data"], confidence:0 };
    }

    const closes = k4.map(c => Number(c[4]));
    const highs   = k4.map(c => Number(c[2]));
    const vols    = k4.map(c => Number(c[5]));
    const closeNow = item.closeNow || closes[closes.length-1];

    // 1. Drop from peak ≥ 15%
    const peak = Math.max(...highs.slice(-40));
    const dropPct = ((closeNow - peak) / peak) * 100;
    const dropOK = dropPct <= -15;

    // 2. Weak bounce = lower highs forming
    let lowerHighs = 0;
    for(let i = highs.length - 5; i < highs.length - 1; i++){
      if(highs[i+1] < highs[i]) lowerHighs++;
    }
    const bounceWeak = lowerHighs >= 2;

    // 3. Declining volume on bounce
    const recentVol = vols[vols.length - 1];
    const prevVol = sma(vols.slice(-10), 5) || vols[vols.length-2];
    const bounceVolOK = recentVol < prevVol * 0.7;

    // 4. Bounce fails below EMA14/EMA21
    const ema14 = ema(closes, 14);
    const ema21 = ema(closes, 21);
    const belowEMA = closeNow < ema14 && closeNow < ema21;

    // 5. Momentum weak: small candles + small wicks
    const last = k4[k4.length-1];
    const wickRatio = (Number(last[2]) - Number(last[3])) / (Math.abs(Number(last[1]) - Number(last[4])) + 1e-9);
    const volSpike = recentVol / (sma(vols, 10) || 1);
    const momentumWeak = wickRatio < 2 && volSpike < 1.5;

    // Score
    let score = 0;
    const reasons = [];
    if(dropOK){ score++; reasons.push("Strong drop from peak (≥15%)"); }
    if(bounceWeak){ score++; reasons.push("Lower highs on bounce (weak bounce)"); }
    if(bounceVolOK){ score++; reasons.push("Declining volume on bounce"); }
    if(belowEMA){ score++; reasons.push("Bounce capped by EMA14/EMA21"); }
    if(momentumWeak){ score++; reasons.push("Momentum weak (small candles / weak wicks)"); }

    const isReturn = score >= 3;
    const confidence = Math.round((score / 5) * 100);

    return { isReturn, score, reasons, confidence, meta:{dropPct, lowerHighs, wickRatio, volSpike} };

  } catch(err) {
    return { isReturn:false, score:0, reasons:[`error: ${err.message}`], confidence:0 };
  }
}
  

/* --------------------------
   PRE-CRASH / BLOWOFF DETECTOR
-------------------------- */
function detectPreCrash(item, opts={}) {
  const sensitivity = parseInt(el.sensitivity.value,10) || 50;
  const t = {
    rsi4h: 78 - Math.round((sensitivity-50)/2),
    volSpike4: 2.0 - (sensitivity-50)/250,
    wickRatio: 1.2 - (sensitivity-50)/500,
    emaDistPct: 40 - Math.round((sensitivity-50)/1.5),
    dropFromPeak: 8 - Math.round((sensitivity-50)/10)
  };

  try {
    const rsi4h = item.rsi4h || 0;
    const vol = Number(item.volSpike4 || 0);
    const wick = Number(item.wickRatio4 || 0);
    const emaDist = Math.abs(Number(item.ema70DistPct || 0));
    const dropPct = Number(item.dropPctFromPeak || 0);
    const funding = item.fundingRate || 0;

    // lower-highs count from k4h if present
    let lowerHCount = 0;
    if(Array.isArray(item.k4h) && item.k4h.length >= 6){
      const highs = item.k4h.slice(-8).map(k => Number(k[2]));
      for(let i=1;i<highs.length;i++) if(highs[i] < highs[i-1]) lowerHCount++;
    }

    let score = 0; const reasons = [];

    // core blowoff signals
    if(vol >= Math.max(1.8, t.volSpike4)){ score += 3; reasons.push(`Vol spike ×${vol}`); }
    else if(vol >= Math.max(1.2, t.volSpike4*0.7)){ score += 1; reasons.push(`Vol uptick ×${vol}`); }

    if(wick >= Math.max(1.2, t.wickRatio)){ score += 3; reasons.push(`Upper wick ratio ${wick.toFixed(2)}`); }
    else if(wick >= Math.max(0.9, t.wickRatio*0.7)){ score += 1; reasons.push(`Wick present ${wick.toFixed(2)}`); }

    if(rsi4h >= t.rsi4h){ score += 2; reasons.push(`RSI4H ${Math.round(rsi4h)}`); }
    else if(rsi4h >= t.rsi4h - 8){ score += 1; reasons.push(`RSI elevated ${Math.round(rsi4h)}`); }

    if(emaDist >= Math.max(30, t.emaDistPct)){ score += 2; reasons.push(`EMA stretch ${Math.round(emaDist)}%`); }

    if(lowerHCount >= 2){ score += 2; reasons.push(`Lower highs (${lowerHCount})`); }
    if(dropPct >= Math.max(6, t.dropFromPeak)){ score += 1; reasons.push(`Drop from peak ${dropPct.toFixed(1)}%`); }

    if(typeof funding === 'number' && funding < -0.001){ score += 1; reasons.push(`Funding neg ${(funding*100).toFixed(3)}%`); }

    // reduce score if accumulation looks strong
    const accumConf = item.accumCombined ? (item.accumCombined.confidence || 0) : 0;
    if(accumConf >= 60){ score = Math.max(0, score - 2); reasons.push('Strong accumulation reduces immediate crash odds'); }

    const maxScore = 13;
    const confidence = Math.round((score / maxScore) * 100);
    const likely = (score >= 7 && confidence >= 45 && accumConf < 65) || (score >= 9);

    return { likely, score, reasons, confidence, meta: { rsi4h, vol, wick, emaDist, dropPct, funding, lowerHCount, accumConf } };
  } catch(err){
    return { likely:false, score:0, reasons:[`error ${err.message}`], confidence:0, meta:{} };
  }
}

/* ---------- SAFE FETCH ---------- */
async function safeFetch(url, opts = { allowIfNotRunning: false }) {
  if(!running && !opts.allowIfNotRunning) throw new Error('Not running (call Start first)');
  try {
    requestsThisWindow++;
    const r = await fetch(url);
    if(!r.ok) {
      const body = await r.text().catch(()=>'<no body>');
      throw new Error(`HTTP ${r.status} ${r.statusText} — ${body.slice(0,200)}`);
    }
    return await r.json();
  } catch (err) {
    throw new Error(`fetch error for ${url} → ${err.message}`);
  }
}

function resetWindow(){ requestsThisWindow=0; windowStart=Date.now(); }
function checkSafetyAndMaybePause(){
  const now=Date.now();
  if(now-windowStart > SAFETY_WINDOW_MS){ resetWindow(); el.safetyStatus.innerText='Safety OK'; return false; }
  if(requestsThisWindow > SAFETY_MAX){
    running=false;
    el.safetyStatus.innerText = `Auto-paused: ${requestsThisWindow} req/min`;
    el.message.innerText = `Auto-paused ${SAFETY_PAUSE}s to avoid rate limit.`;
    el.startBtn.disabled=false; el.stopBtn.disabled=true;
    setTimeout(()=>{ resetWindow(); const cur = Math.max(200, parseInt(el.delay.value,10)||450); el.delay.value = Math.min(2000, Math.round(cur * 1.5)); el.safetyStatus.innerText='Resumed after pause'; el.message.innerText='Resumed'; }, SAFETY_PAUSE*1000);
    return true;
  }
  el.safetyStatus.innerText = `Req/min: ${requestsThisWindow}`;
  return false;
}

/* ---------- TOP N ---------- */
async function getTopN(n){
  const tickers = await safeFetch(API_BASE + '/fapi/v1/ticker/24hr');
  const usdt = tickers.filter(t => t.symbol && t.symbol.endsWith('USDT') && !blacklist.includes(t.symbol));
  usdt.sort((a,b)=> parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent));
  return usdt.slice(0,n).map(x=>({symbol:x.symbol, last: Number(x.lastPrice), change24: Number(x.priceChangePercent)}));
}

/* ---------- ACCUMULATION DETECTOR ---------- */
// ... same detectAccumulationGeneric function from original (kept as-is)
function detectAccumulationGeneric(closes, highs, lows, vols, period=30, sensitivity=50){
  const len = Math.min(period, closes.length);
  if(len < 10) return {isAccum:false, score:0, reasons:[], confidence:0, relSD:0};
  const sliceC = closes.slice(-len), sliceH = highs.slice(-len), sliceL = lows.slice(-len), sliceV = vols.slice(-len);
  const mean = sliceC.reduce((s,x)=>s+x,0)/sliceC.length;
  const sd = stdDev(sliceC);
  const relSD = mean? (sd/mean)*100 : 0;
  const reasons = [];
  let score = 0;
  const relSD_threshold_strict = 2.5;
  const relSD_threshold_loose = 6.0;
  const relSD_threshold = relSD_threshold_strict + (1 - (sensitivity/100)) * (relSD_threshold_loose - relSD_threshold_strict);
  if(relSD <= relSD_threshold){ score += 3; reasons.push(`low volatility ${relSD.toFixed(2)}% ≤ ${relSD_threshold.toFixed(2)}%`); }
  else if(relSD <= relSD_threshold*1.6){ score += 1; reasons.push(`reduced volatility ${relSD.toFixed(2)}%`); }
  let lowerLowCount=0;
  for(let i=1;i<sliceL.length;i++) if(sliceL[i] < sliceL[i-1]) lowerLowCount++;
  const lowerLow_max = 2 + Math.round((100 - sensitivity)/50);
  if(lowerLowCount <= lowerLow_max){ score += 2; reasons.push(`limited lower-lows (${lowerLowCount} ≤ ${lowerLow_max})`); }
  else reasons.push(`lower-lows (${lowerLowCount})`);
  const volBaseline = sma(sliceV, Math.min(8, sliceV.length)) || 0.000001;
  let upCount = 0, upVolHigher = 0;
  for(let i=1;i<sliceC.length;i++){
    if(sliceC[i] > sliceC[i-1]){ upCount++; if(sliceV[i] > volBaseline * (1 + (50 - sensitivity)/200)) upVolHigher++; }
  }
  if(upCount >= 3 && upVolHigher >= Math.max(1, Math.round(upCount*0.4))){ score += 3; reasons.push(`buyers on higher-volume up-bars (${upVolHigher}/${upCount})`); }
  else if(upCount >= 2){ score += 1; reasons.push(`some up bars (${upCount})`); }
  const e14 = ema(sliceC, Math.min(14, sliceC.length));
  const e21 = ema(sliceC, Math.min(21, sliceC.length));
  if(e14 && e21){
    const slope = e14 - e21;
    const slopeThreshold = (sensitivity/100) * (e21 * 0.01);
    if(slope >= -slopeThreshold){ score += 2; reasons.push('EMAs flat/turning up'); }
    else if(Math.abs(slope) < (e21*0.002 || 0.0001)){ score += 1; reasons.push('EMAs flattening'); }
  }
  const rsi = rsiFromCloses(closes, 14);
  if(rsi && rsi >= 36 - (sensitivity/20)) { score += 1; reasons.push(`RSI stabilizing (${rsi.toFixed(1)})`); }
  const peak = Math.max(...sliceC);
  const latest = sliceC[sliceC.length-1];
  const dropPct = peak? ((peak - latest)/peak)*100 : 0;
  const requiredDrop = 8 - Math.round(sensitivity/20);
  if(dropPct >= Math.max(4, requiredDrop)){ score += 1; reasons.push(`follows drop ${dropPct.toFixed(1)}% (req ${Math.max(4, requiredDrop)}%)`); }
  const maxScore = 12;
  const confidence = Math.min(99, Math.round((score/maxScore)*100));
  const isAccum = score >= Math.max(6, Math.round(6 * (0.8 + (50 - sensitivity)/200)));
  return {isAccum, score, reasons, confidence, relSD};
}

/* ---------- QUEUE ANALYSIS (fetch klines & compute features) ---------- */
function queueSymbolAnalysis(symbol, results){
  queue.push(async ()=>{
    try{
      const promises = [];
      promises.push(safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=4h&limit=40`));
      promises.push(safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=1h&limit=60`));
      promises.push(safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=15m&limit=80`));
      promises.push(safeFetch(`${API_BASE}/fapi/v1/fundingRate?symbol=${symbol}&limit=1`));
      const [k4h, k1h, k15, f] = await Promise.all(promises);

      const closes4h = k4h.map(k=>Number(k[4])); const highs4h = k4h.map(k=>Number(k[2])); const lows4h = k4h.map(k=>Number(k[3])); const vols4h = k4h.map(k=>Number(k[5]));
      const closes1h = k1h.map(k=>Number(k[4])); const highs1h = k1h.map(k=>Number(k[2])); const lows1h = k1h.map(k=>Number(k[3])); const vols1h = k1h.map(k=>Number(k[5]));
      const closes15 = k15.map(k=>Number(k[4])); const highs15 = k15.map(k=>Number(k[2])); const lows15 = k15.map(k=>Number(k[3])); const vols15 = k15.map(k=>Number(k[5]));

      const last4 = k4h[k4h.length-1], prev4 = k4h[k4h.length-2] || last4;
      const open4 = Number(last4[1]), high4 = Number(last4[2]), low4 = Number(last4[3]), close4 = Number(last4[4]);
      const body4 = Math.abs(close4 - open4) || 1e-9;
      const wickTop4 = Math.max(0, high4 - Math.max(open4, close4));
      const wickRatio4 = wickTop4 / body4;
      const volMA4 = sma(vols4h, Math.min(10, vols4h.length)) || 1;
      const volSpike4 = Number((Number(last4[5]) / volMA4).toFixed(2));
      const ema70_4 = ema(closes4h, 70) || ema(closes4h, Math.min(21, closes4h.length));
      const emaDistPct = ema70_4 ? Number(pct(close4, ema70_4).toFixed(2)) : 0;
      const rsi4h = rsiFromCloses(closes4h, 14);
      const rsi1d = rsiFromCloses(closes4h.slice(-9).map((v,i)=>v), 14);
      const lowerHigh = Number(high4) < Number(prev4[2]);
      const fundingRate = (f && f.length) ? Number(f[0].fundingRate) : 0;

      // short-term features (from 15m / 1h)
      const rsi1h = rsiFromCloses(closes1h, 14);
      const rsi15 = rsiFromCloses(closes15, 14);
      const volMA15 = sma(vols15, Math.min(10, vols15.length)) || 1;
      const volSpike15 = Number((Number(closes15.length ? vols15[vols15.length-1] : 1) / volMA15).toFixed(2));

      let score=0;
      const signals={};
      if(rsi1d !== null && rsi1d >= 88){ score++; signals.rsi1d=true; } else signals.rsi1d=false;
      if(rsi4h !== null && rsi4h >= 80){ score++; signals.rsi4h=true; } else signals.rsi4h=false;
      if(volSpike4 >= 1.8){ score++; signals.volSpike=true; } else signals.volSpike=false;
      if(wickRatio4 >= 1.2){ score++; signals.wickTop=true; } else signals.wickTop=false;
      if(emaDistPct >= 50){ score++; signals.emaDist=true; } else signals.emaDist=false;
      if(lowerHigh){ score++; signals.lowerHigh=true; } else signals.lowerHigh=false;
      if(typeof fundingRate === 'number' && fundingRate < -0.0005){ score++; signals.fundingConfirm=true; } else signals.fundingConfirm=false;
      signals.funding = fundingRate;

      const sens = parseInt(el.sensitivity.value,10) || 50;
      const tfChecks = [];
      if(el.tf15.checked){
        const acc15 = detectAccumulationGeneric(closes15, highs15, lows15, vols15, 30, sens);
        tfChecks.push({tf:'15m', result:acc15});
      }
      if(el.tf1h.checked){
        const acc1h = detectAccumulationGeneric(closes1h, highs1h, lows1h, vols1h, 30, sens);
        tfChecks.push({tf:'1h', result:acc1h});
      }
      if(el.tf4h.checked){
        const acc4h = detectAccumulationGeneric(closes4h, highs4h, lows4h, vols4h, 20, sens);
        tfChecks.push({tf:'4h', result:acc4h});
      }

      let combinedConfidence = 0;
      if(tfChecks.length){
        let weightSum = 0;
        tfChecks.forEach(t=>{
          const w = (t.tf === '4h') ? 1.2 : (t.tf === '1h' ? 1.0 : 0.8);
          combinedConfidence += (t.result.confidence || 0) * w;
          weightSum += w;
        });
        combinedConfidence = Math.round(combinedConfidence / weightSum);
      }

      // --- add preCrash detection (insert BEFORE results.push)
      const preCrash = detectPreCrash({
        rsi4h,
        volSpike4,
        wickRatio4,
        ema70DistPct: emaDistPct,
        dropPctFromPeak: pct(close4, ema70_4) || 0,
        fundingRate,
        k4h
      });

      results.push({
        symbol,
        score,
        signals,
        rsi1d, rsi4h,
        rsi1h, rsi15,
        volSpike4, volSpike15,
        wickRatio4,
        ema70DistPct: emaDistPct,
        lowerHigh,
        fundingRate,
        closeNow: close4,
        k4h, k1h, k15m: k15,
        accumChecks: tfChecks,
        accumCombined: { confidence: combinedConfidence, isAccum: combinedConfidence >= Math.max(45, (100 - sens) * 0.6) },
        preCrash,
  emaCross,
      });

    } catch(err){
      el.debug.innerText += `\nError ${symbol}: ${err.message}`;
    }
  });
}

/* ---------- PHASE DETECTION & HELPERS ---------- */

// Psychology-cycle driven phase detector (market-psychology aligned, NO "dead-cat" label)
function detectPhaseForSymbol(item){
  try{
    const k4 = item.k4h || [], k15 = item.k15m || [];
    const rsi4h = (item.rsi4h || 0);
    const vol4 = (item.volSpike4 || 1);
    const wick = (item.wickRatio4 || 0);
    const reasons = [];
    let score = 0;

    // helpers
    const closes4 = k4.map(k=>Number(k[4]));
    const highs4  = k4.map(k=>Number(k[2]));
    const lows4   = k4.map(k=>Number(k[3]));
    const vols4   = k4.map(k=>Number(k[5]));
    const lastClose = item.closeNow || (closes4.length ? closes4[closes4.length-1] : 0);

    // compute peak and drop-from-peak (use recent window)
    const peakWindow = Math.min(40, highs4.length);
    const peak = peakWindow ? Math.max(...highs4.slice(-peakWindow)) : lastClose;
    const dropPctFromPeak = peak ? ((lastClose - peak) / peak) * 100 : 0; // negative = dropped

    // higher-lows / lower-highs (structure)
    const recentHighs = highs4.slice(-8);
    let lowerHCount = 0;
    for(let i=1;i<recentHighs.length;i++) if(recentHighs[i] < recentHighs[i-1]) lowerHCount++;
    const recentLows = lows4.slice(-8);
    let higherLCount = 0;
    for(let i=1;i<recentLows.length;i++) if(recentLows[i] > recentLows[i-1]) higherLCount++;

    // volume trend
    const volMA8 = sma(vols4, Math.min(8, vols4.length)) || 1;
    const lastVol = vols4.length ? vols4[vols4.length-1] : 0;
    const volSpike = volMA8 ? lastVol / volMA8 : 1;

    // EMAs (for bounce/return detection)
    const ema14 = ema(closes4, 14) || 0;
    const ema21 = ema(closes4, 21) || 0;
    const ema70 = ema(closes4, 70) || 0;

    // Score signals that map to psychology stages

    // STEALTH / TAKEOFF / EARLY PUMP: steady rising/emas aligned + low wick/low vol spike
    if(ema14 && ema21 && lastClose > ema14 && ema14 > ema21 && volSpike < 1.8 && rsi4h < 65 && dropPctFromPeak > -15){
      reasons.push('Takeoff / Early Pump structure');
      score += 1;
    }

    // AWARENESS / INSTITUTIONAL accumulation: accumulation combined high, low volatility, higher-lows
    if(item.accumCombined && item.accumCombined.confidence >= 60){
      reasons.push(`Accumulation detected (${item.accumCombined.confidence}%)`);
      score += 3;
    } else if(item.accumCombined && item.accumCombined.confidence >= 45){
      reasons.push(`Weak accumulation (${item.accumCombined.confidence}%)`);
      score += 1;
    }

    // MANIA/ENTHUSIASM: rising RSI, sustained vol, big green candles (we detect by high rsi4h + vol)
    if(rsi4h >= 75 && vol4 >= 2.0 && dropPctFromPeak > -8){
      reasons.push('Mania / Enthusiasm (high RSI + volume)');
      score += 2;
    }

    // BLOWOFF / CLIMAX: very large wick, very large vol spike, extreme RSI
    if(wick >= 1.8 && vol4 >= 3 && rsi4h >= 85){
      reasons.push('Blowoff / Climax candle (wick + vol + RSI)');
      score += 4;
    }

    // RETURN-TO-NORMAL (psychology definition)
    //  - did: big drop from peak (>=15%) AND
    //  - weak bounce: lower highs or bounce capped under EMAs + declining volume
    const droppedEnough = dropPctFromPeak <= -15;
    const weakBounceStructure = (lowerHCount >= 2) || (lastClose < ema14 && lastClose < ema21);
    const bounceVolumeDecline = lastVol < volMA8 * 0.75;
    if(droppedEnough && weakBounceStructure && bounceVolumeDecline){
      reasons.push('Return-to-Normal (psych): drop >=15%, weak bounce, declining volume');
      score += 4;
    }

    // BREAKDOWN / DISTRIBUTION: lower highs + range compression on 15m/1h + rising vol on down moves
    let compactRange15 = false;
    if(k15 && k15.length > 10){
      const highs15 = k15.slice(-20).map(k=>Number(k[2]));
      const lows15  = k15.slice(-20).map(k=>Number(k[3]));
      const r = Math.max(...highs15) - Math.min(...lows15 || [1]);
      const base = Math.max(1, Math.min(...lows15));
      if(r / base <= 0.12 && rsi4h >= 55){
        compactRange15 = true;
      }
    }
    if(lowerHCount >= 3 || compactRange15){
      reasons.push('Breakdown / Distribution (lower highs / sideways top)');
      score += 2;
    }

    // CAPITULATION: large drop from peak (>=25%) + vol spike on down moves
    if(dropPctFromPeak <= -25 && vol4 >= 1.8){
      reasons.push('Capitulation / Despair (large drop + vol)');
      score += 4;
    }

    // NOTE: Removed "dead-cat" labeling to align strictly with your psychology-cycle terms.
    // If small bounces exist after a capitulation we treat them as weak bounces / re-accumulation signals (via accumCombined).

    // Determine phase candidates using scored signals and priority rules
    const candidates = [];

    // Priority mapping (higher priority first) — aligned to market psychology stages
    if(reasons.some(r=>r.includes('Blowoff'))) candidates.push({phase:'Blowoff / Mania', priority:9});
    if(reasons.some(r=>r.includes('Capitulation'))) candidates.push({phase:'Capitulation / Despair', priority:8});
    if(reasons.some(r=>r.includes('Return-to-Normal'))) candidates.push({phase:'Return-to-Normal (Psych Trap)', priority:7});
    if(reasons.some(r=>r.includes('Accumulation')) ) candidates.push({phase:'Accumulation / Re-accumulation', priority:6});
    if(reasons.some(r=>r.includes('Breakdown') || r.includes('Distribution'))) candidates.push({phase:'Distribution / Breakdown', priority:5});
    if(reasons.some(r=>r.includes('Takeoff')) ) candidates.push({phase:'Takeoff / Early Pump', priority:4});

    if(candidates.length === 0){
      // fallback heuristics
      if(dropPctFromPeak <= -20) candidates.push({phase:'Capitulation / Despair', priority:7});
      else if(item.accumCombined && item.accumCombined.confidence >= 55) candidates.push({phase:'Accumulation / Re-accumulation', priority:5});
      else candidates.push({phase:'Normal / Trending', priority:1});
    }

    // pick highest priority candidate
    candidates.sort((a,b)=> b.priority - a.priority);
    const chosen = candidates[0].phase || 'Unknown';

    // Confidence: blend of score and accumulation strength (keeps compatibility with prior confidence usage)
    const baseConf = Math.min(95, Math.round((score / 12) * 100));
    const accumBoost = (item.accumCombined && item.accumCombined.confidence) ? Math.round(item.accumCombined.confidence * 0.18) : 0;
    const conf = Math.max(10, Math.min(98, baseConf + accumBoost));

    return {
      phase: chosen,
      confidence: conf,
      reasons: reasons,
      dropPctFromPeak: Math.round(dropPctFromPeak * 100) / 100
    };

  } catch(e){
    return { phase:'Unknown', confidence:0, reasons:[`error ${e.message}`], dropPctFromPeak:0 };
  }
}
       

function makeFeatureVector(item){
  const rsi4h = Math.min(100, item.rsi4h || 0)/100;
  const vol = Math.min(10, item.volSpike4 || 1)/5;
  const wick = Math.min(10, item.wickRatio4 || 0)/5;
  const ema = Math.min(500, Math.abs(item.ema70DistPct || 0))/200;
  const funding = (item.fundingRate || 0) * 1000;
  const slope = Math.min(4, Math.max(0, (item.slope15 || 1)/1.5))/2;
  const drop = Math.min(100, item.dropPctFromPeak || 0)/100;
  const accumConf = item.accumCombined ? (item.accumCombined.confidence || 0)/100 : 0;
  return [rsi4h, vol, wick, ema, funding, slope, drop, accumConf];
}

function explainBlowoff(item){
  const p = item;
  let pts=0; const reasons=[];
  if(p.rsi1d !== null && p.rsi1d >= 88){ pts+=2; reasons.push(`1D RSI ${p.rsi1d.toFixed(1)}`); } else if(p.rsi1d !== null && p.rsi1d >= 80){ pts+=1; reasons.push(`1D RSI ${p.rsi1d.toFixed(1)}`); }
  if(p.rsi4h !== null && p.rsi4h >= 85){ pts+=1; reasons.push(`4H RSI ${p.rsi4h.toFixed(1)}`); }
  if(p.volSpike4 >= 3){ pts+=2; reasons.push(`Vol climax ×${p.volSpike4}`);} else if(p.volSpike4 >= 1.8){ pts+=1; reasons.push(`Vol spike ×${p.volSpike4}`);}
  if(p.wickRatio4 >= 2.0){ pts+=2; reasons.push(`Upper wick ratio ${p.wickRatio4.toFixed(2)}`);} else if(p.wickRatio4 >= 1.2){ pts+=1; reasons.push(`Upper wick ${p.wickRatio4.toFixed(2)}`);}
  if(p.ema70DistPct >= 150){ pts+=2; reasons.push(`EMA stretch ${p.ema70DistPct}%`);} else if(p.ema70DistPct >= 50){ pts+=1; reasons.push(`EMA stretch ${p.ema70DistPct}%`);}
  if(typeof p.fundingRate === 'number'){ if(p.fundingRate < -0.001){ pts+=2; reasons.push(`Funding strongly negative ${(p.fundingRate*100).toFixed(3)}%`);} else if(p.fundingRate < -0.0005){ pts+=1; reasons.push(`Funding negative ${(p.fundingRate*100).toFixed(3)}%`);} }
  if(p.lowerHigh){ pts+=1; reasons.push('Lower high'); }
  if(typeof p.score === 'number'){ if(p.score >= 6) pts+=2; else if(p.score >= 4) pts+=1; }
  let label='None', color='#9fb3cc', prob=5;
  if(pts >= 10){ label='Extreme'; color='#e74c3c'; prob=92; } else if(pts >= 7){ label='High'; color='#ff6b43'; prob=78; } else if(pts >= 4){ label='Medium'; color='#ffd966'; prob=55; } else if(pts >= 2){ label='Low'; color='#7bd389'; prob=25; }
  const topReasons = reasons.slice(0,4);
  const explanation = topReasons.length ? `${topReasons.join('; ')}. Estimated reversal probability: ${prob}%.` : `No clear exhaustion signals detected.`;
  return {pts, label, color, prob, explanation, reasons: topReasons};
}

/* ============================================================
   Long-term targets, recommendations, short-term recs kept same...
   (omitted here for brevity but included below - full original code preserved)
   ============================================================ */

/* ---------- (functions getLongTermTargets, getFinalRecommendation,
   getShortTermRecommendation, renderTable, renderCards, buildTradingInterpretation,
   updateTradingInterpretation) ---------- */
/* For brevity in this block I've preserved the original implementations
   exactly as in your prior code — they follow immediately below. */

/* ============================================================
   NEW: Sorting helpers — inserted now
   ============================================================ */

let sortDesc = true; // default Desc
// helper to extract value for sort key
function getValueForKey(r, key) {
  if(!r) return null;
  switch(key){
    case 'score': return r.score || 0;
    case 'similarity': return (r.similarity||0);
    case 'accum': return (r.accumCombined && r.accumCombined.confidence) ? r.accumCombined.confidence : 0;
    case 'preCrash': return (r.preCrash && (typeof r.preCrash.confidence !== 'undefined')) ? r.preCrash.confidence : ((r.preCrash && typeof r.preCrash.score !== 'undefined') ? r.preCrash.score : 0);
    case 'rsi4h': return r.rsi4h || 0;
    case 'ema70DistPct': return Math.abs(r.ema70DistPct || 0);
    case 'last': return r.closeNow || 0;
    case 'symbol': return (r.symbol || '').toUpperCase();
    default: return 0;
  }
}

function sortResults(results) {
  const key = (el.sortBy && el.sortBy.value) ? el.sortBy.value : 'score';
  results.sort((a,b) => {
    const A = getValueForKey(a,key);
    const B = getValueForKey(b,key);

    // alphabetical
    if(key === 'symbol'){
      if(A < B) return sortDesc ? 1 : -1;
      if(A > B) return sortDesc ? -1 : 1;
      return 0;
    }

    // numeric
    if(typeof A === 'number' && typeof B === 'number'){
      if(A === B){
        // tiebreakers: score desc, then similarity desc
        const t = (b.score||0) - (a.score||0);
        if(t !== 0) return t;
        const s = (b.similarity||0) - (a.similarity||0);
        return s;
      }
      return sortDesc ? (B - A) : (A - B);
    }

    // fallback string
    if(String(A) < String(B)) return sortDesc ? 1 : -1;
    if(String(A) > String(B)) return sortDesc ? -1 : 1;
    return 0;
  });
}

/* ============================================================
   Now inject event handlers for the sort controls (wires up to re-render)
   ============================================================ */
if(el.sortDir){
  el.sortDir.addEventListener('click', () => {
    sortDesc = !sortDesc;
    el.sortDir.innerText = sortDesc ? 'Desc' : 'Asc';
    if(window.lastScanResults){
      sortResults(window.lastScanResults);
      if(window.innerWidth >= 680) renderTable(window.lastScanResults);
      else renderCards(window.lastScanResults);
      updateTradingInterpretation(window.lastScanResults);
    }
  });
}
if(el.sortBy){
  el.sortBy.addEventListener('change', () => {
    if(window.lastScanResults){
      sortResults(window.lastScanResults);
      if(window.innerWidth >= 680) renderTable(window.lastScanResults);
      else renderCards(window.lastScanResults);
      updateTradingInterpretation(window.lastScanResults);
    }
  });
}

/* ============================================================
   (Below: original rendering & recommendation functions)
   For readability in this response I will include them verbatim,
   exactly as in your previous file so the app logic remains identical.
   ============================================================ */

/* ---------- Long-term target generator ---------- */
function getLongTermTargets(item){
  try{
    const k4 = item.k4h || [];
    const lastClose = item.closeNow || (k4.length ? Number(k4[k4.length-1][4]) : 0);
    const windowSize = Math.min(40, k4.length);
    const recent = k4.slice(-windowSize);

    let recentHigh = lastClose, recentLow = lastClose;
    if(recent.length){
      recentHigh = Math.max(...recent.map(k => Number(k[2])));
      recentLow = Math.min(...recent.map(k => Number(k[3])));
    }

    let swingHigh = recentHigh;
    if(recent.length >= 6){
      const last24 = recent.slice(-Math.min(24,recent.length));
      const histHigh = Math.max(...last24.map(k=>Number(k[2])));
      swingHigh = histHigh;
    }

    const baseline = Math.max(lastClose, swingHigh * 0.92);
    const t1 = +(Math.max(swingHigh, lastClose) * 1.05).toFixed(6);
    const t2 = +(Math.max(swingHigh, lastClose) * 1.25).toFixed(6);
    const t3 = +(Math.max(swingHigh, lastClose) * 1.6).toFixed(6);

    let volMA = 0;
    try{ volMA = sma((k4||[]).map(k=>Number(k[5])), Math.min(10, k4.length)) || 0; }catch(e){}
    const lastVol = k4.length ? Number(k4[k4.length-1][5]) : 0;
    const volBoost = (volMA && lastVol > volMA*1.8) ? 1.03 : 1.0;

    const t1b = +(t1 * volBoost).toFixed(6);
    const t2b = +(t2 * volBoost).toFixed(6);
    const t3b = +(t3 * volBoost).toFixed(6);

    const s1 = +(recentLow.toFixed(6));
    const s2 = +((recentLow) * 0.92).toFixed(6);
    const s3 = +((recentLow) * 0.80).toFixed(6);

    const fallbackPercent = (p) => +(lastClose * p).toFixed(6);
    return {
      t1: t1b || fallbackPercent(1.05),
      t2: t2b || fallbackPercent(1.25),
      t3: t3b || fallbackPercent(1.6),
      s1: (s1 && s1>0) ? s1 : +((lastClose*0.92).toFixed(6)),
      s2: (s2 && s2>0) ? s2 : +((lastClose*0.85).toFixed(6)),
      s3: (s3 && s3>0) ? s3 : +((lastClose*0.75).toFixed(6)),
      recentHigh, recentLow, swingHigh
    };
  } catch(e){
    const lastClose = item.closeNow || 0;
    return {
      t1: +(lastClose * 1.05).toFixed(6),
      t2: +(lastClose * 1.25).toFixed(6),
      t3: +(lastClose * 1.6).toFixed(6),
      s1: +(lastClose * 0.92).toFixed(6),
      s2: +(lastClose * 0.85).toFixed(6),
      s3: +(lastClose * 0.75).toFixed(6),
      recentHigh: lastClose, recentLow: lastClose, swingHigh: lastClose
    };
  }
}

/* ---------- Final AI recommendation (long-term) ---------- */
function getFinalRecommendation(item){
  const sim = Math.round((item.similarity||0)*100);
  const phase = item.phase && item.phase.phase ? item.phase.phase : (item.phase || 'Unknown');
  let accum = item.accumCombined ? (item.accumCombined.confidence || 0) : 0;
  if(item.returnToNormal && item.returnToNormal.isReturn){
    accum = Math.min(100, accum + Math.round(item.returnToNormal.confidence * 0.12));
  }
  const rsi4h = item.rsi4h || 0;
  const rsi1d = item.rsi1d || 0;
  const wick = item.wickRatio4 || 0;
  const vol = item.volSpike4 || 1;
  const funding = item.fundingRate || 0;
  const drop = item.dropPctFromPeak || 0;
  let sentence = '';
  let rationale = '';
  if(accum >= 65 && phase.includes('Accumulation')){
    sentence = `CYCLE sim ${sim}% and multi-TF accumulation (${accum}%) suggest early re-accumulation — consider staged long-term entries (starter now, add on 4H/1D confirmation).`;
    rationale = 'Strong accumulation confirmed';
  }
  else if(sim >= 70 && accum >= 50){
    sentence = `High CYCLE similarity (${sim}%) plus moderate accumulation (${accum}%) — use a small starter, protect with a 4H stop, and scale in after sustained volume and 4H confirmation.`;
    rationale = 'High similarity + moderate accumulation';
  }
  else if((rsi4h >= 78 || wick >= 1.8 || vol >= 3 || funding < -0.001) && accum < 50){
    sentence = `Because 4H is overbought (RSI ${Math.round(rsi4h)}) and accumulation is weak (${accum}%), avoid full long-term positions now; if needed, use a small starter and tight 4H stop — only add after clear 4H/daily accumulation.`;
    rationale = 'Overbought + weak accumulation';
  }
  else if(phase.includes('Distribution') || phase.includes('Breakdown') || phase.includes('Capitulation')){
    sentence = `Distribution/breakdown phase detected — expect further downside pressure; avoid long-term buys until a stable accumulation base and flattening EMAs appear on 4H/1D.`;
    rationale = 'Distribution/Breakdown';
  }
  else if(phase.includes('Dead-cat') || (drop > 10 && accum < 55)){
    sentence = `Looks like a short-lived bounce (dead-cat) with limited accumulation (${accum}%) — do not treat this as a long-term base; wait for a sideways 4H/1D structure.`;
    rationale = 'Dead-cat bounce';
  }
  else if(sim >= 50 && rsi4h < 75 && accum >= 45 && vol >= 1.2){
    sentence = `Structure appears healthy enough for longer-term exposure — consider standard sized positions and add on confirmed 4H higher lows or daily accumulation confirmation.`;
    rationale = 'Healthy trending structure';
  }
  else {
    sentence = `No clear long-term buy signal: use a small starter (if any), protect with a tight stop, and scale in only after clear 4H/1D accumulation and rising green-volume.`;
    rationale = 'Conservative fallback';
  }
  return {sentence, rationale, sim, accum, phase};
}

/* ---------- Short-term recommendation generator ---------- */
function getShortTermRecommendation(item){
  const rsi15 = item.rsi15 || 0;
  const rsi1h = item.rsi1h || 0;
  const rsi4h = item.rsi4h || 0;
  const vol15 = item.volSpike15 || 1;
  const vol4 = item.volSpike4 || 1;
  const wick = item.wickRatio4 || 0;
  const accum = item.accumCombined ? item.accumCombined.confidence : 0;
  const phase = item.phase && item.phase.phase ? item.phase.phase : item.phase || 'Unknown';
  const close = Number(item.closeNow || 0) || 0;

  function recentLowFrom(karr, lookback=12){
    if(!Array.isArray(karr) || karr.length===0) return null;
    const slice = karr.slice(-Math.min(lookback, karr.length));
    const lows = slice.map(k => Number(k[3] || k[3] === 0 ? k[3] : NaN)).filter(v => !isNaN(v));
    if(!lows.length) return null;
    return Math.min(...lows);
  }

  const low15 = recentLowFrom(item.k15m, 20);
  const low1h = recentLowFrom(item.k1h, 12);
  const low4h = recentLowFrom(item.k4h, 6);

  const targets = [];
  if(low15 && close > 0 && low15 < close) targets.push(Number(low15.toFixed(6)));
  if(low1h && close > 0 && low1h < close && (targets.indexOf(Number(low1h.toFixed(6))) === -1)) targets.push(Number(low1h.toFixed(6)));
  if(low4h && close > 0 && low4h < close && (targets.indexOf(Number(low4h.toFixed(6))) === -1)) targets.push(Number(low4h.toFixed(6)));

  if(targets.length < 3 && close > 0){
    const percCandidates = [
      +(close * (1 - 0.05)).toFixed(6),
      +(close * (1 - 0.12)).toFixed(6),
      +(close * (1 - 0.20)).toFixed(6)
    ];
    percCandidates.forEach(p => { if(targets.length < 3) targets.push(p); });
  }

  const fmtTargets = targets.map(t => {
    if(typeof t !== 'number' || isNaN(t)) return '—';
    return (Math.abs(t) < 0.0001) ? t.toExponential(6) : (Number(t.toFixed(6)));
  });

  let bias = 'Neutral';
  let sentence = '';
  let plan = '';

  if(phase.includes('Dead-cat') || phase.includes('Breakdown') || (rsi4h >= 78 && accum < 50) || (wick >= 1.0 && vol4 < 1.0 && rsi4h >= 75)){
    bias = 'Bearish';
    sentence = `Short-term bias: Bearish — bounce likely temporary; prefer shorting the rally or waiting for lower re-entry.`;
    plan = `If shorting: enter on a failed bounce or rejection; stop above the recent 4H swing high; take partial profits at first support, trail rest.`;
  } else if(accum >= 60 && rsi15 <= 45 && rsi4h < 65){
    bias = 'Bullish';
    sentence = `Short-term bias: Bullish — corrective pullback with rising accumulation; consider small scalp/long with tight stop.`;
    plan = `Starter on confirmed 15m higher low + green-volume; stop below local 15m low; target near prior 15m/1h resistance.`;
  } else {
    bias = 'Neutral';
    sentence = `Short-term: Neutral—no clean short or long edge. Prefer to wait for a tradeable structure (rejection or 15m higher-low).`;
    plan = `Wait for either a clear rejection (short) or 15m/1h higher-low with volume (long).`;
  }

  return {
    bias,
    sentence,
    plan,
    targets: fmtTargets,
    accum,
    rsi15,
    rsi1h,
    rsi4h,
    vol15,
    vol4
  };
}

/* ---------- RENDER TABLE & CARDS (updated to use window.lastScanResults) ---------- */
function renderTable(results){
  // results expected already sorted by sortResults()
  const threshold = parseInt(el.threshold.value,10)||4;
  const showShort = el.showShort.checked;
  const rows = results.map(r=>{
    const expl = explainBlowoff(r);
    const phaseInfo = r.phase || {phase:'Unknown', confidence:0};
    const accum = r.accumCombined || {confidence:0, isAccum:false};
    const rec = getFinalRecommendation(r);
    const shortRec = getShortTermRecommendation(r);
    const longTargets = getLongTermTargets(r);

    // RTN badge
    const rtnBadge = (r.returnToNormal && r.returnToNormal.isReturn) ? `<span class="phaseTag" style="background:#2dd4bf;color:#04221a;margin-left:6px">Return-to-normal ${r.returnToNormal.confidence}%</span>` : '';

    let statusHtml = `<span class="small">normal</span>`; let bg='background:rgba(255,255,255,0.02)'; let cls='';
    if(r.score >= threshold){ statusHtml = `<span style="background:#ff4d4d;padding:4px 8px;border-radius:6px;font-size:11px;font-weight:bold;">🔥 BLOWOFF</span>`; bg='background:rgba(255,40,40,0.12)'; if(!prevBlowoffSet.has(r.symbol)) cls='blink'; }
    else if(r.score === threshold-1){ statusHtml = `<span style="background:#ffd966;padding:4px 8px;border-radius:6px;font-size:11px;font-weight:bold;color:black;">⚠ POTENTIAL</span>`; bg='background:rgba(255,200,0,0.10)'; }

    const simPct = r.similarity ? Math.round(r.similarity*100) : 0;
    const accumHtml = accum.isAccum ? `<div class="small" style="color:#2dd4bf">Accum: ${accum.confidence}%</div>` : `<div class="small" style="color:var(--muted)">Accum: ${accum.confidence}%</div>`;
    const tfList = (r.accumChecks || []).map(t => `${t.tf}:${t.result.confidence}%${t.result.isAccum? '✓':''}`).join(' | ');
    let phaseColor = '#9fb3cc';
    if(phaseInfo.phase.includes('Capitulation')) phaseColor='#e74c3c';
    else if(phaseInfo.phase.includes('Climax')||phaseInfo.phase.includes('Acceleration')) phaseColor='#ff6b43';
    else if(phaseInfo.phase.includes('Distribution')) phaseColor='#ffd966';
    else if(phaseInfo.phase.includes('Dead-cat')) phaseColor='#7bd389';

    const shortHtml = showShort ? `
      <div class="shortRec">🔎 Short-term: ${shortRec.sentence}</div>
      <div class="recBox" style="background:rgba(255,255,255,0.01)">
        <strong>Short-term Plan:</strong> ${shortRec.plan}<br>
        <strong>Targets:</strong> ${shortRec.targets.join(' • ')}
        <br><em style="color:var(--muted)">Short-term bias: ${shortRec.bias} • RSI15:${Math.round(shortRec.rsi15||0)} • accum:${shortRec.accum}%</em>
      </div>
    ` : '';

    const longTargetsHtml = `
      <div style="margin-top:8px;">
        <strong>Targets (long-term):</strong>
        <div class="recBox">
          <strong>Upside Targets:</strong> ${longTargets.t1} • ${longTargets.t2} • ${longTargets.t3}
          <br><strong>Safety levels:</strong> ${longTargets.s1} • ${longTargets.s2} • ${longTargets.s3}
          <br><em style="color:var(--muted)">Recent H/L: ${longTargets.recentHigh}/${longTargets.recentLow} • SwingHigh:${longTargets.swingHigh}</em>
        </div>
      </div>
    `;

    return `
      <tr class="${cls}" style="${bg}">
        <td>
          <strong>${r.symbol}</strong><br>
          ${statusHtml}
          ${ r.preCrash && r.preCrash.likely ? `<span style="background:#ff5c5c;color:white;padding:4px 6px;border-radius:6px;margin-left:8px">⚠ Pre-crash ${r.preCrash.confidence}%</span>` : '' }
          <span class="phaseTag" style="background:${phaseColor}; color:black;margin-left:8px">${phaseInfo.phase} (${phaseInfo.confidence}%)</span>
          ${rtnBadge}
        </td>
        <td>${r.closeNow}</td>
        <td class="${(r.rsi4h||0)>=80?'green':''}">${r.rsi4h? r.rsi4h.toFixed(1):'n/a'}</td>
        <td class="small">vol×${r.volSpike4} wick:${(r.wickRatio4||0).toFixed(2)} ema:${r.ema70DistPct}%</td>
        <td class="small">${(r.fundingRate||0).toFixed(6)}<br>Cycle sim: <strong>${simPct}%</strong><br>${accumHtml}<div class="small" style="color:#9fb3cc">TFs: ${tfList || '—'}</div></td>
      </tr>
      <div class="small" style="color:#7edcff">
  Cycle Match: <strong>${simPct}%</strong> —
  <span>${r.simPhase || classifySimilarityPhase(r.similarity)}</span>
</div>
      <tr style="background:rgba(255,255,255,0.01)"><td colspan="5" style="padding:8px 12px;color:${expl.color}">
        <strong>${expl.label}</strong> — ${expl.explanation}
        ${r.phase? `<div style="margin-top:6px;color:#cfe8ff">Phase: <strong>${r.phase.phase}</strong> (${r.phase.confidence}%) • ${r.phase.reasons.join('; ')}</div>` : ''}
        ${r.accumCombined && r.accumCombined.isAccum ? `<div style="margin-top:6px;color:#cfe8ff">Accumulation combined: ${r.accumCombined.confidence}% • reasons: ${ (r.accumChecks||[]).map(t => `${t.tf}:${t.result.reasons.join(',')}`).join(' || ') }</div>` : `<div style="margin-top:6px;color:var(--muted)">Accumulation combined: ${r.accumCombined.confidence}%</div>`}
        ${ r.preCrash ? `<div style="margin-top:6px;color:#ffd9d9"><strong>Pre-crash signals:</strong> ${r.preCrash.reasons.join('; ') || '—'} • score ${r.preCrash.score}</div>` : '' }
        <div class="finalRec">🧠 Final AI Recommendation: <strong>${rec.sentence}</strong></div>
        ${longTargetsHtml}
        ${shortHtml}
        <div class="recBox"><strong>Plan (long-term):</strong><br>Starter: ~10% of planned allocation.<br>Stop: below recent 4H consolidation low (use tight stop).<br>Add rules: add only after 2 of — 4H higher low; Volume on green candles ≥ 1.5× volMA; Accumulation confidence ≥ 70% on 4H/combined TFs.<br><em style="color:var(--muted)">Rationale: sim ${rec.sim}%, phase "${rec.phase}", accum ${rec.accum}%</em></div>
      </td></tr>
    `;
  }).join('');
  el.tableView.innerHTML = `<div class="card-panel"><table><thead><tr><th>Symbol / Status</th><th>Last</th><th>RSI4H</th><th>Signals</th><th>Funding / PIPPIN / Accum</th></tr></thead><tbody>${rows}</tbody></table></div>`;
  setTimeout(()=>{ const nodes=document.querySelectorAll('tr.blink'); nodes.forEach(n=>n.classList.remove('blink')); }, 3000);
}

function renderCards(results){
  // assumes results already sorted
  const showShort = el.showShort.checked;
  let html='';
  results.forEach(r=>{
    const expl = explainBlowoff(r); const phase = r.phase || {phase:'Unknown', confidence:0}; const accum = r.accumCombined || {confidence:0, isAccum:false};
    const simPct = Math.round((r.similarity||0)*100);
    const rec = getFinalRecommendation(r);
    const srec = getShortTermRecommendation(r);
    const longTargets = getLongTermTargets(r);
    let badge = `<span class="small" style="color:var(--muted)">normal</span>`; let bc='';
    if(r.score >= (parseInt(el.threshold.value,10)||4)){ badge = `<span class="blowBadge">🔥 Blowoff</span>`; bc='blink'; } else if(r.score === (parseInt(el.threshold.value,10)||4)-1){ badge = `<span class="potBadge">⚠ Potential</span>`; }
    const accBadge = accum.isAccum ? `<span class="accBadge">✔ Accum ${accum.confidence}%</span>` : `<span class="small" style="color:var(--muted)">Accum ${accum.confidence}%</span>`;

    const rtnBadge = (r.returnToNormal && r.returnToNormal.isReturn) ? `<span class="phaseTag" style="background:#2dd4bf;color:#04221a;margin-left:6px">Return-to-normal ${r.returnToNormal.confidence}%</span>` : '';

    const shortHtml = showShort ? `
      <div class="shortRec">🔎 Short-term: ${srec.sentence}</div>
      <div class="recBox" style="background:rgba(255,255,255,0.01)">
        <strong>Short-term Plan:</strong> ${srec.plan}<br>
        <strong>Targets:</strong> ${srec.targets.join(' • ')}
        <br><em style="color:var(--muted)">Bias: ${srec.bias} • RSI15:${Math.round(srec.rsi15||0)} • accum:${srec.accum}%</em>
      </div>
    ` : '';
    html += `
      <div class="coinCard ${bc}">
        <div class="coinRow1"><div class="coinSymbol">${r.symbol}</div><div class="coinScore">${r.score}/8</div></div>
        <div style="margin-top:6px">
          ${badge} ${accBadge}
          ${ r.preCrash && r.preCrash.likely ? `<span style="background:#ff5c5c;color:white;padding:4px 8px;border-radius:6px;margin-left:8px">⚠ Pre-crash ${r.preCrash.confidence}%</span>` : '' }
          ${rtnBadge} <span style="margin-left:8px;font-size:12px;background:var(--glass);padding:4px 8px;border-radius:8px">${phase.phase} ${phase.confidence}%</span>
        </div>
        <div class="sigList">
          Last: ${r.closeNow}<br>
          RSI4H: ${r.rsi4h? r.rsi4h.toFixed(1):'n/a'} • Vol×${r.volSpike4} • Wick:${(r.wickRatio4||0).toFixed(2)}<br>
          EMA∆: ${r.ema70DistPct}% • Funding: ${(r.fundingRate||0).toFixed(6)}<br>
          <small style="color:#cfe8ff">Cycle similarity: <strong>${simPct}%</strong></small>
        </div>
        <div class="small" style="color:#7edcff">
  Cycle Match: <strong>${simPct}%</strong> —
  <span>${r.simPhase || classifySimilarityPhase(r.similarity)}</span>
</div>
        <div style="margin-top:8px;padding-top:8px;border-top:1px dashed rgba(255,255,255,0.03);">
          <div style="color:${expl.color};font-weight:700">${expl.label} — ${expl.prob}% reversal chance</div>
          <div style="color:#cfe8ff;font-size:13px;margin-top:6px">${expl.explanation}</div>
          ${phase.reasons && phase.reasons.length ? `<div style="color:#cfe8ff;margin-top:6px">Phase reasons:<br>• ${phase.reasons.join('<br>• ')}</div>` : ''}
          ${accum.isAccum ? `<div style="color:#cfe8ff;margin-top:6px">Accumulation combined: ${accum.confidence}% • TFs: ${(r.accumChecks||[]).map(t => `${t.tf}:${t.result.confidence}%${t.result.isAccum? '✓':''}`).join(' | ')}</div>` : ''}
          ${ r.preCrash ? `<div style="margin-top:6px;color:#ffd9d9"><strong>Pre-crash signals:</strong> ${r.preCrash.reasons.join('; ') || '—'} • score ${r.preCrash.score}</div>` : '' }
          <div class="finalRec">🧠 Final AI Recommendation: <strong>${rec.sentence}</strong></div>
          ${shortHtml}
          <div style="margin-top:8px">
            <strong>Targets (long-term):</strong>
            <div class="recBox">
              <strong>Upside:</strong> ${longTargets.t1} • ${longTargets.t2} • ${longTargets.t3}
              <br><strong>Safety levels:</strong> ${longTargets.s1} • ${longTargets.s2} • ${longTargets.s3}
              <br><em style="color:var(--muted)">Recent H/L: ${longTargets.recentHigh}/${longTargets.recentLow} • SwingHigh:${longTargets.swingHigh}</em>
            </div>
          </div>
          <div class="recBox"><strong>Plan (long-term):</strong><br>Starter: ~10% of planned allocation.<br>Stop: below recent 4H consolidation low (use tight stop).<br>Add rules: add only after 2 of — 4H higher low; Volume on green candles ≥ 1.5× volMA; Accumulation confidence ≥ 70% on 4H/combined TFs.<br><em style="color:var(--muted)">Rationale: sim ${rec.sim}%, phase "${rec.phase}", accum ${rec.accum}%</em></div>
        </div>
      </div>
    `;
  });
  el.cardView.innerHTML = `<div class="card-panel">${html}</div>`;
  setTimeout(()=>{ const nodes=document.querySelectorAll('.coinCard.blink'); nodes.forEach(n=>n.classList.remove('blink')); }, 3000);
}

/* ---------- Trading interpretation renderer ---------- */
function buildTradingInterpretation(item){
  if(!item) return `<h3>No symbol to interpret</h3><p class="mutedNote">No results yet — run a scan.</p>`;

  const shortRec = getShortTermRecommendation(item);
  const expl = explainBlowoff(item);
  const phase = item.phase ? item.phase.phase : 'Unknown';
  const accum = item.accumCombined ? item.accumCombined.confidence : 0;
  const rsi4h = Math.round((item.rsi4h || 0));
  const funding = typeof item.fundingRate === 'number' ? (item.fundingRate*100).toFixed(3) + '%' : 'n/a';
  const drop = item.dropPctFromPeak || 0;
  const blowoffScore = item.score || 0;
  const wick = (item.wickRatio4||0).toFixed(2);
  const prob = expl.prob || 0;
  const longTargets = getLongTermTargets(item);

  const html = `
    <h3>Quick Trading Interpretation — ${item.symbol}</h3>
    <p><strong>Short-term bias:</strong> <span style="color:${shortRec.bias==='Bearish' ? '#ff9b9b' : (shortRec.bias==='Bullish' ? '#9bffcf' : '#cfe8ff')}">${shortRec.bias}</span></p>

    <div>
      <strong>Why:</strong>
      <ul class="tradeList">
        ${expl.reasons.length ? `<li>${expl.reasons.join('</li><li>')}</li>` : `<li>No major exhaustion points, see signals below.</li>`}
        <li>Dead-cat / structure: ${phase}</li>
        <li>4H RSI: ${rsi4h} (overbought threshold typically ≥75–80)</li>
        <li>Accumulation: ${accum}%</li>
        <li>Funding: ${funding} (negative indicates short pressure)</li>
        <li>Blowoff score: ${blowoffScore}/8 • Wick ratio: ${wick} • Estimated reversal chance: ${prob}%</li>
      </ul>
    </div>

    <div style="margin-top:8px">
      <strong>Short-term trade recommendation</strong>
      <p>${shortRec.sentence}</p>
      <div class="recBox">
        <strong>Plan:</strong> ${shortRec.plan}
        <div style="margin-top:6px"><strong>Targets:</strong> ${shortRec.targets.join(' • ')}</div>
        <div class="mutedNote">Starter size and stop depend on your risk profile. This is NOT financial advice.</div>
      </div>
    </div>

    <div style="margin-top:8px">
      <strong>Long-term plan & targets</strong>
      <div class="recBox">
        <strong>Starter:</strong> ~10% of planned allocation.<br>
        <strong>Stop:</strong> below recent 4H consolidation low.<br>
        <strong>Upside Targets:</strong> ${longTargets.t1} • ${longTargets.t2} • ${longTargets.t3}<br>
        <strong>Downside / Safety levels:</strong> ${longTargets.s1} • ${longTargets.s2} • ${longTargets.s3}<br>
        <em style="color:var(--muted)">Recent H/L: ${longTargets.recentHigh}/${longTargets.recentLow} • SwingHigh:${longTargets.swingHigh}</em>
      </div>
    </div>

    <div style="margin-top:8px">
      <strong>When short-term becomes bullish again</strong>
      <ul class="tradeList">
        <li>4H RSI drops below ~60</li>
        <li>Accumulation rises to ≥ 60–70%</li>
        <li>Confirmed 4H higher lows / rising green-volume</li>
        <li>Funding normalizes (less negative)</li>
      </ul>
    </div>

    <div class="mutedNote">Quick summary: <strong>${shortRec.bias}</strong>. Use small starters, tight stops, and confirm with 4H structure before scaling.</div>
  `;
  return html;
}

function updateTradingInterpretation(results){
  if(!results || !results.length){
    el.tradeInterpret.style.display = 'none';
    el.tradeInterpret.innerHTML = '';
    return;
  }
  const sorted = results.slice().sort((a,b)=> {
    if(b.score !== a.score) return b.score - a.score;
    if((b.similarity||0) !== (a.similarity||0)) return (b.similarity||0) - (a.similarity||0);
    return (b.ema70DistPct||0) - (a.ema70DistPct||0);
  });
  const top = sorted[0];
  el.tradeInterpret.style.display = 'block';
  el.tradeInterpret.innerHTML = buildTradingInterpretation(top);
}

/* ---------- Progress & countdown ---------- */
function updateProgress(){ const pct = totalTasks ? Math.round((doneTasks/totalTasks)*100) : 0; el.bar.style.width = pct + '%'; el.message.innerText = `Scanning ${doneTasks}/${totalTasks} (${pct}%) — delay ${el.delay.value}ms`; el.safetyStatus.innerText = `Req/min: ${requestsThisWindow}`; }
function startCountdown(sec){ if(countdownTimer) clearInterval(countdownTimer); const end = Date.now() + sec*1000; countdownTimer = setInterval(()=>{ const left = Math.max(0, Math.round((end - Date.now())/1000)); el.countdown.innerText = `Next scan in: ${left}s`; if(left <= 0){ clearInterval(countdownTimer); el.countdown.innerText='Running...'; } }, 500); }

/* ---------- MAIN RUN ---------- */
async function runScan(once=false){
  try{
    running=true; el.startBtn.disabled=true; el.stopBtn.disabled=false; el.debug.innerText=''; resetWindow(); el.message.innerText='Fetching top symbols...';
    const N = Math.max(5, Math.min(60, parseInt(el.prefilter.value,10) || 30));
    const delayMs = Math.max(50, Math.min(2000, parseInt(el.delay.value,10) || 450));
    const intervalSec = Math.max(10, Math.min(3600, parseInt(el.interval.value,10) || 60));

    const top = await getTopN(N);
    queue = []; totalTasks = top.length; doneTasks = 0; updateProgress(); const results = [];

    top.forEach(t => queueSymbolAnalysis(t.symbol, results));
    if(!once) startCountdown(intervalSec);

    while(queue.length && running){
      if(checkSafetyAndMaybePause()) break;
      const job = queue.shift();
      try{ await job(); } catch(e){ el.debug.innerText += `\nJob error: ${e.message}`; }
      doneTasks++; updateProgress();
      await delay(delayMs);
    }

    // core phase detection
    results.forEach(r => { r.phase = detectPhaseForSymbol(r); r.dropPctFromPeak = r.phase.dropPctFromPeak || 0; });

    // RUN RETURN-TO-NORMAL DETECTOR & ANNOTATE
    results.forEach(r => {
      const rtn = detectReturnToNormal(r, {sensitivity: parseInt(el.sensitivity.value,10) || 50});
      r.returnToNormal = rtn;
      if(rtn.isReturn){
        if(r.phase && r.phase.reasons) r.phase.reasons.unshift(`Return-to-normal (${rtn.confidence}%)`);
        else r.phase = {phase: 'Return-to-normal', confidence: rtn.confidence, reasons: [`Return-to-normal (${rtn.confidence}%)`] };
        r.phase.isReturnToNormal = true;
      }
    });


    // ----------------- EMA Cross scanner (replacement) -----------------
(async function(){
  // reuse safeFetch/delay if available (fallbacks already defined elsewhere)
  const API_BASE = window.API_BASE || 'https://fapi.binance.com';

  // config
  const klinesLimit = 300;      // request this many 15m candles (>= 200 recommended)
  const minCloseRequirement = 220; // minimum number of closes to attempt EMA200 reliably
  const recentCandles = 4;      // look-back window to detect a recent cross

  // UI refs
  const btn = document.getElementById('runEmaScanBtn');
  const statusEl = document.getElementById('emaScanStatus');
  const resultsEl = document.getElementById('emaScanResults');

  // safeFetch fallback already provided earlier in file

  // compute SMA
  function smaArr(arr, n){
    if(!arr || arr.length < n) return null;
    const slice = arr.slice(0,n);
    return slice.reduce((s,x)=>s+ x, 0)/n;
  }

  // EMA series with SMA seeding: returns array same length as prices
  function emaSeries(prices, period){
    if(!prices || prices.length === 0) return [];
    const out = new Array(prices.length).fill(null);
    if(prices.length < period){
      // fallback naive: simple single-pass EMA seeded with first price
      let e = prices[0];
      out[0] = e;
      const k = 2/(period+1);
      for(let i=1;i<prices.length;i++){
        e = prices[i]*k + e*(1-k);
        out[i] = e;
      }
      return out;
    }
    // seed with SMA of first 'period' values to reduce startup bias
    const seed = smaArr(prices.slice(0,period), period);
    out[period-1] = seed;
    const k = 2/(period+1);
    let prev = seed;
    for(let i=period;i<prices.length;i++){
      const v = prices[i]*k + prev*(1-k);
      out[i] = v;
      prev = v;
    }
    // for indices < period-1, fill a best-effort series by forward copying seed
    for(let i=0;i<period-1;i++) out[i] = prices[i]; // keep raw prices early
    return out;
  }

  async function fetch15mKlines(symbol, limit=klinesLimit){
    const url = `${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=15m&limit=${limit}`;
    return await safeFetch(url, { allowIfNotRunning: true });
  }

  // detect EMA70/200 cross from closes (returns object with detailed info)
  function detectEMACrossFromCloses(closes, times){
    // returns { crossed, dir, whenIndex (index in closes), whenTs, ema70, ema200, prevDiff, curDiff, reason }
    if(!closes || closes.length < minCloseRequirement){
      return { crossed:false, reason:`insufficient data: need ≥ ${minCloseRequirement} closes (have ${closes ? closes.length : 0})` };
    }
    // compute ema series
    const ema70series = emaSeries(closes, 70);
    const ema200series = emaSeries(closes, 200);
    if(!ema70series.length || !ema200series.length || ema70series.length !== ema200series.length){
      return { crossed:false, reason:'series computation failed' };
    }

    // compute diff = ema70 - ema200
    const diff = ema70series.map((v,i) => {
      const a = (typeof v === 'number') ? v : null;
      const b = (typeof ema200series[i] === 'number') ? ema200series[i] : null;
      return (a === null || b === null) ? null : (a - b);
    });

    // search for a sign change in the last (recentCandles + 2) points
    const start = Math.max(1, diff.length - (recentCandles + 2));
    for(let i = start; i < diff.length; i++){
      const prev = diff[i-1];
      const cur = diff[i];
      if(prev === null || cur === null) continue;
      // bullish cross: prev <= 0 && cur > 0
      if(prev <= 0 && cur > 0){
        return {
          crossed: true, dir: 'bull', whenIndex: i,
          whenTs: Array.isArray(times) ? times[i] : null,
          prevDiff: prev, curDiff: cur,
          ema70: ema70series[i], ema200: ema200series[i]
        };
      }
      // bearish cross: prev >= 0 && cur < 0
      if(prev >= 0 && cur < 0){
        return {
          crossed: true, dir: 'bear', whenIndex: i,
          whenTs: Array.isArray(times) ? times[i] : null,
          prevDiff: prev, curDiff: cur,
          ema70: ema70series[i], ema200: ema200series[i]
        };
      }
    }

    // no recent cross
    return { crossed:false, reason:'no recent cross', lastDiff: diff[diff.length-1] };
  }

  // analyze single symbol (15m) for EMA cross, returns structured result
  async function analyzeSymbolEMACross(sym){
    try{
      const kl = await fetch15mKlines(sym, klinesLimit);
      if(!Array.isArray(kl) || kl.length === 0) throw new Error('klines empty');
      const closes = kl.map(k => Number(k[4]));
      const times = kl.map(k => Number(k[0])); // open timestamp
      const res = detectEMACrossFromCloses(closes, times);
      // enrich with lastClose and lastTimestamp
      res.symbol = sym;
      res.lastClose = closes[closes.length-1];
      res.lastTs = times[times.length-1];
      return res;
    } catch(err){
      return { symbol: sym, error: err.message || String(err) };
    }
  }

  // main orchestrator
  async function runEMACrossScan({ positive=true, minDelayMs = 420 } = {}){
    try{
      if(btn) btn.disabled = true;
      if(resultsEl) resultsEl.innerHTML = '';
      if(statusEl) statusEl.innerText = 'Fetching tickers...';

      // fetch top30 by change
      const tickers = await safeFetch(API_BASE + '/fapi/v1/ticker/24hr', { allowIfNotRunning: true });
      const top = (tickers || [])
        .filter(t => t.symbol && t.symbol.endsWith('USDT'))
        .map(t => ({ symbol: t.symbol, priceChangePercent: Number(t.priceChangePercent||0) }))
        .sort((a,b) => positive ? b.priceChangePercent - a.priceChangePercent : a.priceChangePercent - b.priceChangePercent)
        .slice(0,30);

      if(statusEl) statusEl.innerText = `Found ${top.length} symbols — analyzing...`;
      const matches = [];
      for(let i=0;i<top.length;i++){
        const sym = top[i].symbol;
        if(statusEl) statusEl.innerText = `(${i+1}/${top.length}) ${sym} — fetching 15m...`;
        const r = await analyzeSymbolEMACross(sym);
        // render progress row
        const row = document.createElement('div');
        row.style.padding='6px 0';
        row.style.borderBottom='1px solid rgba(255,255,255,0.03)';
        if(r.error) {
          row.innerHTML = `<b>${sym}</b> — ❌ ${r.error}`;
        } else if(r.crossed) {
          matches.push(r);
          const when = r.whenTs ? new Date(r.whenTs).toLocaleString() : `idx ${r.whenIndex}`;
          row.innerHTML = `<b>${sym}</b> — ${r.dir === 'bull' ? '🔼 Bullish cross' : '🔽 Bearish cross'} • when: ${when}`;
        } else {
          row.innerHTML = `<b>${sym}</b> — — ${r.reason || 'no cross'}`;
        }
        if(resultsEl) resultsEl.appendChild(row);
        await delay(minDelayMs);
      }

      if(statusEl) statusEl.innerText = `Scan complete — matches: ${matches.length}`;
      // display summary table if any matches
      if(matches.length && resultsEl){
        const table = document.createElement('table');
        table.style.width='100%';
        table.style.borderCollapse='collapse';
        table.style.marginTop='8px';
        table.innerHTML = `<thead><tr><th>Symbol</th><th>Direction</th><th>LastClose</th><th>when</th><th>ema70</th><th>ema200</th></tr></thead>`;
        const tb = document.createElement('tbody');
        matches.forEach(m=>{
          const tr = document.createElement('tr');
          tr.style.borderTop='1px solid rgba(255,255,255,0.03)';
          tr.innerHTML = `<td>${m.symbol}</td><td>${m.dir}</td><td>${m.lastClose}</td><td>${ m.whenTs ? new Date(m.whenTs).toLocaleString() : m.whenIndex }</td><td>${(m.ema70||0).toFixed(8)}</td><td>${(m.ema200||0).toFixed(8)}</td>`;
          tb.appendChild(tr);
        });
        table.appendChild(tb);
        resultsEl.appendChild(document.createElement('hr'));
        resultsEl.appendChild(table);
      }

      return matches;
    } catch(err){
      if(statusEl) statusEl.innerText = 'Scan failed: ' + (err.message || err);
      throw err;
    } finally {
      if(btn) btn.disabled = false;
    }
  }

  // wire UI
  if(btn){
    btn.addEventListener('click', async ()=>{
      const mode = document.querySelector('input[name="ec_mode"]:checked')?.value || 'gainers';
      const positive = mode === 'gainers';
      if(resultsEl) resultsEl.innerHTML = '';
      try{
        await runEMACrossScan({ positive, minDelayMs: 420 });
      } catch(e){
        console.error('EMA scan error', e);
      }
    });
  }

  // expose function globally
  window.runEMACrossScan = runEMACrossScan;
})();


    // ---------------------------
// Fixed “Full Cycle” reference vector (parabolic → blowoff → long decay → dead-flat)
// This is a static template derived from the screenshot cycles (MAVIA, COAI, SOON, JELLY, EVAA)
// ---------------------------
const referenceFullCycleVector = {
  // these values are tuned to represent a completed blowoff + decay cycle
  rsi4h: 30,              // washed-out RSI after the decay
  volSpike4: 5.0,         // large spike at blowoff
  wickRatio4: 6.0,        // big upper wick at the top
  ema70DistPct: 150,      // large EMA stretch at peak (in %)
  fundingRate: -0.2,      // negative funding typical post-blowoff
  slope15: -1,            // short-term slope negative (decay)
  dropPctFromPeak: 85,    // huge drop from peak (in %)
  accumCombined: { confidence: 20, isAccum: false } // low accumulation after full flattening
};

// Build a feature vector from the fixed template and compute similarity for every result
try {
  const pippinVector = makeFeatureVector(referenceFullCycleVector);
  results.forEach(r => {
    // ensure makeFeatureVector can accept objects with missing keys safely (it already does)
    r.similarity = cosineSim(makeFeatureVector(r), pippinVector);
  });
} catch(err) {
  console.warn('Error computing static template similarity:', err.message);
  results.forEach(r => r.similarity = 0);
}
    
    // store latest results globally and sort using user's choice
    window.lastScanResults = results;
    sortResults(window.lastScanResults);

    prevBlowoffSet = new Set(window.lastScanResults.filter(r=> r.score >= (parseInt(el.threshold.value,10)||4)).map(r=>r.symbol));
    if(window.innerWidth >= 680) renderTable(window.lastScanResults); else renderCards(window.lastScanResults);

    // update interpretation panel
    updateTradingInterpretation(window.lastScanResults);

    // alerts (same behavior as before)
    const condEnabled = el.condAlert.checked;
    const accumThreshold = Math.max(0, Math.min(100, parseInt(el.accumAlertThreshold.value,10) || 50));
    const blowoffThreshold = parseInt(el.threshold.value,10) || 4;
    const flagged = window.lastScanResults.filter(r => r.score >= blowoffThreshold);
    const flaggedCond = flagged.filter(r => r.accumCombined && r.accumCombined.confidence >= accumThreshold);

    if(condEnabled && flaggedCond.length){
      try{ const audio = new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg'); audio.volume=0.85; audio.play().catch(()=>{}); }catch(e){}
      if(Notification && Notification.permission === 'granted') new Notification('Blowoff+Accum Alert', { body: flaggedCond.map(x => `${x.symbol} acc:${x.accumCombined.confidence}%`).slice(0,6).join(', ') });
      else if(Notification && Notification.permission !== 'denied') Notification.requestPermission();
    } else if(!condEnabled && flagged.length){
      try{ const audio = new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg'); audio.volume=0.7; audio.play().catch(()=>{}); }catch(e){}
      if(Notification && Notification.permission === 'granted') new Notification('Blowoff Detected', { body: flagged.map(f=>f.symbol).slice(0,6).join(', ') });
      else if(Notification && Notification.permission !== 'denied') Notification.requestPermission();
    }

    if(!once){
      if(requestsThisWindow > SAFETY_MAX){ el.debug.innerText += '\nAuto-paused due to safety'; }
      else { if(autoTimer) clearTimeout(autoTimer); autoTimer = setTimeout(()=>{ if(requestsThisWindow <= SAFETY_MAX) runScan(false); }, intervalSec * 1000); startCountdown(intervalSec); }
    }

    running=false; el.startBtn.disabled=false; el.stopBtn.disabled=true;
  } catch(e){
    el.debug.innerText += `\nRun error: ${e.message}`;
    running=false; el.startBtn.disabled=false; el.stopBtn.disabled=true;
  }
}

/* UI events */
  // wire buttons (call after DOM ready)
// === EMA UI wiring (place next to other el.* assignments) ===
el.runEmaScanBtn = document.getElementById('runEmaScanBtn');
el.emaScanStatus = document.getElementById('emaScanStatus');
el.emaScanResults = document.getElementById('emaScanResults');

if(!el.runEmaScanBtn){
  console.warn('EMA UI: runEmaScanBtn not found - check your HTML id');
} else {
  el.runEmaScanBtn.addEventListener('click', async () => {
    // defensive checks
    if(typeof window.runEMACrossScan !== 'function'){
      const msg = 'EMA scanner function not found (window.runEMACrossScan).';
      console.error(msg);
      if(el.emaScanStatus) el.emaScanStatus.innerText = msg;
      return;
    }

    // read mode radio (defaults to gainers)
    const mode = document.querySelector('input[name="ec_mode"]:checked')?.value || 'gainers';
    const positive = mode === 'gainers';

    // disable UI
    el.runEmaScanBtn.disabled = true;
    if(el.scanTopGreenBtn) el.scanTopGreenBtn.disabled = true;
    if(el.scanTopRedBtn) el.scanTopRedBtn.disabled = true;
    if(el.emaScanStatus) el.emaScanStatus.innerText = `Running EMA Cross Scan — mode: ${mode}...`;
    if(el.emaScanResults) el.emaScanResults.innerHTML = '';

    try {
      // runEMACrossScan should accept options and return results (array) — adapt as needed
      const matches = await window.runEMACrossScan({ positive, minDelayMs: 400 });

      if(el.emaScanStatus) el.emaScanStatus.innerText = `EMA scan complete — ${Array.isArray(matches) ? matches.length : 'done'}.`;

      // optional: render basic list
      if(el.emaScanResults && Array.isArray(matches)){
        const html = matches.map(m => {
          const s = (typeof m === 'string') ? m : (m.symbol || m.symbolName || m.symbol?.symbol || JSON.stringify(m));
          return `<div class="ema-result-row">${s}</div>`;
        }).join('');
        el.emaScanResults.innerHTML = html;
      }
    } catch(err){
      console.error('EMA scan failed:', err);
      if(el.emaScanStatus) el.emaScanStatus.innerText = 'EMA scan error: ' + (err && err.message ? err.message : String(err));
    } finally {
      // re-enable
      el.runEmaScanBtn.disabled = false;
      if(el.scanTopGreenBtn) el.scanTopGreenBtn.disabled = false;
      if(el.scanTopRedBtn) el.scanTopRedBtn.disabled = false;
    }
  });
}
  
el.scanTopGreenBtn = document.getElementById('scanTopGreenBtn');
el.scanTopRedBtn   = document.getElementById('scanTopRedBtn');
el.scanStatus = document.getElementById('scanStatus');

el.scanTopGreenBtn.addEventListener('click', async () => {
  el.scanTopGreenBtn.disabled = true;
  el.scanTopRedBtn.disabled = true;
  el.scanStatus.innerText = 'Running Top30 Gainers (green) scan...';
  await runTop30Scan({ positive: true, mode: 'resistance' });
  el.scanTopGreenBtn.disabled = false;
  el.scanTopRedBtn.disabled = false;
});

el.scanTopRedBtn.addEventListener('click', async () => {
  el.scanTopGreenBtn.disabled = true;
  el.scanTopRedBtn.disabled = true;
  el.scanStatus.innerText = 'Running Top30 Losers (red) scan...';
  await runTop30Scan({ positive: false, mode: 'bearish' });
  el.scanTopGreenBtn.disabled = false;
  el.scanTopRedBtn.disabled = false;
});
  
el.startBtn.addEventListener('click', ()=>{ if(running) return; prevBlowoffSet = new Set(); runScan(false); });
el.stopBtn.addEventListener('click', ()=>{ running=false; queue=[]; el.startBtn.disabled=false; el.stopBtn.disabled=true; if(autoTimer) clearTimeout(autoTimer); if(countdownTimer) clearInterval(countdownTimer); el.countdown.innerText='Next scan in: -'; el.message.innerText='Stopped.'; });
el.oneShot.addEventListener('click', ()=>{ if(running) return; runScan(true); });
el.sensitivity.addEventListener('input', ()=>{ el.sensVal.innerText = el.sensitivity.value; });
if('Notification' in window){ try{ Notification.requestPermission().catch(()=>{}); } catch(e){} }
(async function ping(){ try{ await fetch(API_BASE + '/fapi/v1/ping'); } catch(e){ console.warn('ping failed', e); } })();

</script>

<footer class="small">Multi-TF accumulation detector + sensitivity + conditional alerts + long-term AI recommendation + short-term trade guidance. Long-term targets (upside) + safety levels included. Run from a local server to avoid CORS.</footer>
</body>
</html>
