<!doctype html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Blowoff Top Detector ‚Äî Hybrid AI Mode (with Sorting)</title><style>
  :root{
    --bg:#07101a;
    --card:#0b1220;
    --muted:#9fb3cc;
    --accent:#2dd4bf;
    --danger:#ff7b7b;
  }

  body{
    font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;
    background:var(--bg);
    color:#e6eef8;
    margin:16px;
  }

  .card-panel{
    background:var(--card);
    border:1px solid #172033;
    padding:14px;
    border-radius:10px;
    box-shadow:0 6px 20px rgba(0,0,0,.6);
    margin-bottom:16px;
  }

  h1{margin:0;font-size:18px}

  .controls{
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    margin-top:12px;
    align-items:center
  }

  label{font-size:13px;color:var(--muted)}

  input, select{
    background:#071722;
    border:1px solid #243241;
    color:#e6eef8;
    padding:6px;
    border-radius:6px;
  }

  button{
    background:#1f6feb;
    border:none;
    color:white;
    padding:8px 10px;
    border-radius:6px;
    cursor:pointer;
  }

  button.alt{ background:#2b3947 }

  .status{
    margin-top:8px;
    color:var(--muted);
    font-size:13px;
    display:flex;
    gap:12px;
    align-items:center;
    flex-wrap:wrap;
  }

  .progress{
    height:8px;
    background:#05101a;
    border-radius:4px;
    margin-top:8px;
    overflow:hidden;
    flex:1
  }

  .progress > i{
    display:block;
    height:100%;
    background:linear-gradient(90deg,var(--accent),#60a5fa);
    width:0%
  }

  .countdown{
    font-weight:700;
    color:#cfe8ff;
  }

  .mutedBadge{
    background:rgba(255,255,255,0.03);
    color:var(--muted);
    padding:4px 8px;
    border-radius:8px;
    font-size:12px;
  }

  /* DESKTOP TABLE */
  #tableView{ display:block }
  #cardView{ display:none }

  table{
    width:100%;
    border-collapse:collapse;
    margin-top:12px;
    font-size:13px;
    min-width:700px;
  }

  th, td{
    padding:8px 10px;
    border-bottom:1px dashed #122331;
    text-align:left;
  }

  th{
    color:var(--muted);
    font-size:12px
  }

  .green{ color:#66f9a1 }
  .red{ color:var(--danger) }

  .small{ font-size:12px;color:var(--muted) }

  .blink{
    animation: blinkHighlight 1.8s ease-in-out 3;
  }

  @keyframes blinkHighlight {
    0% { box-shadow:0 0 0px rgba(255,80,80,0.0); }
    50% { box-shadow:0 0 12px rgba(255,80,80,0.35); }
    100% { box-shadow:0 0 0px rgba(255,80,80,0.0); }
  }

  /* MOBILE CARD UI */
  @media (max-width:680px){
    #tableView{ display:none }
    #cardView{ display:block }

    .coinCard{
      background:var(--card);
      border:1px solid #172033;
      padding:12px;
      border-radius:10px;
      margin-bottom:12px;
    }

    .coinRow1{
      display:flex;
      justify-content:space-between;
      align-items:center;
    }

    .coinSymbol{
      font-size:16px;
      font-weight:700;
    }

    .coinScore{
      font-size:14px;
      font-weight:700;
    }

    .blowBadge{
      background:#ff4d4d;
      padding:4px 8px;
      border-radius:6px;
      color:white;
      font-size:12px;
      font-weight:700;
    }

    .potBadge{
      background:#ffd966;
      padding:4px 8px;
      border-radius:6px;
      color:black;
      font-size:12px;
      font-weight:700;
    }

    .sigList{
      margin-top:8px;
      font-size:12px;
      line-height:18px;
      color:#cce3ff;
    }
  }

  /* SORT ICON */
  .sortBtn{ cursor:pointer; user-select:none; }
  .sortIcon{ font-size:11px; opacity:0.8; margin-left:6px }
</style></head>
<body><div class="card-panel">
  <h1>Blowoff Top Detector ‚Äî Hybrid AI Mode</h1>  <div class="small" style="margin-top:6px;color:var(--muted)">
    Auto-scans top N Binance Futures coins for blowoff-top behavior.  
    Hybrid UI: Desktop = Table ‚Ä¢ Mobile = Card View.  
    Includes rule-based AI explanation, alerts, & auto-pause safety.
  </div>  <!-- CONTROL BAR -->  <div class="controls">
    <label>Prefilter <input id="prefilter" type="number" value="30" min="5" max="100"></label>
    <label>Delay (ms) <input id="delay" type="number" value="450" min="50" max="2000"></label>
    <label>Refresh (sec) <input id="interval" type="number" value="60" min="10" max="3600"></label>
    <label>Score ‚â• <input id="threshold" type="number" value="4" min="1" max="6"></label><!-- SORTING CONTROLS (NEW) -->
<label style="display:flex;align-items:center">Sort by
  <select id="sortField" style="margin-left:8px">
    <option value="score">Score</option>
    <option value="volSpike">Vol Spike</option>
    <option value="wickRatio">Wick Ratio</option>
    <option value="ema70DistPct">EMA Distance</option>
    <option value="rsi4h">RSI 4H</option>
    <option value="rsi1d">RSI 1D</option>
    <option value="funding">Funding Rate</option>
    <option value="last">Last Price</option>
    <option value="change24">24h Change</option>
  </select>
</label>

<label style="display:flex;align-items:center">Order
  <select id="sortOrder" style="margin-left:8px">
    <option value="desc">Descending</option>
    <option value="asc">Ascending</option>
  </select>
</label>

<button id="startBtn">Start</button>
<button id="stopBtn" class="alt" disabled>Stop</button>
<button id="oneShot" class="alt">Run Once</button>

  </div>  <!-- STATUS BAR -->  <div class="status">
    <div id="message">Ready.</div>
    <div class="progress"><i id="bar"></i></div>
    <div id="countdown" class="countdown">Next scan in: -</div>
    <div id="safetyStatus" class="mutedBadge">Safety OK</div>
  </div>  <!-- DESKTOP VIEW -->  <div id="tableView"></div>  <!-- MOBILE VIEW -->  <div id="cardView"></div>  <div id="debug" class="small" style="margin-top:10px"></div>
</div><script>
/* ============================================================
   SECTION C WILL START HERE (JavaScript Engine)
   ============================================================ */

/* ============================================================
   SECTION C ‚Äî JavaScript engine: scanning, indicators, rendering
   ============================================================ */

const API_BASE = "https://fapi.binance.com";

// ------- BLACKLIST -------
const blacklist = [
  "ALPACAUSDT","BNXUSDT","ALPHAUSDT","OCEANUSDT","DGBUSDT",
  "AGIXUSDT","LINAUSDT","LOKAUSDT","KEYUSDT","MDTUSDT",
  "LOOMUSDT","RENUSDT","OMNIUSDT","SLERFUSDT","STMXUSDT",
  "UXLINKUSDT","BSWUSDT","NEIROETHUSDT","VIDTUSDT","TROYUSDT",
  "BAKEUSDT","AMBUSDT","MEMEFIUSDT","NULSUSDT","HIFIUSDT",
  "LEVERUSDT","XEMUSDT","STRAXUSDT","COMBOUSDT"
];

// ------- ELEMENTS -------
const el = {
  prefilter: document.getElementById("prefilter"),
  delay: document.getElementById("delay"),
  interval: document.getElementById("interval"),
  threshold: document.getElementById("threshold"),
  startBtn: document.getElementById("startBtn"),
  stopBtn: document.getElementById("stopBtn"),
  oneShot: document.getElementById("oneShot"),
  message: document.getElementById("message"),
  bar: document.getElementById("bar"),
  tableView: document.getElementById("tableView"),
  cardView: document.getElementById("cardView"),
  debug: document.getElementById("debug"),
  safetyStatus: document.getElementById("safetyStatus"),
  countdown: document.getElementById("countdown"),
  sortField: document.getElementById("sortField"),
  sortOrder: document.getElementById("sortOrder")
};

// ------- STATE -------
let running = false;
let queue = [];
let totalTasks = 0;
let doneTasks = 0;
let autoTimer = null;
let countdownTimer = null;
let requestsThisWindow = 0;
let windowStart = Date.now();
const SAFETY_WINDOW = 60000;
const SAFETY_MAX = 900; // conservative
const SAFETY_PAUSE = 30; // seconds
let prevBlow = new Set();

// ------- UTILITIES (indicators) -------
function sma(arr, n){
  if(!arr || arr.length < n) return null;
  let s = 0;
  for(let i=arr.length-n;i<arr.length;i++) s += arr[i];
  return s / n;
}
function ema(arr, period){
  if(!arr || arr.length === 0) return null;
  const k = 2/(period+1);
  let e = arr[0];
  for(let i=1;i<arr.length;i++) e = arr[i]*k + e*(1-k);
  return e;
}
function rsiFromCloses(closes, period=14){
  if(!closes || closes.length <= period) return null;
  let gains=0, losses=0;
  for(let i=closes.length-period;i<closes.length;i++){
    const d = closes[i] - closes[i-1];
    if(d>0) gains += d; else losses += Math.abs(d);
  }
  const avgGain = gains/period;
  const avgLoss = losses/period;
  if(avgLoss === 0) return 100;
  const rs = avgGain / avgLoss;
  return 100 - (100/(1+rs));
}
function pct(a,b){ return b===0 ? 0 : ((a-b)/b)*100; }
function delay(ms){ return new Promise(r=>setTimeout(r,ms)); }

// ------- SAFE FETCH (counts requests) -------
async function safeFetch(url){
  if(!running) throw new Error("Not running");
  requestsThisWindow++;
  const res = await fetch(url);
  if(!res.ok) throw new Error("HTTP "+res.status);
  return res.json();
}

// ------- SAFETY WINDOW MANAGEMENT -------
function resetWindow(){
  requestsThisWindow = 0;
  windowStart = Date.now();
}
function safetyCheck(){
  const now = Date.now();
  if(now - windowStart > SAFETY_WINDOW){
    resetWindow();
    el.safetyStatus.innerText = "Safety OK";
    return false;
  }
  if(requestsThisWindow > SAFETY_MAX){
    // auto-pause
    running = false;
    el.safetyStatus.innerText = `Auto-paused (high req: ${requestsThisWindow})`;
    el.message.innerText = `Paused ${SAFETY_PAUSE}s to avoid limit.`;
    el.stopBtn.disabled = true;
    el.startBtn.disabled = false;
    // increase delay slightly
    setTimeout(()=>{
      el.safetyStatus.innerText = "Resuming after pause";
      const cur = Math.max(200, parseInt(el.delay.value,10) || 450);
      el.delay.value = Math.min(2000, Math.round(cur * 1.5));
      resetWindow();
    }, SAFETY_PAUSE*1000);
    return true;
  }
  el.safetyStatus.innerText = `Req/min: ${requestsThisWindow}`;
  return false;
}

// ------- QUEUE PROCESSOR -------
async function processQueue(){
  const d = Math.max(50, Math.min(2000, parseInt(el.delay.value,10) || 450));
  while(queue.length && running){
    if(safetyCheck()) break;
    const job = queue.shift();
    try{ await job(); } catch(e){ el.debug.innerText += `\nJob error: ${e.message}`; }
    doneTasks++;
    updateProgress();
    await delay(d);
  }
  running = false;
  el.startBtn.disabled = false;
  el.stopBtn.disabled = true;
  el.message.innerText = "Scan complete.";
}

// ------- GET TOP N (24h change) -------
async function getTopN(n){
  const tick = await safeFetch(API_BASE + "/fapi/v1/ticker/24hr");
  const list = tick.filter(t => t.symbol && t.symbol.endsWith("USDT") && !blacklist.includes(t.symbol));
  list.sort((a,b)=> parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent));
  return list.slice(0,n).map(x=>({symbol:x.symbol, last: Number(x.lastPrice), change24: Number(x.priceChangePercent)}));
}

// ------- Queue Symbol Analysis (push jobs) -------
function queueSymbol(symbol, results){
  queue.push(async ()=>{
    try{
      const [k1d, k4h, k15, fund] = await Promise.all([
        safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=1d&limit=9`),
        safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=4h&limit=20`),
        safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=15m&limit=30`),
        safeFetch(`${API_BASE}/fapi/v1/fundingRate?symbol=${symbol}&limit=1`)
      ]);

      const closes1d = k1d.map(k=>Number(k[4]));
      const closes4h = k4h.map(k=>Number(k[4]));
      const vols4h = k4h.map(k=>Number(k[5]));
      const last4 = k4h[k4h.length-1];
      const prev4 = k4h[k4h.length-2] || last4;

      const open4 = Number(last4[1]);
      const high4 = Number(last4[2]);
      const low4 = Number(last4[3]);
      const close4 = Number(last4[4]);
      const body = Math.abs(close4 - open4) || 1e-9;
      const upperWick = Math.max(0, high4 - Math.max(open4, close4));
      const wickRatio = upperWick / body;

      const volMA = sma(vols4h, Math.min(10, vols4h.length)) || 0;
      const volSpike = volMA > 0 ? Number((vols4h[vols4h.length-1] / volMA).toFixed(2)) : 1;

      const ema70 = ema(closes4h, 70) || ema(closes4h, Math.min(21, closes4h.length));
      const emaDistPct = ema70 ? Number(pct(close4, ema70).toFixed(2)) : 0;

      const rsi1d = rsiFromCloses(closes1d, 14);
      const rsi4h = rsiFromCloses(closes4h, 14);

      const lowerHigh = Number(high4) < Number(prev4[2]);

      const fundingRate = (fund && fund.length) ? Number(fund[0].fundingRate) : 0;

      // scoring (tuned)
      let score = 0;
      const signals = {};
      if(rsi1d !== null && rsi1d >= 88){ score++; signals.rsi1d=true; } else signals.rsi1d=false;
      if(rsi4h !== null && rsi4h >= 80){ score++; signals.rsi4h=true; } else signals.rsi4h=false;
      if(volSpike >= 1.8){ score++; signals.volSpike=true; } else signals.volSpike=false;
      if(wickRatio >= 1.2){ score++; signals.wickTop=true; } else signals.wickTop=false;
      if(emaDistPct >= 50){ score++; signals.emaDist=true; } else signals.emaDist=false;
      if(lowerHigh){ score++; signals.lowerHigh=true; } else signals.lowerHigh=false;
      if(typeof fundingRate === "number" && fundingRate < -0.0005){ score++; signals.fundingConfirm=true; } else signals.fundingConfirm=false;
      signals.funding = fundingRate;

      results.push({
        symbol,
        score,
        rsi1d,
        rsi4h,
        volSpike,
        wickRatio,
        ema70DistPct: emaDistPct,
        lowerHigh,
        funding: fundingRate,
        last: close4,
        change24: null,
        signals
      });

    } catch(err){
      el.debug.innerText += `\nError ${symbol}: ${err.message}`;
    }
  });
}

// ------- Sorting helper (NEW) -------
function applySort(results){
  const field = el.sortField.value || 'score';
  const order = el.sortOrder.value === 'asc' ? 1 : -1;

  // mapping for nested or aliased fields
  const getter = (r) => {
    if(field === 'score') return r.score ?? -Infinity;
    if(field === 'volSpike') return r.volSpike ?? -Infinity;
    if(field === 'wickRatio') return r.wickRatio ?? -Infinity;
    if(field === 'ema70DistPct') return r.ema70DistPct ?? -Infinity;
    if(field === 'rsi4h') return r.rsi4h ?? -Infinity;
    if(field === 'rsi1d') return r.rsi1d ?? -Infinity;
    if(field === 'funding') return r.funding ?? -Infinity;
    if(field === 'last') return r.last ?? -Infinity;
    if(field === 'change24') return r.change24 ?? -Infinity;
    return r.score ?? -Infinity;
  };

  results.sort((a,b)=>{
    const va = getter(a);
    const vb = getter(b);
    // handle NaN or null
    const na = (va === null || va === undefined || Number.isNaN(va));
    const nb = (vb === null || vb === undefined || Number.isNaN(vb));
    if(na && nb) return 0;
    if(na) return 1 * order; // push missing to end
    if(nb) return -1 * order;

    if(typeof va === 'string' && typeof vb === 'string') return va.localeCompare(vb) * order;
    return (va - vb) * order;
  });
}

// ------- Update Progress -------
function updateProgress(){
  if(!totalTasks) return;
  const pct = Math.round((doneTasks/totalTasks)*100);
  el.bar.style.width = pct + "%";
  el.message.innerText = `Scanning ${doneTasks}/${totalTasks} (${pct}%) ‚Äî delay ${el.delay.value}ms`;
  el.safetyStatus.innerText = `Req/min: ${requestsThisWindow}`;
}

// ------- Countdown -------
function startCountdown(sec){
  if(countdownTimer) clearInterval(countdownTimer);
  const end = Date.now() + sec*1000;
  countdownTimer = setInterval(()=>{
    const leftMs = Math.max(0, end - Date.now());
    const s = Math.round(leftMs/1000);
    el.countdown.innerText = `Next scan in: ${s}s`;
    if(s <= 0){
      clearInterval(countdownTimer);
      el.countdown.innerText = "Running...";
    }
  }, 500);
}

/* ============================================================
   Rule-based AI explanation helper (inserted here)
   ============================================================ */
function explainBlowoff(item){
  const p = item;
  let pts = 0;
  const reasons = [];

  // RSI 1D weighty
  if(p.rsi1d !== null && p.rsi1d >= 88){ pts += 2; reasons.push(`1D RSI very high (${p.rsi1d})`); }
  else if(p.rsi1d !== null && p.rsi1d >= 80){ pts += 1; reasons.push(`1D RSI high (${p.rsi1d})`); }

  if(p.rsi4h !== null && p.rsi4h >= 85){ pts += 1; reasons.push(`4H RSI overbought (${p.rsi4h})`); }

  // volume
  if(p.volSpike >= 3){ pts += 2; reasons.push(`Volume climax √ó${p.volSpike}`); }
  else if(p.volSpike >= 1.8){ pts += 1; reasons.push(`Volume spike √ó${p.volSpike}`); }

  // wick
  if(p.wickRatio >= 2.0){ pts += 2; reasons.push(`Large upper wick (ratio ${p.wickRatio.toFixed(2)})`); }
  else if(p.wickRatio >= 1.2){ pts += 1; reasons.push(`Upper wick present (ratio ${p.wickRatio.toFixed(2)})`); }

  // ema dist
  if(p.ema70DistPct >= 150){ pts += 2; reasons.push(`Extreme EMA stretch (${p.ema70DistPct}% above EMA70)`); }
  else if(p.ema70DistPct >= 50){ pts += 1; reasons.push(`Price stretched from EMA (${p.ema70DistPct}% )`); }

  // funding
  if(typeof p.funding === 'number'){
    if(p.funding < -0.001){ pts += 2; reasons.push(`Funding strongly negative (${(p.funding*100).toFixed(3)}%)`); }
    else if(p.funding < -0.0005){ pts += 1; reasons.push(`Funding negative (${(p.funding*100).toFixed(3)}%)`); }
  }

  // lower high
  if(p.lowerHigh){ pts += 1; reasons.push('Lower high formed'); }

  // score contribute
  if(typeof p.score === 'number'){
    if(p.score >= 6) pts += 2;
    else if(p.score >= 4) pts += 1;
  }

  // map to label
  let label = 'None', color = '#9fb3cc', prob = 5;
  if(pts >= 10){ label = 'Extreme'; color = '#e74c3c'; prob = 92; }
  else if(pts >= 7){ label = 'High'; color = '#ff6b43'; prob = 78; }
  else if(pts >= 4){ label = 'Medium'; color = '#ffd966'; prob = 55; }
  else if(pts >= 2){ label = 'Low'; color = '#7bd389'; prob = 25; }
  else { label = 'None'; color = '#9fb3cc'; prob = 5; }

  const topReasons = reasons.slice(0,4);
  const explanation = topReasons.length
    ? `${topReasons.join('; ')}. Estimated reversal probability: ${prob}%.`
    : `No clear exhaustion signals detected.`;

  return { pts, label, color, prob, explanation, reasons: topReasons };
}

/* ============================================================
   RENDERING (hybrid) ‚Äî renderTable & renderCards use explainBlowoff
   ============================================================ */

function renderTable(results){
  const th = `
    <table>
      <thead>
        <tr>
          <th class="sortBtn" data-field="symbol">Symbol / Status</th>
          <th class="sortBtn" data-field="last">Last <span class="sortIcon">‚Üï</span></th>
          <th class="sortBtn" data-field="rsi4h">RSI4H <span class="sortIcon">‚Üï</span></th>
          <th>Signals</th>
          <th class="sortBtn" data-field="funding">Funding <span class="sortIcon">‚Üï</span></th>
        </tr>
      </thead>
      <tbody>
  `;

  const rows = results.map(r=>{
    let status = "normal";
    let bg = "background:rgba(255,255,255,0.02);";
    let cls = "";

    if(r.score >= 4){
      status = `<span style="background:#ff4d4d;color:white;font-size:11px;padding:4px 6px;border-radius:6px">üî• BLOWOFF</span>`;
      bg = "background:rgba(255,40,40,0.18);";
      if(!prevBlow.has(r.symbol)) cls = "blink";
    } else if(r.score === 3){
      status = `<span style="background:#ffd966;color:black;font-size:11px;padding:4px 6px;border-radius:6px">‚ö†Ô∏è Potential</span>`;
      bg = "background:rgba(255,200,0,0.14);";
    }

    // explanation
    const expl = explainBlowoff({
      score: r.score,
      rsi1d: r.rsi1d !== undefined ? r.rsi1d : null,
      rsi4h: r.rsi4h !== undefined ? r.rsi4h : null,
      volSpike: r.volSpike || 0,
      wickRatio: r.wickRatio !== undefined ? r.wickRatio : (r.wickTopRatio || 0),
      ema70DistPct: r.ema70DistPct !== undefined ? r.ema70DistPct : 0,
      lowerHigh: r.lowerHigh,
      funding: r.funding !== undefined ? r.funding : 0
    });

    const explRow = `<tr style="background:rgba(255,255,255,0.02)"><td colspan="5" style="padding:8px 12px;color:${expl.color}"><strong>${expl.label}</strong> ‚Äî ${expl.explanation}</td></tr>`;

    return `
      <tr class="${cls}" style="${bg}">
        <td><strong>${r.symbol}</strong><br>${status}</td>
        <td>${r.last}</td>
        <td class="${r.rsi4h >= 80 ? 'green' : ''}">${r.rsi4h !== undefined && r.rsi4h !== null ? r.rsi4h.toFixed(1) : 'n/a'}</td>
        <td class="small">vol:${r.volSpike} wick:${(r.wickRatio || 0).toFixed(2)} ema:${r.ema70DistPct}%</td>
        <td class="small">${(r.funding !== undefined ? r.funding : 0).toFixed(6)}</td>
      </tr>
      ${explRow}
    `;
  }).join("");

  el.tableView.innerHTML = `<div class="card-panel">${th}${rows}</tbody></table></div>`;

  // attach header click sorting (desktop)
  const headers = el.tableView.querySelectorAll('th.sortBtn');
  headers.forEach(h => {
    h.style.cursor = 'pointer';
    h.addEventListener('click', ()=>{
      const fld = h.getAttribute('data-field');
      if(!fld) return;
      // if user clicks header, set the sort control then re-render
      if(el.sortField.value === fld){
        // toggle order
        el.sortOrder.value = (el.sortOrder.value === 'asc') ? 'desc' : 'asc';
      } else {
        el.sortField.value = fld;
      }
      // re-render using existing results
      renderResults(results);
    });
  });

  // clear blink after short time
  setTimeout(()=> {
    const nodes = document.querySelectorAll('tr.blink');
    nodes.forEach(n => n.classList.remove('blink'));
  }, 4000);
}

function renderCards(results){
  let html = "";

  results.forEach(r=>{
    let badge = `<span class="small" style="color:var(--muted)">normal</span>`;
    let cls = "";

    if(r.score >= 4){
      badge = `<span class="blowBadge">üî• Blowoff</span>`;
      cls = (!prevBlow.has(r.symbol) ? "blink" : "");
    } else if(r.score === 3){
      badge = `<span class="potBadge">‚ö† Potential</span>`;
    }

    const expl = explainBlowoff({
      score: r.score,
      rsi1d: r.rsi1d !== undefined ? r.rsi1d : null,
      rsi4h: r.rsi4h !== undefined ? r.rsi4h : null,
      volSpike: r.volSpike || 0,
      wickRatio: r.wickRatio !== undefined ? r.wickRatio : (r.wickTopRatio || 0),
      ema70DistPct: r.ema70DistPct !== undefined ? r.ema70DistPct : 0,
      lowerHigh: r.lowerHigh,
      funding: r.funding !== undefined ? r.funding : 0
    });

    const reasonHtml = expl.reasons.length ? `<div style="margin-top:6px;color:#cfe8ff;font-size:12px">‚Ä¢ ${expl.reasons.join('<br>‚Ä¢ ')}</div>` : '';

    html += `
      <div class="coinCard ${cls}">
        <div class="coinRow1">
          <div class="coinSymbol">${r.symbol}</div>
          <div class="coinScore">${r.score}/6</div>
        </div>

        <div style="margin-top:6px">${badge}</div>

        <div class="sigList" style="margin-top:6px">
          Last: ${r.last}<br>
          RSI4H: ${r.rsi4h !== undefined && r.rsi4h !== null ? r.rsi4h.toFixed(1) : 'n/a'} ‚Ä¢ Vol√ó: ${r.volSpike} ‚Ä¢ Wick: ${(r.wickRatio||0).toFixed(2)}<br>
          EMA70‚àÜ: ${r.ema70DistPct}% ‚Ä¢ Funding: ${(r.funding !== undefined ? r.funding : 0).toFixed(6)}
        </div>

        <div style="margin-top:8px;padding-top:8px;border-top:1px dashed rgba(255,255,255,0.03);">
          <div style="color:${expl.color};font-weight:700">${expl.label} ‚Äî ${expl.prob}% chance of near-term reversal</div>
          <div style="color:#cfe8ff;font-size:13px;margin-top:6px">${expl.explanation}</div>
          ${reasonHtml}
        </div>
      </div>
    `;
  });

  el.cardView.innerHTML = `<div class="card-panel">${html}</div>`;

  setTimeout(()=> {
    const nodes = document.querySelectorAll('.coinCard.blink');
    nodes.forEach(n => n.classList.remove('blink'));
  }, 4000);
}

/* ---------------------------------------------------------
   Combined render entrypoint (hybrid)
--------------------------------------------------------- */
function renderResults(results){
  // sort by user control first (new)
  applySort(results);

  // secondary stable sort: score desc, then vol, then ema dist when same primary key
  results.sort((a,b)=>{
    // first compare by primary sort field stable order already applied; keep stable tie-breakers
    // We'll perform a tie-breaker using score (desc) then volSpike then ema70DistPct
    const s = (b.score - a.score) || (b.volSpike - a.volSpike) || (b.ema70DistPct - a.ema70DistPct);
    return s;
  });

  // update prevBlow set
  prevBlow = new Set(results.filter(r=>r.score >= (parseInt(el.threshold.value,10) || 4)).map(r=>r.symbol));

  // choose view
  if(window.innerWidth >= 680){
    renderTable(results);
  } else {
    renderCards(results);
  }
}

/* ============================================================
   ALERTS (sound + notification)
   ============================================================ */
function playAlertSound(){
  try{
    const audio = new Audio("https://actions.google.com/sounds/v1/alarms/beep_short.ogg");
    audio.volume = 0.8;
    audio.play().catch(()=>{});
  }catch(e){}
}
function notify(title, body){
  if(Notification.permission === "granted") new Notification(title, { body });
  else if(Notification.permission !== "denied") Notification.requestPermission();
}
function alertIfNeeded(results){
  const flagged = results.filter(r => r.score >= (parseInt(el.threshold.value,10) || 4));
  if(flagged.length > 0){
    playAlertSound();
    notify("üî• Blowoff Top Detected", flagged.map(f=>f.symbol).slice(0,4).join(", "));
  }
}

/* ============================================================
   MAIN SCAN CYCLE
   ============================================================ */
async function runScan(once=false){
  try{
    running = true;
    el.startBtn.disabled = true;
    el.stopBtn.disabled = false;
    el.debug.innerText = "";
    el.message.innerText = "Fetching top symbols...";
    resetWindow();

    const N = Math.max(5, Math.min(100, parseInt(el.prefilter.value,10) || 30));
    const delayMs = Math.max(50, Math.min(2000, parseInt(el.delay.value,10) || 450));
    const intervalSec = Math.max(10, Math.min(3600, parseInt(el.interval.value,10) || 60));

    const top = await getTopN(N);

    // Prepare queue
    queue = [];
    totalTasks = top.length;
    doneTasks = 0;
    updateProgress();

    const results = [];
    top.forEach(x => queueSymbol(x.symbol, results));

    // countdown for next run
    if(!once) startCountdown(intervalSec);

    // start processing
    await processQueue();

    // when queue done, attach 24h change info from `top` into results (if available)
    results.forEach(r => {
      const found = top.find(t => t.symbol === r.symbol);
      if(found) r.change24 = found.change24;
    });

    // render results and alerts
    renderResults(results);
    alertIfNeeded(results);

    // schedule next run (use setTimeout to avoid running-flag race)
    if (!once) {
      // if safety triggered (high request usage) don't schedule ‚Äî auto-pause handled separately
      if (requestsThisWindow > SAFETY_MAX) {
        el.debug.innerText += `\nNot scheduling next run: safety auto-paused (req/min ${requestsThisWindow})`;
        // do not schedule; auto-pause handler will resume later
      } else {
        // clear previous timer if any, then schedule the next run with setTimeout
        if (autoTimer) { clearTimeout(autoTimer); autoTimer = null; }
        autoTimer = setTimeout(()=> {
          // only call runScan if not currently auto-paused
          if (requestsThisWindow <= SAFETY_MAX) runScan(false);
        }, intervalSec * 1000);
        // update countdown immediately
        startCountdown(intervalSec);
      }
    }

  } catch(e){
    el.debug.innerText += `\nScan error: ${e.message}`;
  }
}

/* ============================================================
   UI Bindings
   ============================================================ */
el.startBtn.addEventListener("click", ()=> {
  if(running) return;
  prevBlow = new Set(); // reset highlights
  runScan(false);
});
el.stopBtn.addEventListener("click", ()=>{
  running = false;
  queue = [];
  el.startBtn.disabled = false;
  el.stopBtn.disabled = true;
  if(autoTimer){ clearInterval(autoTimer); autoTimer = null; }
});
el.oneShot.addEventListener("click", ()=> {
  if(running) return;
  runScan(true);
});

// Sorting controls: re-render on change
el.sortField.addEventListener('change', ()=>{ if(window.lastResults) renderResults(window.lastResults); });
el.sortOrder.addEventListener('change', ()=>{ if(window.lastResults) renderResults(window.lastResults); });

// Request Notification permission at load
if("Notification" in window){
  try { Notification.requestPermission(); } catch(e){}
}

// initial debug ping to confirm CORS reachability
(async function ping(){
  try { await fetch(API_BASE + "/fapi/v1/ping"); } catch(e){ console.warn('ping failed', e); }
})();

/* ============================================================
   END OF ENGINE
   ============================================================ */
</script><footer class="small" style="margin-top:20px;color:var(--muted)">
  Blowoff Top Detector ‚Äî Hybrid AI Mode ‚Ä¢  
  Alerts, Explanations, Auto-Pause, Mobile/Desktop UI  
  <br>Run from a local server (e.g., <code>python -m http.server</code>) to avoid CORS issues.
</footer></body>
</html>
