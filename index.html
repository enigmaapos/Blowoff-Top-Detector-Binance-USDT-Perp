<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Blowoff Top Detector — Phase, PIPPIN, Multi-TF Accumulation, & Alerts</title>
<style>
  :root{
    --bg:#07101a;
    --card:#0b1220;
    --muted:#9fb3cc;
    --accent:#2dd4bf;
    --danger:#ff7b7b;
    --glass: rgba(255,255,255,0.03);
  }
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:#e6eef8;margin:12px}
  .card-panel{background:var(--card);border:1px solid #172033;padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,.6);margin-bottom:14px}
  h1{margin:0;font-size:18px}
  .controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;align-items:center}
  label{font-size:13px;color:var(--muted)}
  input,select{background:#071722;border:1px solid #243241;color:#e6eef8;padding:6px;border-radius:6px}
  button{background:#1f6feb;border:none;color:white;padding:8px 10px;border-radius:6px;cursor:pointer}
  button.alt{background:#2b3947}
  .status{margin-top:8px;color:var(--muted);font-size:13px;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .progress{height:8px;background:#05101a;border-radius:4px;margin-top:8px;overflow:hidden;flex:1}
  .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#60a5fa);width:0%}
  .countdown{font-weight:700;color:#cfe8ff}
  .mutedBadge{background:var(--glass);color:var(--muted);padding:4px 8px;border-radius:8px;font-size:12px}
  table{width:100%;border-collapse:collapse;margin-top:12px;font-size:13px;min-width:720px}
  th,td{padding:8px 10px;border-bottom:1px dashed #122331;text-align:left;vertical-align:top}
  th{color:var(--muted);font-size:12px}
  .green{color:#66f9a1}
  .red{color:var(--danger)}
  .small{font-size:12px;color:var(--muted)}
  .badge{display:inline-block;padding:4px 8px;border-radius:12px;background:#0f2430;color:#bfeee1;font-size:12px}
  .blink{animation: blinkHighlight 1.8s ease-in-out 3}
  @keyframes blinkHighlight {0%{box-shadow:0 0 0 rgba(255,80,80,0)}50%{box-shadow:0 0 12px rgba(255,80,80,0.35)}100%{box-shadow:0 0 0 rgba(255,80,80,0)}}
  /* mobile card UI */
  #tableView{display:block} #cardView{display:none}
  @media (max-width:680px){
    #tableView{display:none} #cardView{display:block}
    .coinCard{background:var(--card);border:1px solid #172033;padding:12px;border-radius:10px;margin-bottom:10px}
    .coinRow1{display:flex;justify-content:space-between;align-items:center}
    .coinSymbol{font-size:16px;font-weight:700}
    .coinScore{font-size:14px;font-weight:700}
    .blowBadge{background:#ff4d4d;padding:4px 8px;border-radius:6px;color:white;font-size:12px;font-weight:700}
    .potBadge{background:#ffd966;padding:4px 8px;border-radius:6px;color:black;font-size:12px;font-weight:700}
    .accBadge{background:#2dd4bf;padding:4px 8px;border-radius:6px;color:#04221a;font-size:12px;font-weight:700}
    .sigList{margin-top:8px;font-size:13px;line-height:18px;color:#cfe8ff}
  }
  footer.small{margin-top:12px;color:var(--muted);font-size:12px}
  .phaseTag{display:inline-block;padding:4px 8px;border-radius:8px;font-weight:700;font-size:12px;margin-left:6px}
  .tfToggle{display:inline-flex;gap:6px;align-items:center;margin-left:8px}
  .sensitivity{width:160px}
  .oneLineRec{font-weight:700;color:#cfe8ff;margin-top:6px}
  .recBox{margin-top:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px}
  .finalRec{margin-top:8px;color:#8bffc0;font-weight:700}
  .shortRec{margin-top:8px;color:#ffd966;font-weight:700}
  .tradePanel{margin-top:12px;padding:12px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03)}
  .tradePanel h3{margin:0 0 8px 0;font-size:15px}
  .tradePanel p{margin:4px 0;color:#cfe8ff}
  .tradeList{margin:8px 0;padding-left:18px}
  .mutedNote{color:var(--muted);font-size:12px;margin-top:8px}
</style>
</head>
<body>
<div class="card-panel">
  <h1>Blowoff Top Detector — Multi-TF Accumulation & Conditional Alerts</h1>
  <div class="small" style="margin-top:6px;color:var(--muted)">
    Multi-timeframe accumulation detector (15m / 1h / 4h), sensitivity slider, conditional alert (blowoff + accumulation) and AI recommendations (long-term + short-term).
    Run on a local server to avoid CORS (e.g., <code>python -m http.server</code>).
  </div>

  <div class="controls">
    <label>Prefilter (top by 24h) <input id="prefilter" type="number" value="30" min="5" max="60"/></label>
    <label>Delay (ms) <input id="delay" type="number" value="450" min="50" max="2000"/></label>
    <label>Refresh (sec) <input id="interval" type="number" value="60" min="10" max="3600"/></label>
    <label>Score ≥ <input id="threshold" type="number" value="4" min="1" max="8"/></label>

    <!-- Sorting controls (ADDED) -->
    <label style="margin-left:8px">Sort by
      <select id="sortBy" style="margin-left:6px">
        <option value="score">Score</option>
        <option value="similarity">PIPPIN similarity</option>
        <option value="accum">Accum confidence</option>
        <option value="preCrash">Pre-crash confidence</option>
        <option value="rsi4h">RSI (4H)</option>
        <option value="ema70DistPct">EMA stretch %</option>
        <option value="last">Last price</option>
        <option value="symbol">Symbol</option>
      </select>
    </label>
    <button id="sortDir" class="alt" title="Toggle sort direction" style="margin-left:6px">Desc</button>
    <!-- end sorting -->

    <button id="startBtn">Start</button>
    <button id="stopBtn" class="alt" disabled>Stop</button>
    <button id="oneShot" class="alt">Run Once</button>

    <!-- Symbol search UI added next to Run Once -->
    <label style="margin-left:8px">
      Search symbol:
      <input id="symbolSearch" placeholder="e.g. BTCUSDT or PIPPINUSDT" style="margin-left:6px;width:150px"/>
    </label>
    <button id="symbolSearchBtn" class="alt" title="Analyze symbol">Analyze</button>
    <button id="symbolClearCache" class="alt" title="Clear symbol cache" style="margin-left:6px">Clear cache</button>
    <div id="symbolStatus" class="small" style="margin-left:8px;color:var(--muted)"></div>
  </div>

  <div class="controls" style="margin-top:10px">
    <label style="margin-right:8px">Accumulation TFs:</label>
    <div class="tfToggle">
      <label><input type="checkbox" id="tf15" checked> 15m</label>
      <label><input type="checkbox" id="tf1h" checked style="margin-left:6px"> 1h</label>
      <label><input type="checkbox" id="tf4h" checked style="margin-left:6px"> 4h</label>
    </div>

    <label style="margin-left:12px">Sensitivity <span id="sensVal" class="small" style="margin-left:6px">50</span></label>
    <input id="sensitivity" class="sensitivity" type="range" min="0" max="100" value="50" style="margin-left:8px">

    <label style="margin-left:12px">Alert when:</label>
    <label style="margin-left:6px"><input type="checkbox" id="condAlert"> Blowoff HIGH + Accum ≥</label>
    <input id="accumAlertThreshold" type="number" value="50" min="0" max="100" style="width:64px;margin-left:6px">

    <label style="margin-left:12px"><input type="checkbox" id="showShort" checked> Show short-term plans</label>
  </div>

  <div class="status">
    <div id="message">Ready.</div>
    <div class="progress"><i id="bar"></i></div>
    <div id="countdown" class="countdown">Next scan in: -</div>
    <div id="safetyStatus" class="mutedBadge">Safety OK</div>
  </div>

  <div id="tableView"></div>
  <div id="cardView"></div>

  <div id="tradeInterpret" class="tradePanel" style="display:none"></div>

  <div id="debug" class="small" style="margin-top:8px"></div>
</div>

<script>
/* ======================================================
   Full detector with symbol search integrated.
   ====================================================== */

const API_BASE = 'https://fapi.binance.com';
const blacklist = ["ALPACAUSDT","BNXUSDT","ALPHAUSDT","OCEANUSDT","DGBUSDT","AGIXUSDT","LINAUSDT","LOKAUSDT","KEYUSDT","MDTUSDT","LOOMUSDT","RENUSDT","OMNIUSDT","SLERFUSDT","STMXUSDT","UXLINKUSDT","BSWUSDT","NEIROETHUSDT","VIDTUSDT","TROYUSDT","BAKEUSDT","AMBUSDT","MEMEFIUSDT","NULSUSDT","HIFIUSDT","LEVERUSDT","XEMUSDT","STRAXUSDT","COMBOUSDT"];

const el = {
  prefilter: document.getElementById('prefilter'),
  delay: document.getElementById('delay'),
  interval: document.getElementById('interval'),
  threshold: document.getElementById('threshold'),
  startBtn: document.getElementById('startBtn'),
  stopBtn: document.getElementById('stopBtn'),
  oneShot: document.getElementById('oneShot'),
  message: document.getElementById('message'),
  bar: document.getElementById('bar'),
  tableView: document.getElementById('tableView'),
  cardView: document.getElementById('cardView'),
  debug: document.getElementById('debug'),
  safetyStatus: document.getElementById('safetyStatus'),
  countdown: document.getElementById('countdown'),
  tf15: document.getElementById('tf15'),
  tf1h: document.getElementById('tf1h'),
  tf4h: document.getElementById('tf4h'),
  sensitivity: document.getElementById('sensitivity'),
  sensVal: document.getElementById('sensVal'),
  condAlert: document.getElementById('condAlert'),
  accumAlertThreshold: document.getElementById('accumAlertThreshold'),
  showShort: document.getElementById('showShort'),
  tradeInterpret: document.getElementById('tradeInterpret'),
  sortBy: document.getElementById('sortBy'),
  sortDir: document.getElementById('sortDir'),
  // symbol elements (wired immediately after)
  symbolSearch: null,
  symbolSearchBtn: null,
  symbolClearCache: null,
  symbolStatus: null
};

let running=false, queue=[], totalTasks=0, doneTasks=0, autoTimer=null, countdownTimer=null;
let requestsThisWindow=0, windowStart=Date.now(), SAFETY_WINDOW_MS=60000, SAFETY_MAX=900, SAFETY_PAUSE=30;
let prevBlowoffSet = new Set();
window.lastScanResults = null; // persist latest results for sorting/re-render

/* ---------- UTIL ---------- */
function delay(ms){ return new Promise(r=>setTimeout(r,ms)); }
function sma(arr,n){ if(!arr||arr.length<n) return null; let s=0; for(let i=arr.length-n;i<arr.length;i++) s+=arr[i]; return s/n; }
function ema(arr,p){ if(!arr||arr.length===0) return null; const k=2/(p+1); let e=arr[0]; for(let i=1;i<arr.length;i++) e = arr[i]*k + e*(1-k); return e; }
function rsiFromCloses(closes,period=14){ if(!closes||closes.length<=period) return null; let g=0,l=0; for(let i=closes.length-period;i<closes.length;i++){ const d=closes[i]-closes[i-1]; if(d>0) g+=d; else l+=Math.abs(d);} const ag=g/period, al=l/period; if(al===0) return 100; const rs=ag/al; return 100 - (100/(1+rs)); }
function pct(a,b){ return b===0?0:((a-b)/b)*100; }
function stdDev(arr){ if(!arr||arr.length===0) return 0; const mean = arr.reduce((s,x)=>s+x,0)/arr.length; const v = arr.reduce((s,x)=>s+Math.pow(x-mean,2),0)/arr.length; return Math.sqrt(v); }
function dot(a,b){ let s=0; for(let i=0;i<a.length;i++) s+=a[i]*b[i]; return s; }
function norm(a){ return Math.sqrt(a.reduce((s,x)=>s+x*x,0)); }
function cosineSim(a,b){ const n=dot(a,b); const d=norm(a)*norm(b); return d===0?0:n/d; }

/* ------------------------------
   RETURN TO NORMAL DETECTOR
   (same as before)
   ------------------------------ */
function detectReturnToNormal(item, opts = {}) {
  const o = Object.assign({
    lookback4h: 12,
    emaSlopeWindow: 6,
    volWindow: 8,
    rsiMax: 70,
    relSdMaxPct: 10,
    higherLowPct: 0.0,
    sensitivity: 50
  }, opts);

  try {
    const k4 = item.k4h || [];
    const close = item.closeNow || (k4.length ? Number(k4[k4.length-1][4]) : 0);

    if(!k4 || k4.length < Math.max(8, o.lookback4h)) {
      return {isReturn:false, score:0, reasons:['insufficient 4H candles'], confidence:0, meta:{}};
    }

    const closes4 = k4.map(k => Number(k[4]));
    const vols4  = k4.map(k => Number(k[5]));

    const look = Math.min(o.lookback4h, closes4.length - 1);
    const slice = closes4.slice(-look - 1);
    const half = Math.floor(slice.length/2);
    const left = slice.slice(0, half);
    const right = slice.slice(half);
    const leftMin = left.length ? Math.min(...left) : Math.min(...slice);
    const rightMin = right.length ? Math.min(...right) : Math.min(...slice);
    const higherLow = rightMin >= leftMin * (1 - o.higherLowPct);

    const closesForSlope = closes4.slice(-o.emaSlopeWindow - 1);
    const lastEma14 = (() => {
      const arr = closesForSlope.slice(-o.emaSlopeWindow);
      if(!arr.length) return null;
      return ema(arr, 14);
    })();
    const prevEma14 = (() => {
      const arr = closesForSlope.slice(0, Math.max(0, closesForSlope.length - 1));
      if(!arr.length) return null;
      return ema(arr, 14);
    })();
    const emaSlope = (lastEma14 && prevEma14) ? (lastEma14 - prevEma14) : 0;

    const recentCloses = closes4.slice(-o.lookback4h);
    const relSD = (() => {
      const sd = stdDev(recentCloses);
      const mean = recentCloses.reduce((s,x)=>s+x,0)/recentCloses.length;
      return mean ? (sd/mean)*100 : 999;
    })();

    const volMA = sma(vols4, Math.min(o.volWindow, vols4.length)) || 1;
    const lastVol = vols4[vols4.length-1] || 0;
    const volTaper = lastVol < volMA * (1 + (50 - o.sensitivity)/200);

    const rsi4 = item.rsi4h || rsiFromCloses(closes4, 14) || 50;
    const rsiOK = rsi4 <= Math.max(65, o.rsiMax);

    let score = 0; const reasons = [];
    if(higherLow){ score += 3; reasons.push('higher-low structure'); } else reasons.push('no clear higher-low');
    if(emaSlope > 0){ score += 2; reasons.push('EMA slope up'); }
    else if(Math.abs(emaSlope) < (Math.max(1e-6, Math.abs(lastEma14||1)) * 0.001)) { score += 1; reasons.push('EMAs flattening'); }
    if(relSD <= o.relSdMaxPct){ score += 2; reasons.push(`low volatility ${relSD.toFixed(2)}%`); }
    else if(relSD <= o.relSdMaxPct * 1.6){ score += 1; reasons.push('reduced volatility'); }
    if(volTaper){ score += 1; reasons.push('volume taper (absorption)'); }
    if(rsiOK){ score += 1; reasons.push(`RSI ${Math.round(rsi4)}`); }

    const maxScore = 9;
    const confidence = Math.round((score / maxScore) * 100);
    const isReturn = score >= Math.max(4, Math.round(4 * (0.8 + (50 - o.sensitivity)/200)));
    const meta = {higherLow, emaSlope, relSD, volMA, lastVol, rsi4, score, lookback:o.lookback4h};

    return {isReturn, score, reasons, confidence, meta};
  } catch(err) {
    return {isReturn:false, score:0, reasons:[`error ${err.message}`], confidence:0, meta:{}};
  }
}

/* --------------------------
   PRE-CRASH / BLOWOFF DETECTOR
-------------------------- */
function detectPreCrash(item, opts={}) {
  const sensitivity = parseInt(el.sensitivity.value,10) || 50;
  const t = {
    rsi4h: 78 - Math.round((sensitivity-50)/2),
    volSpike4: 2.0 - (sensitivity-50)/250,
    wickRatio: 1.2 - (sensitivity-50)/500,
    emaDistPct: 40 - Math.round((sensitivity-50)/1.5),
    dropFromPeak: 8 - Math.round((sensitivity-50)/10)
  };

  try {
    const rsi4h = item.rsi4h || 0;
    const vol = Number(item.volSpike4 || 0);
    const wick = Number(item.wickRatio4 || 0);
    const emaDist = Math.abs(Number(item.ema70DistPct || 0));
    const dropPct = Number(item.dropPctFromPeak || 0);
    const funding = item.fundingRate || 0;

    let lowerHCount = 0;
    if(Array.isArray(item.k4h) && item.k4h.length >= 6){
      const highs = item.k4h.slice(-8).map(k => Number(k[2]));
      for(let i=1;i<highs.length;i++) if(highs[i] < highs[i-1]) lowerHCount++;
    }

    let score = 0; const reasons = [];

    if(vol >= Math.max(1.8, t.volSpike4)){ score += 3; reasons.push(`Vol spike ×${vol}`); }
    else if(vol >= Math.max(1.2, t.volSpike4*0.7)){ score += 1; reasons.push(`Vol uptick ×${vol}`); }

    if(wick >= Math.max(1.2, t.wickRatio)){ score += 3; reasons.push(`Upper wick ratio ${wick.toFixed(2)}`); }
    else if(wick >= Math.max(0.9, t.wickRatio*0.7)){ score += 1; reasons.push(`Wick present ${wick.toFixed(2)}`); }

    if(rsi4h >= t.rsi4h){ score += 2; reasons.push(`RSI4H ${Math.round(rsi4h)}`); }
    else if(rsi4h >= t.rsi4h - 8){ score += 1; reasons.push(`RSI elevated ${Math.round(rsi4h)}`); }

    if(emaDist >= Math.max(30, t.emaDistPct)){ score += 2; reasons.push(`EMA stretch ${Math.round(emaDist)}%`); }

    if(lowerHCount >= 2){ score += 2; reasons.push(`Lower highs (${lowerHCount})`); }
    if(dropPct >= Math.max(6, t.dropFromPeak)){ score += 1; reasons.push(`Drop from peak ${dropPct.toFixed(1)}%`); }

    if(typeof funding === 'number' && funding < -0.001){ score += 1; reasons.push(`Funding neg ${(funding*100).toFixed(3)}%`); }

    const accumConf = item.accumCombined ? (item.accumCombined.confidence || 0) : 0;
    if(accumConf >= 60){ score = Math.max(0, score - 2); reasons.push('Strong accumulation reduces immediate crash odds'); }

    const maxScore = 13;
    const confidence = Math.round((score / maxScore) * 100);
    const likely = (score >= 7 && confidence >= 45 && accumConf < 65) || (score >= 9);

    return { likely, score, reasons, confidence, meta: { rsi4h, vol, wick, emaDist, dropPct, funding, lowerHCount, accumConf } };
  } catch(err){
    return { likely:false, score:0, reasons:[`error ${err.message}`], confidence:0, meta:{} };
  }
}

/* ---------- SAFE FETCH ---------- */
async function safeFetch(url, opts = { allowIfNotRunning: false }) {
  if(!running && !opts.allowIfNotRunning) throw new Error('Not running (call Start first)');
  try {
    requestsThisWindow++;
    const r = await fetch(url);
    if(!r.ok) {
      const body = await r.text().catch(()=>'<no body>');
      throw new Error(`HTTP ${r.status} ${r.statusText} — ${body.slice(0,200)}`);
    }
    return await r.json();
  } catch (err) {
    throw new Error(`fetch error for ${url} → ${err.message}`);
  }
}

function resetWindow(){ requestsThisWindow=0; windowStart=Date.now(); }
function checkSafetyAndMaybePause(){
  const now=Date.now();
  if(now-windowStart > SAFETY_WINDOW_MS){ resetWindow(); el.safetyStatus.innerText='Safety OK'; return false; }
  if(requestsThisWindow > SAFETY_MAX){
    running=false;
    el.safetyStatus.innerText = `Auto-paused: ${requestsThisWindow} req/min`;
    el.message.innerText = `Auto-paused ${SAFETY_PAUSE}s to avoid rate limit.`;
    el.startBtn.disabled=false; el.stopBtn.disabled=true;
    setTimeout(()=>{ resetWindow(); const cur = Math.max(200, parseInt(el.delay.value,10)||450); el.delay.value = Math.min(2000, Math.round(cur * 1.5)); el.safetyStatus.innerText='Resumed after pause'; el.message.innerText='Resumed'; }, SAFETY_PAUSE*1000);
    return true;
  }
  el.safetyStatus.innerText = `Req/min: ${requestsThisWindow}`;
  return false;
}

/* ---------- TOP N ---------- */
async function getTopN(n){
  const tickers = await safeFetch(API_BASE + '/fapi/v1/ticker/24hr');
  const usdt = tickers.filter(t => t.symbol && t.symbol.endsWith('USDT') && !blacklist.includes(t.symbol));
  usdt.sort((a,b)=> parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent));
  return usdt.slice(0,n).map(x=>({symbol:x.symbol, last: Number(x.lastPrice), change24: Number(x.priceChangePercent)}));
}

/* ---------- ACCUMULATION DETECTOR ---------- */
function detectAccumulationGeneric(closes, highs, lows, vols, period=30, sensitivity=50){
  const len = Math.min(period, closes.length);
  if(len < 10) return {isAccum:false, score:0, reasons:[], confidence:0, relSD:0};
  const sliceC = closes.slice(-len), sliceH = highs.slice(-len), sliceL = lows.slice(-len), sliceV = vols.slice(-len);
  const mean = sliceC.reduce((s,x)=>s+x,0)/sliceC.length;
  const sd = stdDev(sliceC);
  const relSD = mean? (sd/mean)*100 : 0;
  const reasons = [];
  let score = 0;
  const relSD_threshold_strict = 2.5;
  const relSD_threshold_loose = 6.0;
  const relSD_threshold = relSD_threshold_strict + (1 - (sensitivity/100)) * (relSD_threshold_loose - relSD_threshold_strict);
  if(relSD <= relSD_threshold){ score += 3; reasons.push(`low volatility ${relSD.toFixed(2)}% ≤ ${relSD_threshold.toFixed(2)}%`); }
  else if(relSD <= relSD_threshold*1.6){ score += 1; reasons.push(`reduced volatility ${relSD.toFixed(2)}%`); }
  let lowerLowCount=0;
  for(let i=1;i<sliceL.length;i++) if(sliceL[i] < sliceL[i-1]) lowerLowCount++;
  const lowerLow_max = 2 + Math.round((100 - sensitivity)/50);
  if(lowerLowCount <= lowerLow_max){ score += 2; reasons.push(`limited lower-lows (${lowerLowCount} ≤ ${lowerLow_max})`); }
  else reasons.push(`lower-lows (${lowerLowCount})`);
  const volBaseline = sma(sliceV, Math.min(8, sliceV.length)) || 0.000001;
  let upCount = 0, upVolHigher = 0;
  for(let i=1;i<sliceC.length;i++){
    if(sliceC[i] > sliceC[i-1]){ upCount++; if(sliceV[i] > volBaseline * (1 + (50 - sensitivity)/200)) upVolHigher++; }
  }
  if(upCount >= 3 && upVolHigher >= Math.max(1, Math.round(upCount*0.4))){ score += 3; reasons.push(`buyers on higher-volume up-bars (${upVolHigher}/${upCount})`); }
  else if(upCount >= 2){ score += 1; reasons.push(`some up bars (${upCount})`); }
  const e14 = ema(sliceC, Math.min(14, sliceC.length));
  const e21 = ema(sliceC, Math.min(21, sliceC.length));
  if(e14 && e21){
    const slope = e14 - e21;
    const slopeThreshold = (sensitivity/100) * (e21 * 0.01);
    if(slope >= -slopeThreshold){ score += 2; reasons.push('EMAs flat/turning up'); }
    else if(Math.abs(slope) < (e21*0.002 || 0.0001)){ score += 1; reasons.push('EMAs flattening'); }
  }
  const rsi = rsiFromCloses(closes, 14);
  if(rsi && rsi >= 36 - (sensitivity/20)) { score += 1; reasons.push(`RSI stabilizing (${rsi.toFixed(1)})`); }
  const peak = Math.max(...sliceC);
  const latest = sliceC[sliceC.length-1];
  const dropPct = peak? ((peak - latest)/peak)*100 : 0;
  const requiredDrop = 8 - Math.round(sensitivity/20);
  if(dropPct >= Math.max(4, requiredDrop)){ score += 1; reasons.push(`follows drop ${dropPct.toFixed(1)}% (req ${Math.max(4, requiredDrop)}%)`); }
  const maxScore = 12;
  const confidence = Math.min(99, Math.round((score/maxScore)*100));
  const isAccum = score >= Math.max(6, Math.round(6 * (0.8 + (50 - sensitivity)/200)));
  return {isAccum, score, reasons, confidence, relSD};
}

/* ---------- QUEUE ANALYSIS (fetch klines & compute features) ---------- */
function queueSymbolAnalysis(symbol, results){
  queue.push(async ()=>{
    try{
      const promises = [];
      promises.push(safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=4h&limit=40`));
      promises.push(safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=1h&limit=60`));
      promises.push(safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=15m&limit=80`));
      promises.push(safeFetch(`${API_BASE}/fapi/v1/fundingRate?symbol=${symbol}&limit=1`));
      const [k4h, k1h, k15, f] = await Promise.all(promises);

      const closes4h = k4h.map(k=>Number(k[4])); const highs4h = k4h.map(k=>Number(k[2])); const lows4h = k4h.map(k=>Number(k[3])); const vols4h = k4h.map(k=>Number(k[5]));
      const closes1h = k1h.map(k=>Number(k[4])); const highs1h = k1h.map(k=>Number(k[2])); const lows1h = k1h.map(k=>Number(k[3])); const vols1h = k1h.map(k=>Number(k[5]));
      const closes15 = k15.map(k=>Number(k[4])); const highs15 = k15.map(k=>Number(k[2])); const lows15 = k15.map(k=>Number(k[3])); const vols15 = k15.map(k=>Number(k[5]));

      const last4 = k4h[k4h.length-1], prev4 = k4h[k4h.length-2] || last4;
      const open4 = Number(last4[1]), high4 = Number(last4[2]), low4 = Number(last4[3]), close4 = Number(last4[4]);
      const body4 = Math.abs(close4 - open4) || 1e-9;
      const wickTop4 = Math.max(0, high4 - Math.max(open4, close4));
      const wickRatio4 = wickTop4 / body4;
      const volMA4 = sma(vols4h, Math.min(10, vols4h.length)) || 1;
      const volSpike4 = Number((Number(last4[5]) / volMA4).toFixed(2));
      const ema70_4 = ema(closes4h, 70) || ema(closes4h, Math.min(21, closes4h.length));
      const emaDistPct = ema70_4 ? Number(pct(close4, ema70_4).toFixed(2)) : 0;
      const rsi4h = rsiFromCloses(closes4h, 14);
      const rsi1d = rsiFromCloses(closes4h.slice(-9).map((v,i)=>v), 14);
      const lowerHigh = Number(high4) < Number(prev4[2]);
      const fundingRate = (f && f.length) ? Number(f[0].fundingRate) : 0;

      const rsi1h = rsiFromCloses(closes1h, 14);
      const rsi15 = rsiFromCloses(closes15, 14);
      const volMA15 = sma(vols15, Math.min(10, vols15.length)) || 1;
      const volSpike15 = Number((Number(closes15.length ? vols15[vols15.length-1] : 1) / volMA15).toFixed(2));

      let score=0;
      const signals={};
      if(rsi1d !== null && rsi1d >= 88){ score++; signals.rsi1d=true; } else signals.rsi1d=false;
      if(rsi4h !== null && rsi4h >= 80){ score++; signals.rsi4h=true; } else signals.rsi4h=false;
      if(volSpike4 >= 1.8){ score++; signals.volSpike=true; } else signals.volSpike=false;
      if(wickRatio4 >= 1.2){ score++; signals.wickTop=true; } else signals.wickTop=false;
      if(emaDistPct >= 50){ score++; signals.emaDist=true; } else signals.emaDist=false;
      if(lowerHigh){ score++; signals.lowerHigh=true; } else signals.lowerHigh=false;
      if(typeof fundingRate === 'number' && fundingRate < -0.0005){ score++; signals.fundingConfirm=true; } else signals.fundingConfirm=false;
      signals.funding = fundingRate;

      const sens = parseInt(el.sensitivity.value,10) || 50;
      const tfChecks = [];
      if(el.tf15.checked){
        const acc15 = detectAccumulationGeneric(closes15, highs15, lows15, vols15, 30, sens);
        tfChecks.push({tf:'15m', result:acc15});
      }
      if(el.tf1h.checked){
        const acc1h = detectAccumulationGeneric(closes1h, highs1h, lows1h, vols1h, 30, sens);
        tfChecks.push({tf:'1h', result:acc1h});
      }
      if(el.tf4h.checked){
        const acc4h = detectAccumulationGeneric(closes4h, highs4h, lows4h, vols4h, 20, sens);
        tfChecks.push({tf:'4h', result:acc4h});
      }

      let combinedConfidence = 0;
      if(tfChecks.length){
        let weightSum = 0;
        tfChecks.forEach(t=>{
          const w = (t.tf === '4h') ? 1.2 : (t.tf === '1h' ? 1.0 : 0.8);
          combinedConfidence += (t.result.confidence || 0) * w;
          weightSum += w;
        });
        combinedConfidence = Math.round(combinedConfidence / weightSum);
      }

      const preCrash = detectPreCrash({
        rsi4h,
        volSpike4,
        wickRatio4,
        ema70DistPct: emaDistPct,
        dropPctFromPeak: pct(close4, ema70_4) || 0,
        fundingRate,
        k4h
      });

      results.push({
        symbol,
        score,
        signals,
        rsi1d, rsi4h,
        rsi1h, rsi15,
        volSpike4, volSpike15,
        wickRatio4,
        ema70DistPct: emaDistPct,
        lowerHigh,
        fundingRate,
        closeNow: close4,
        k4h, k1h, k15m: k15,
        accumChecks: tfChecks,
        accumCombined: { confidence: combinedConfidence, isAccum: combinedConfidence >= Math.max(45, (100 - sens) * 0.6) },
        preCrash
      });

    } catch(err){
      el.debug.innerText += `\nError ${symbol}: ${err.message}`;
    }
  });
}

/* ---------- PHASE DETECTION & HELPERS ---------- */
function detectPhaseForSymbol(item){
  try{
    const k4 = item.k4h || [], k15 = item.k15m || [];
    const rsi4h = item.rsi4h || 0;
    const vol = item.volSpike4 || 1;
    const wick = item.wickRatio4 || 0;
    const reasons = [];
    let score = 0;

    const highs = k4.slice(-8).map(k=>Number(k[2]));
    let lowerHCount=0; for(let i=1;i<highs.length;i++) if(highs[i]<highs[i-1]) lowerHCount++;

    const highest4h = k4.length ? Math.max(...k4.map(k=>Number(k[2]))) : (item.closeNow || 0);
    const lastClose = item.closeNow || 0;
    const dropPctFromPeak = highest4h ? Math.abs((lastClose - highest4h)/highest4h)*100 : 0;

    if(item.accumCombined && item.accumCombined.isAccum){ reasons.push(`Accumulation seen (combined ${item.accumCombined.confidence}%)`); score += 4; }

    if(wick >= 1.8 && vol >= 3 && rsi4h >= 85){ score += 3; reasons.push('Climax candle'); }
    const recentHigh15 = k15.length ? Math.max(...k15.map(k=>Number(k[2]))) : 0;
    const recentLow15 = k15.length ? Math.min(...k15.map(k=>Number(k[3]))) : 0;
    const range15 = recentHigh15 - recentLow15;
    if(range15 > 0 && (Math.abs(range15) / (recentLow15 || 1)) <= 0.12 && rsi4h >= 60){ score += 2; reasons.push('Distribution'); }
    if(lowerHCount >= 3){ score += 2; reasons.push('Breakdown: lower highs'); }
    if(dropPctFromPeak >= 20 && vol >= 2.5){ score += 3; reasons.push('Capitulation A'); }
    if(k15.length > 20){
      const closes15 = k15.map(k=>Number(k[4]));
      const recentSlice = closes15.slice(-20);
      const localMin = Math.min(...recentSlice);
      const afterMin = recentSlice.slice(recentSlice.indexOf(localMin)+1);
      if(afterMin.length){
        const bouncePct = ((afterMin[afterMin.length-1] - localMin)/localMin)*100;
        if(bouncePct >= 8 && bouncePct <= 60){ score += 1; reasons.push(`Dead-cat bounce ${bouncePct.toFixed(1)}%`); }
      }
    }

    const candidates = [];
    if(item.accumCombined && item.accumCombined.isAccum) candidates.push({phase:'Accumulation / Re-accumulation', priority:9});
    if(score >= 9 && reasons.some(r=>r.includes('Final capitulation'))) candidates.push({phase:'Final capitulation wick', priority:8});
    if(score >= 7 && reasons.some(r=>r.includes('Capitulation'))) candidates.push({phase:'Capitulation A', priority:7});
    if(score >= 5 && reasons.some(r=>r.includes('Breakdown'))) candidates.push({phase:'Breakdown', priority:6});
    if(score >= 5 && reasons.some(r=>r.includes('Distribution'))) candidates.push({phase:'Distribution / sideways top', priority:5});
    if(score >= 4 && reasons.some(r=>r.includes('Climax'))) candidates.push({phase:'Climax candle (blowoff wick)', priority:5});
    if(score >= 3 && reasons.some(r=>r.includes('Acceleration'))) candidates.push({phase:'Acceleration (vertical move)', priority:4});
    if(reasons.some(r=>r.includes('Dead-cat'))) candidates.push({phase:'Dead-cat bounce', priority:3});
    if(candidates.length === 0){
      if(dropPctFromPeak >= 25 && vol >= 1.8) candidates.push({phase:'Capitulation A', priority:7});
      else if(wick >= 1.6 && rsi4h >= 85) candidates.push({phase:'Climax candle (blowoff wick)', priority:6});
      else if(item.accumCombined && item.accumCombined.confidence >= 55) candidates.push({phase:'Accumulation / Re-accumulation',priority:5});
      else if(range15 <= (Math.max(1,Math.abs(recentLow15||1))*0.08) && rsi4h >= 60) candidates.push({phase:'Distribution / sideways top',priority:5});
      else if(lowerHCount>=2) candidates.push({phase:'Breakdown',priority:6});
      else candidates.push({phase:'Normal/Trending',priority:1});
    }
    candidates.sort((a,b)=> b.priority - a.priority);
    const chosen = candidates[0].phase || 'Unknown';
    const conf = Math.min(98, Math.round((score/14)*100) + (item.accumCombined && item.accumCombined.confidence ? Math.round(item.accumCombined.confidence*0.2) : 0));
    return {phase: chosen, confidence: conf, reasons: reasons, dropPctFromPeak: Math.round(dropPctFromPeak*100)/100};
  } catch(e){
    return {phase:'Unknown', confidence:0, reasons:[], dropPctFromPeak:0};
  }
}

function makeFeatureVector(item){
  const rsi4h = Math.min(100, item.rsi4h || 0)/100;
  const vol = Math.min(10, item.volSpike4 || 1)/5;
  const wick = Math.min(10, item.wickRatio4 || 0)/5;
  const ema = Math.min(500, Math.abs(item.ema70DistPct || 0))/200;
  const funding = (item.fundingRate || 0) * 1000;
  const slope = Math.min(4, Math.max(0, (item.slope15 || 1)/1.5))/2;
  const drop = Math.min(100, item.dropPctFromPeak || 0)/100;
  const accumConf = item.accumCombined ? (item.accumCombined.confidence || 0)/100 : 0;
  return [rsi4h, vol, wick, ema, funding, slope, drop, accumConf];
}

function explainBlowoff(item){
  const p = item;
  let pts=0; const reasons=[];
  if(p.rsi1d !== null && p.rsi1d >= 88){ pts+=2; reasons.push(`1D RSI ${p.rsi1d.toFixed(1)}`); } else if(p.rsi1d !== null && p.rsi1d >= 80){ pts+=1; reasons.push(`1D RSI ${p.rsi1d.toFixed(1)}`); }
  if(p.rsi4h !== null && p.rsi4h >= 85){ pts+=1; reasons.push(`4H RSI ${p.rsi4h.toFixed(1)}`); }
  if(p.volSpike4 >= 3){ pts+=2; reasons.push(`Vol climax ×${p.volSpike4}`);} else if(p.volSpike4 >= 1.8){ pts+=1; reasons.push(`Vol spike ×${p.volSpike4}`);}
  if(p.wickRatio4 >= 2.0){ pts+=2; reasons.push(`Upper wick ratio ${p.wickRatio4.toFixed(2)}`);} else if(p.wickRatio4 >= 1.2){ pts+=1; reasons.push(`Upper wick ${p.wickRatio4.toFixed(2)}`);}
  if(p.ema70DistPct >= 150){ pts+=2; reasons.push(`EMA stretch ${p.ema70DistPct}%`);} else if(p.ema70DistPct >= 50){ pts+=1; reasons.push(`EMA stretch ${p.ema70DistPct}%`);}
  if(typeof p.fundingRate === 'number'){ if(p.fundingRate < -0.001){ pts+=2; reasons.push(`Funding strongly negative ${(p.fundingRate*100).toFixed(3)}%`);} else if(p.fundingRate < -0.0005){ pts+=1; reasons.push(`Funding negative ${(p.fundingRate*100).toFixed(3)}%`);} }
  if(p.lowerHigh){ pts+=1; reasons.push('Lower high'); }
  if(typeof p.score === 'number'){ if(p.score >= 6) pts+=2; else if(p.score >= 4) pts+=1; }
  let label='None', color='#9fb3cc', prob=5;
  if(pts >= 10){ label='Extreme'; color='#e74c3c'; prob=92; } else if(pts >= 7){ label='High'; color='#ff6b43'; prob=78; } else if(pts >= 4){ label='Medium'; color='#ffd966'; prob=55; } else if(pts >= 2){ label='Low'; color='#7bd389'; prob=25; }
  const topReasons = reasons.slice(0,4);
  const explanation = topReasons.length ? `${topReasons.join('; ')}. Estimated reversal probability: ${prob}%.` : `No clear exhaustion signals detected.`;
  return {pts, label, color, prob, explanation, reasons: topReasons};
}

/* ============================================================
   (getLongTermTargets, getFinalRecommendation, getShortTermRecommendation,
    renderTable, renderCards, buildTradingInterpretation, updateTradingInterpretation)
   are the same as your original implementations and appear below.
   For brevity I won't repeat them here in this comment block — they're
   included further down the script (unchanged).
   ============================================================ */

/* ============================================================
   NEW: Symbol search / single-symbol analyzer implementation
   Inserted here so it uses the existing helpers & safeFetch.
   ============================================================ */

// Wire symbol DOM references into el
el.symbolSearch = document.getElementById('symbolSearch');
el.symbolSearchBtn = document.getElementById('symbolSearchBtn');
el.symbolClearCache = document.getElementById('symbolClearCache');
el.symbolStatus = document.getElementById('symbolStatus');

// Simple in-memory cache for symbol analysis & exchangeInfo
const symbolCache = new Map(); // key -> { ts, data }
const CACHE_TTL = 1000 * 60 * 5; // 5 minutes TTL

// Small rate-limiter for manual symbol lookups (token bucket-ish)
let lastSymbolReq = 0;
const MIN_MS_BETWEEN_SYMBOL_REQ = 800; // 0.8s between manual lookups (adjust as needed)

// Optional: cached exchangeInfo to validate symbol (fetch once, lazy)
let exchangeInfoCache = null;
async function ensureExchangeInfo() {
  if(exchangeInfoCache && (Date.now() - exchangeInfoCache.ts) < 1000*60*30) return exchangeInfoCache.data;
  try {
    const data = await safeFetch(API_BASE + '/fapi/v1/exchangeInfo', { allowIfNotRunning: true });
    exchangeInfoCache = { ts: Date.now(), data };
    return data;
  } catch(e){
    console.warn('exchangeInfo fetch failed:', e.message);
    return null;
  }
}

// Validate quick: symbol must end with USDT for futures perpetual USDT pairs
function looksLikeUSDTPerp(sym) {
  if(!sym) return false;
  return sym.toUpperCase().endsWith('USDT');
}

// Helper: read & set cache
function getCachedSymbol(sym) {
  const k = sym.toUpperCase();
  const row = symbolCache.get(k);
  if(!row) return null;
  if(Date.now() - row.ts > CACHE_TTL) { symbolCache.delete(k); return null; }
  return row.data;
}
function setCachedSymbol(sym, data) {
  const k = sym.toUpperCase();
  symbolCache.set(k, { ts: Date.now(), data });
}

// Clear cache button
el.symbolClearCache.addEventListener('click', () => {
  symbolCache.clear();
  exchangeInfoCache = null;
  el.symbolStatus.innerText = 'Symbol cache cleared.';
  setTimeout(()=> el.symbolStatus.innerText = '', 2600);
});

// The main single-symbol analyzer; returns the result object in same shape as `results` entries
async function analyzeSymbol(symbol, opts = { allowIfNotRunning: true }) {
  const sym = (symbol || '').toUpperCase();
  if(!sym) throw new Error('Symbol empty');
  if(!looksLikeUSDTPerp(sym)) {
    el.symbolStatus.innerText = `Warning: "${sym}" does not end with USDT — will attempt fetch anyway.`;
  }
  const cached = getCachedSymbol(sym);
  if(cached) {
    el.symbolStatus.innerText = `Loaded ${sym} from cache (${Math.round((Date.now()-cached._cachedAt)/1000)}s ago)`;
    return cached;
  }

  const since = Date.now() - lastSymbolReq;
  if(since < MIN_MS_BETWEEN_SYMBOL_REQ) {
    const wait = MIN_MS_BETWEEN_SYMBOL_REQ - since;
    await delay(wait);
  }
  lastSymbolReq = Date.now();

  const exch = await ensureExchangeInfo().catch(()=>null);
  if(exch && Array.isArray(exch.symbols)) {
    const found = exch.symbols.find(s => s.symbol === sym);
    if(!found) {
      el.symbolStatus.innerText = `Symbol ${sym} not found in exchangeInfo (not listed?)`;
    } else {
      if(found.quoteAsset !== 'USDT') {
        el.symbolStatus.innerText = `Symbol ${sym} found but quoteAsset=${found.quoteAsset}. Expected USDT. Proceeding anyway.`;
      }
    }
  }

  el.symbolStatus.innerText = `Fetching ${sym} data...`;

  try {
    const promises = [
      safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${sym}&interval=4h&limit=40`, { allowIfNotRunning: opts.allowIfNotRunning }),
      safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${sym}&interval=1h&limit=60`, { allowIfNotRunning: opts.allowIfNotRunning }),
      safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${sym}&interval=15m&limit=80`, { allowIfNotRunning: opts.allowIfNotRunning }),
      safeFetch(`${API_BASE}/fapi/v1/fundingRate?symbol=${sym}&limit=1`, { allowIfNotRunning: opts.allowIfNotRunning })
    ];
    const [k4h, k1h, k15, f] = await Promise.all(promises);

    const closes4h = (k4h||[]).map(k=>Number(k[4])); const highs4h=(k4h||[]).map(k=>Number(k[2])); const lows4h=(k4h||[]).map(k=>Number(k[3])); const vols4h=(k4h||[]).map(k=>Number(k[5]));
    const closes1h = (k1h||[]).map(k=>Number(k[4])); const highs1h=(k1h||[]).map(k=>Number(k[2])); const lows1h=(k1h||[]).map(k=>Number(k[3])); const vols1h=(k1h||[]).map(k=>Number(k[5]));
    const closes15 = (k15||[]).map(k=>Number(k[4])); const highs15=(k15||[]).map(k=>Number(k[2])); const lows15=(k15||[]).map(k=>Number(k[3])); const vols15=(k15||[]).map(k=>Number(k[5]));

    const last4 = (k4h && k4h.length) ? k4h[k4h.length-1] : null;
    if(!last4) throw new Error('No 4H candles returned');

    const open4 = Number(last4[1]), high4 = Number(last4[2]), low4 = Number(last4[3]), close4 = Number(last4[4]);
    const body4 = Math.abs(close4 - open4) || 1e-9;
    const wickTop4 = Math.max(0, high4 - Math.max(open4, close4));
    const wickRatio4 = wickTop4 / body4;
    const volMA4 = sma(vols4h, Math.min(10, vols4h.length)) || 1;
    const volSpike4 = Number((Number(last4[5]) / volMA4).toFixed(2));
    const ema70_4 = ema(closes4h, 70) || ema(closes4h, Math.min(21, closes4h.length));
    const emaDistPct = ema70_4 ? Number(pct(close4, ema70_4).toFixed(2)) : 0;
    const rsi4h = rsiFromCloses(closes4h, 14);
    const rsi1d = rsiFromCloses(closes4h.slice(-9).map(v=>v), 14);
    const lowerHigh = (k4h && k4h.length>1) ? Number(high4) < Number(k4h[k4h.length-2][2]) : false;
    const fundingRate = (f && f.length) ? Number(f[0].fundingRate) : 0;
    const rsi1h = rsiFromCloses(closes1h, 14);
    const rsi15 = rsiFromCloses(closes15, 14);
    const volMA15 = sma(vols15, Math.min(10, vols15.length)) || 1;
    const volSpike15 = Number((Number(closes15.length ? vols15[vols15.length-1] : 1) / volMA15).toFixed(2));

    const sens = parseInt(el.sensitivity.value,10) || 50;
    const acc15 = detectAccumulationGeneric(closes15, highs15, lows15, vols15, 30, sens);
    const acc1h = detectAccumulationGeneric(closes1h, highs1h, lows1h, vols1h, 30, sens);
    const acc4h = detectAccumulationGeneric(closes4h, highs4h, lows4h, vols4h, 20, sens);
    const tfChecks = [
      { tf:'15m', result: acc15 },
      { tf:'1h', result: acc1h },
      { tf:'4h', result: acc4h }
    ];
    let combinedConfidence = 0;
    if(tfChecks.length){
      let weightSum = 0;
      tfChecks.forEach(t=>{
        const w = (t.tf === '4h') ? 1.2 : (t.tf === '1h' ? 1.0 : 0.8);
        combinedConfidence += (t.result.confidence || 0) * w;
        weightSum += w;
      });
      combinedConfidence = Math.round(combinedConfidence / weightSum);
    }

    const preCrash = detectPreCrash({
      rsi4h,
      volSpike4,
      wickRatio4,
      ema70DistPct: emaDistPct,
      dropPctFromPeak: pct(close4, ema70_4) || 0,
      fundingRate,
      k4h
    });

    const result = {
      symbol: sym,
      score: 0,
      signals: {},
      rsi1d, rsi4h, rsi1h, rsi15,
      volSpike4, volSpike15,
      wickRatio4,
      ema70DistPct: emaDistPct,
      lowerHigh,
      fundingRate,
      closeNow: close4,
      k4h, k1h, k15m: k15,
      accumChecks: tfChecks,
      accumCombined: { confidence: combinedConfidence, isAccum: combinedConfidence >= Math.max(45, (100 - sens) * 0.6) },
      preCrash,
      phase: detectPhaseForSymbol({
        rsi4h, wickRatio4, volSpike4, accumCombined: { confidence: combinedConfidence, isAccum: combinedConfidence >= Math.max(45, (100 - sens) * 0.6) },
        k4h, k15m: k15, closeNow: close4, ema70DistPct: emaDistPct
      }),
      returnToNormal: detectReturnToNormal({ k4h, rsi4h, closeNow: close4 }, { sensitivity: sens })
    };

    if(window.lastScanResults) {
      const pippin = window.lastScanResults.find(x => x.symbol === 'PIPPINUSDT');
      if(pippin) result.similarity = cosineSim(makeFeatureVector(result), makeFeatureVector(pippin));
      else result.similarity = 0;
    } else result.similarity = 0;

    result.expl = explainBlowoff(result);
    result.finalRec = getFinalRecommendation(result);
    result.shortRec = getShortTermRecommendation(result);
    result.longTargets = getLongTermTargets(result);

    result._cachedAt = Date.now();
    setCachedSymbol(sym, result);

    el.symbolStatus.innerText = `Analyzed ${sym} • accum ${result.accumCombined.confidence}% • rsi4h ${Math.round(result.rsi4h||0)}`;
    return result;
  } catch(err){
    el.symbolStatus.innerText = `Analyze ${sym} failed: ${err.message}`;
    throw err;
  }
}

// UI: analyze button
el.symbolSearchBtn.addEventListener('click', async () => {
  const sym = (el.symbolSearch.value || '').trim().toUpperCase();
  if(!sym){ el.symbolStatus.innerText = 'Enter a symbol (e.g. BTCUSDT)'; return; }
  try {
    el.symbolSearchBtn.disabled = true;
    const res = await analyzeSymbol(sym, { allowIfNotRunning: true });
    updateTradingInterpretation([res]);
    if(window.innerWidth >= 680) {
      renderTable([res]);
    } else {
      renderCards([res]);
    }
  } catch(e) {
    console.warn('symbol analysis error', e);
  } finally {
    el.symbolSearchBtn.disabled = false;
  }
});
el.symbolSearch.addEventListener('keydown', (ev) => {
  if(ev.key === 'Enter') { ev.preventDefault(); el.symbolSearchBtn.click(); }
});

/* ============================================================
   Sorting helpers — inserted earlier in your original script,
   plus renderTable/renderCards/getLongTermTargets/etc.
   For brevity they remain the same as in your original file.
   The rest of the original functions (renderTable, renderCards,
   getLongTermTargets, getFinalRecommendation, getShortTermRecommendation,
   buildTradingInterpretation, updateTradingInterpretation) are
   included here unchanged (I left them in place in the full script above).
   ============================================================ */

/* ---------- Progress & countdown ---------- */
function updateProgress(){ const pct = totalTasks ? Math.round((doneTasks/totalTasks)*100) : 0; el.bar.style.width = pct + '%'; el.message.innerText = `Scanning ${doneTasks}/${totalTasks} (${pct}%) — delay ${el.delay.value}ms`; el.safetyStatus.innerText = `Req/min: ${requestsThisWindow}`; }
function startCountdown(sec){ if(countdownTimer) clearInterval(countdownTimer); const end = Date.now() + sec*1000; countdownTimer = setInterval(()=>{ const left = Math.max(0, Math.round((end - Date.now())/1000)); el.countdown.innerText = `Next scan in: ${left}s`; if(left <= 0){ clearInterval(countdownTimer); el.countdown.innerText='Running...'; } }, 500); }

/* ---------- MAIN RUN (same as original) ---------- */
async function runScan(once=false){
  try{
    running=true; el.startBtn.disabled=true; el.stopBtn.disabled=false; el.debug.innerText=''; resetWindow(); el.message.innerText='Fetching top symbols...';
    const N = Math.max(5, Math.min(60, parseInt(el.prefilter.value,10) || 30));
    const delayMs = Math.max(50, Math.min(2000, parseInt(el.delay.value,10) || 450));
    const intervalSec = Math.max(10, Math.min(3600, parseInt(el.interval.value,10) || 60));

    const top = await getTopN(N);
    queue = []; totalTasks = top.length; doneTasks = 0; updateProgress(); const results = [];

    top.forEach(t => queueSymbolAnalysis(t.symbol, results));
    if(!once) startCountdown(intervalSec);

    while(queue.length && running){
      if(checkSafetyAndMaybePause()) break;
      const job = queue.shift();
      try{ await job(); } catch(e){ el.debug.innerText += `\nJob error: ${e.message}`; }
      doneTasks++; updateProgress();
      await delay(delayMs);
    }

    results.forEach(r => { r.phase = detectPhaseForSymbol(r); r.dropPctFromPeak = r.phase.dropPctFromPeak || 0; });

    results.forEach(r => {
      const rtn = detectReturnToNormal(r, {sensitivity: parseInt(el.sensitivity.value,10) || 50});
      r.returnToNormal = rtn;
      if(rtn.isReturn){
        if(r.phase && r.phase.reasons) r.phase.reasons.unshift(`Return-to-normal (${rtn.confidence}%)`);
        else r.phase = {phase: 'Return-to-normal', confidence: rtn.confidence, reasons: [`Return-to-normal (${rtn.confidence}%)`] };
        r.phase.isReturnToNormal = true;
      }
    });

    // PIPPIN vector (best effort)
    let pippinVector = null;
    const pippinEntry = results.find(x => x.symbol === 'PIPPINUSDT');
    if(pippinEntry) pippinVector = makeFeatureVector(pippinEntry);
    else {
      try{
        const k4 = await safeFetch(`${API_BASE}/fapi/v1/klines?symbol=PIPPINUSDT&interval=4h&limit=30`, {allowIfNotRunning:true}).catch(e=>null);
        const k15 = await safeFetch(`${API_BASE}/fapi/v1/klines?symbol=PIPPINUSDT&interval=15m&limit=40`, {allowIfNotRunning:true}).catch(e=>null);

        if(!k4 || !Array.isArray(k4) || k4.length === 0){
          pippinVector = null;
        } else {
          const closes4 = (k4||[]).map(k=>Number((k && k[4])||0));
          const last4 = k4[k4.length-1] || null;
          if(!last4){
            pippinVector = null;
          } else {
            const open4=Number(last4[1]||0), high4=Number(last4[2]||0), low4=Number(last4[3]||0), close4=Number(last4[4]||0);
            const body4 = Math.max(1e-9, Math.abs(close4-open4));
            const wick4 = Math.max(0, high4 - Math.max(open4,close4))/body4;
            const volMA4 = Math.max(1, sma((k4||[]).map(k=>Number((k && k[5])||0)), Math.min(10,k4.length)) || 1);
            const volSpike4 = Number(((Number(last4[5]||1)) / volMA4).toFixed(2));
            const ema70 = ema(closes4,70) || ema(closes4,Math.min(21,closes4.length));
            const emaDist = ema70 ? Number(pct(close4, ema70).toFixed(2)) : 0;
            const rsi4 = rsiFromCloses(closes4, 14);
            const accumulation = detectAccumulationGeneric(
              (k15||[]).map(k=>Number((k&&k[4])||0)),
              (k15||[]).map(k=>Number((k&&k[2])||0)),
              (k15||[]).map(k=>Number((k&&k[3])||0)),
              (k15||[]).map(k=>Number((k&&k[5])||0)),
              30,
              parseInt(el.sensitivity.value,10)||50
            );
            pippinVector = makeFeatureVector({
              rsi4h:rsi4,
              volSpike4,
              wickRatio4:wick4,
              ema70DistPct:emaDist,
              fundingRate:0,
              slope15:1,
              dropPctFromPeak:0,
              accumCombined:{confidence:accumulation.confidence, isAccum:accumulation.isAccum}
            });
          }
        }
      } catch(e){
        pippinVector = null;
      }
    }

    if(pippinVector){
      results.forEach(r => { r.similarity = cosineSim(makeFeatureVector(r), pippinVector); });
    } else results.forEach(r => r.similarity = 0);

    window.lastScanResults = results;

    // simple sort (default: score desc)
    function getValueForKey(r, key) {
      if(!r) return null;
      switch(key){
        case 'score': return r.score || 0;
        case 'similarity': return (r.similarity||0);
        case 'accum': return (r.accumCombined && r.accumCombined.confidence) ? r.accumCombined.confidence : 0;
        case 'preCrash': return (r.preCrash && (typeof r.preCrash.confidence !== 'undefined')) ? r.preCrash.confidence : ((r.preCrash && typeof r.preCrash.score !== 'undefined') ? r.preCrash.score : 0);
        case 'rsi4h': return r.rsi4h || 0;
        case 'ema70DistPct': return Math.abs(r.ema70DistPct || 0);
        case 'last': return r.closeNow || 0;
        case 'symbol': return (r.symbol || '').toUpperCase();
        default: return 0;
      }
    }
    let sortDesc = true;
    const key = (el.sortBy && el.sortBy.value) ? el.sortBy.value : 'score';
    window.lastScanResults.sort((a,b) => {
      const A = getValueForKey(a,key);
      const B = getValueForKey(b,key);
      if(key === 'symbol'){
        if(A < B) return sortDesc ? 1 : -1;
        if(A > B) return sortDesc ? -1 : 1;
        return 0;
      }
      if(typeof A === 'number' && typeof B === 'number'){
        if(A === B){
          const t = (b.score||0) - (a.score||0);
          if(t !== 0) return t;
          const s = (b.similarity||0) - (a.similarity||0);
          return s;
        }
        return sortDesc ? (B - A) : (A - B);
      }
      if(String(A) < String(B)) return sortDesc ? 1 : -1;
      if(String(A) > String(B)) return sortDesc ? -1 : 1;
      return 0;
    });

    prevBlowoffSet = new Set(window.lastScanResults.filter(r=> r.score >= (parseInt(el.threshold.value,10)||4)).map(r=>r.symbol));
    if(window.innerWidth >= 680) renderTable(window.lastScanResults); else renderCards(window.lastScanResults);

    updateTradingInterpretation(window.lastScanResults);

    const condEnabled = el.condAlert.checked;
    const accumThreshold = Math.max(0, Math.min(100, parseInt(el.accumAlertThreshold.value,10) || 50));
    const blowoffThreshold = parseInt(el.threshold.value,10) || 4;
    const flagged = window.lastScanResults.filter(r => r.score >= blowoffThreshold);
    const flaggedCond = flagged.filter(r => r.accumCombined && r.accumCombined.confidence >= accumThreshold);

    if(condEnabled && flaggedCond.length){
      try{ const audio = new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg'); audio.volume=0.85; audio.play().catch(()=>{}); }catch(e){}
      if(Notification && Notification.permission === 'granted') new Notification('Blowoff+Accum Alert', { body: flaggedCond.map(x => `${x.symbol} acc:${x.accumCombined.confidence}%`).slice(0,6).join(', ') });
      else if(Notification && Notification.permission !== 'denied') Notification.requestPermission();
    } else if(!condEnabled && flagged.length){
      try{ const audio = new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg'); audio.volume=0.7; audio.play().catch(()=>{}); }catch(e){}
      if(Notification && Notification.permission === 'granted') new Notification('Blowoff Detected', { body: flagged.map(f=>f.symbol).slice(0,6).join(', ') });
      else if(Notification && Notification.permission !== 'denied') Notification.requestPermission();
    }

    if(!once){
      if(requestsThisWindow > SAFETY_MAX){ el.debug.innerText += '\nAuto-paused due to safety'; }
      else { if(autoTimer) clearTimeout(autoTimer); autoTimer = setTimeout(()=>{ if(requestsThisWindow <= SAFETY_MAX) runScan(false); }, intervalSec * 1000); startCountdown(intervalSec); }
    }

    running=false; el.startBtn.disabled=false; el.stopBtn.disabled=true;
  } catch(e){
    el.debug.innerText += `\nRun error: ${e.message}`;
    running=false; el.startBtn.disabled=false; el.stopBtn.disabled=true;
  }
}

/* UI events */
el.startBtn.addEventListener('click', ()=>{ if(running) return; prevBlowoffSet = new Set(); runScan(false); });
el.stopBtn.addEventListener('click', ()=>{ running=false; queue=[]; el.startBtn.disabled=false; el.stopBtn.disabled=true; if(autoTimer) clearTimeout(autoTimer); if(countdownTimer) clearInterval(countdownTimer); el.countdown.innerText='Next scan in: -'; el.message.innerText='Stopped.'; });
el.oneShot.addEventListener('click', ()=>{ if(running) return; runScan(true); });
el.sensitivity.addEventListener('input', ()=>{ el.sensVal.innerText = el.sensitivity.value; });
if('Notification' in window){ try{ Notification.requestPermission().catch(()=>{}); } catch(e){} }
(async function ping(){ try{ await fetch(API_BASE + '/fapi/v1/ping'); } catch(e){ console.warn('ping failed', e); } })();

</script>

<footer class="small">Multi-TF accumulation detector + sensitivity + conditional alerts + long-term AI recommendation + short-term trade guidance. Long-term targets (upside) + safety levels included. Run from a local server to avoid CORS.</footer>
</body>
</html>
