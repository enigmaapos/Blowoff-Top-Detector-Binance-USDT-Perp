<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Blowoff Top Detector â€” Professional Dashboard</title>

<!-- ====== PROFESSIONAL TRADING DASHBOARD THEME ====== -->
<style>
:root {
  --bg: #0A0F1A;            /* main background */
  --card: #111722;          /* card panels */
  --border: #1C2535;        /* subtle borders */
  --muted: #A9B8D4;         /* secondary text */
  --accent: #00FFC6;        /* bullish / accumulation */
  --bear: #FF5C5C;          /* bearish / blowoff */
  --warn: #FFD24A;          /* return-to-normal */
  --info: #89B4FA;          /* sorting / neutral info */
  --aiLong: #8BFFBF;        /* AI long-term recommendation */
  --aiShort: #FFE083;       /* AI short-term recommendation */
  --glass: rgba(255,255,255,0.04);
}

body {
  margin: 0;
  padding: 16px;
  font-family: Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial;
  background: var(--bg);
  color: #E8EEF7;
}

/* ===== Card Panel ===== */
.card-panel {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 16px;
  margin-bottom: 18px;
  box-shadow: 0 4px 14px rgba(0,0,0,0.6);
}

/* ===== Headings ===== */
h1 {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: #E8EEF7;
}

/* ====== Control Section ===== */
.controls {
  display: flex;
  flex-wrap: wrap;
  gap: 14px;
  margin-top: 14px;
  align-items: center;
}

label {
  font-size: 13px;
  color: var(--muted);
}

input, select {
  background: #0D1623;
  border: 1px solid #1F2A3A;
  color: #E8EEF7;
  padding: 6px 8px;
  border-radius: 6px;
}

button {
  background: #1F6FEB;
  border: none;
  color: white;
  padding: 8px 12px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 600;
}
button.alt {
  background: #2C3A4A;
}

/* ===== Progress + Status ===== */
.status {
  display: flex;
  flex-wrap: wrap;
  gap: 14px;
  margin-top: 10px;
  font-size: 13px;
  color: var(--muted);
}

.progress {
  flex: 1;
  height: 10px;
  background: #05101A;
  border-radius: 5px;
  overflow: hidden;
}
.progress > i {
  display: block;
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, var(--accent), #4ea7ff);
}

/* ===== Table Styles ===== */
table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 20px;
  font-size: 13px;
}
th {
  text-align: left;
  padding: 8px;
  color: var(--muted);
  border-bottom: 1px solid var(--border);
}
td {
  padding: 8px;
  border-bottom: 1px dashed var(--border);
}

/* ===== Color Tags ===== */
.phaseTag {
  display: inline-block;
  padding: 4px 8px;
  border-radius: 8px;
  font-size: 12px;
  font-weight: 700;
}

.phase-accum      { background: var(--accent); color: #042218; }
.phase-blowoff    { background: var(--bear); color: #fff; }
.phase-return     { background: var(--warn); color: #3a2a00; }
.phase-distrib    { background: #FFB169; color: #3d1f00; }
.phase-breakdown  { background: #FF7B7B; color: white; }
.phase-normal     { background: #3A4B6A; color: white; }

/* ===== AI Recommendation Boxes ===== */
.finalRec {
  margin-top: 6px;
  padding: 10px;
  background: rgba(0,255,198,0.08);
  border-left: 3px solid var(--aiLong);
  color: var(--aiLong);
  font-weight: 600;
}

.shortRec {
  margin-top: 6px;
  padding: 10px;
  background: rgba(255,210,74,0.08);
  border-left: 3px solid var(--aiShort);
  color: var(--aiShort);
  font-weight: 600;
}

/* ===== Mobile Card View ===== */
#cardView { display: none; }
@media (max-width: 700px) {
  #tableView { display: none; }
  #cardView { display: block; }

  .coinCard {
    background: var(--card);
    border: 1px solid var(--border);
    padding: 14px;
    border-radius: 12px;
    margin-bottom: 12px;
  }
  .coinSymbol { font-size: 16px; font-weight: 700; }
  .coinScore { color: var(--warn); font-weight: 700; }
}
</style>
</head>
<body>

  <div class="card-panel">
  <h1>Blowoff Top Detector â€” Professional Dashboard</h1>

  <div class="small" style="margin-top:6px;color:var(--muted)">
    Multi-TF accumulation detector â€¢ Blowoff scoring â€¢ PIPPIN similarity â€¢ AI long + short-term recommendations  
    <br>Run locally to avoid CORS: <code>python -m http.server</code>
  </div>

  <!-- =======================
       ROW 1 â€” SCAN SETTINGS
       ======================= -->
  <div class="controls" style="margin-top:16px; border-bottom:1px solid var(--border); padding-bottom:12px;">
    
    <label>Prefilter (top 24h)
      <input id="prefilter" type="number" value="30" min="5" max="80">
    </label>

    <label>Delay (ms)
      <input id="delay" type="number" value="450" min="50" max="2000">
    </label>

    <label>Refresh (sec)
      <input id="interval" type="number" value="60" min="10" max="3600">
    </label>

    <label>Score â‰¥
      <input id="threshold" type="number" value="4" min="1" max="8">
    </label>

    <button id="startBtn">Start</button>
    <button id="stopBtn" class="alt" disabled>Stop</button>
    <button id="oneShot" class="alt">Run Once</button>
  </div>

  <!-- ===========================
       ROW 2 â€” ACCUMULATION SETTINGS
       =========================== -->
  <div class="controls" style="margin-top:16px; border-bottom:1px solid var(--border); padding-bottom:12px;">
    
    <label style="font-weight:600;color:var(--info)">Accumulation TFs:</label>

    <label><input type="checkbox" id="tf15" checked> 15m</label>
    <label><input type="checkbox" id="tf1h" checked> 1h</label>
    <label><input type="checkbox" id="tf4h" checked> 4h</label>

    <label style="margin-left:16px">
      Sensitivity:
      <span id="sensVal" class="small" style="margin-left:4px">50</span>
    </label>
    <input id="sensitivity" class="sensitivity" type="range" min="0" max="100" value="50" style="width:160px">

    <label style="margin-left:16px">
      <input type="checkbox" id="condAlert">
      Blowoff HIGH + Accum â‰¥
    </label>

    <input id="accumAlertThreshold" type="number" value="50" min="0" max="100" style="width:60px">

    <label style="margin-left:16px">
      <input type="checkbox" id="showShort" checked>
      Show short-term plans
    </label>

  </div>

  <!-- =======================
       ROW 3 â€” SORT + SYMBOL SEARCH
       ======================= -->
  <div class="controls" style="margin-top:16px;">

    <label style="font-weight:600;color:var(--info)">Sort by</label>

    <select id="sortBy">
      <option value="score">Score</option>
      <option value="similarity">PIPPIN similarity</option>
      <option value="accum">Accum confidence</option>
      <option value="preCrash">Pre-crash confidence</option>
      <option value="rsi4h">RSI (4H)</option>
      <option value="ema70DistPct">EMA stretch %</option>
      <option value="last">Last price</option>
      <option value="symbol">Symbol</option>
    </select>

    <button id="sortDir" class="alt">Desc</button>

    <label style="margin-left:16px">Search symbol:
      <input id="symbolSearch" placeholder="e.g. BTCUSDT" style="width:150px">
    </label>

    <button id="symbolSearchBtn" class="alt">Analyze</button>
    <button id="symbolClearCache" class="alt">Clear cache</button>

    <span id="symbolStatus" class="small" style="color:var(--muted);"></span>
  </div>

  <!-- STATUS BAR -->
  <div class="status" style="margin-top:20px;">
    <div id="message">Ready.</div>
    <div class="progress"><i id="bar"></i></div>
    <div id="countdown" class="countdown">Next scan in: -</div>
    <div id="safetyStatus" class="mutedBadge">Safety OK</div>
  </div>

  <div id="tableView"></div>
  <div id="cardView"></div>

  <div id="tradeInterpret" class="tradePanel" style="display:none"></div>
  <div id="debug" class="small" style="margin-top:10px;color:var(--muted)"></div>
</div>

  <script>
/* ============================================================
   SECTION 3 â€” SORTING SYSTEM (Professional Version)
   Handles:
     â€¢ Sorting state
     â€¢ Sorting logic
     â€¢ UI event listeners
     â€¢ Key extractors for different metrics
============================================================ */

/* -----------------------------
   Sorting State
----------------------------- */
let SORT_KEY = "score";      // default sorting column
let SORT_DIR = "desc";       // "asc" or "desc"

/* -----------------------------
   Extract numeric/string value
   from result object based on
   the selected sort key.
----------------------------- */
function getSortValue(item, key) {
  switch(key) {
    case "score": return item.score || 0;
    case "similarity": return item.similarity || 0;
    case "accum": return item.accumCombined ? item.accumCombined.confidence || 0 : 0;
    case "preCrash": return item.preCrash ? (item.preCrash.confidence || item.preCrash.score || 0) : 0;
    case "rsi4h": return item.rsi4h || 0;
    case "ema70DistPct": return Math.abs(item.ema70DistPct || 0);
    case "last": return item.closeNow || 0;
    case "symbol": return (item.symbol || "").toUpperCase();
    default: return 0;
  }
}

/* -----------------------------
   Sorting Function
----------------------------- */
function sortResults(list) {
  if(!list || !Array.isArray(list)) return list;

  const key = SORT_KEY;
  const dir = SORT_DIR;

  list.sort((a, b) => {
    const A = getSortValue(a, key);
    const B = getSortValue(b, key);

    // alphabetical sort
    if(key === "symbol") {
      if(A < B) return dir === "desc" ? 1 : -1;
      if(A > B) return dir === "desc" ? -1 : 1;
      return 0;
    }

    // numeric sort
    if(A === B) {
      // tiebreaker 1: score
      const s = (b.score || 0) - (a.score || 0);
      if(s !== 0) return s;

      // tiebreaker 2: similarity
      return (b.similarity || 0) - (a.similarity || 0);
    }

    return dir === "desc" ? (B - A) : (A - B);
  });

  return list;
}

/* -----------------------------
   UI Event â€” Sort Key Change
----------------------------- */
document.getElementById("sortBy").addEventListener("change", (ev) => {
  SORT_KEY = ev.target.value;

  if(window.lastScanResults) {
    sortResults(window.lastScanResults);
    renderTable(window.lastScanResults);
    renderCards(window.lastScanResults);
  }
});

/* -----------------------------
   UI Event â€” Sort Direction Toggle
----------------------------- */
document.getElementById("sortDir").addEventListener("click", () => {
  SORT_DIR = SORT_DIR === "desc" ? "asc" : "desc";

  // Update button text
  document.getElementById("sortDir").innerText = SORT_DIR === "desc" ? "Desc" : "Asc";

  // Apply immediately if results already loaded
  if(window.lastScanResults) {
    sortResults(window.lastScanResults);
    renderTable(window.lastScanResults);
    renderCards(window.lastScanResults);
  }
});

/* -----------------------------
   Public API â€” Apply Sorting
   Called after each scan cycle.
----------------------------- */
function applySorting(results) {
  if(!results) return results;
  return sortResults(results);
}


/* ============================================================
   SECTION 4 â€” AI RECOMMENDATION ENGINE (Professional)
   Generates:
     âœ“ Long-term AI recommendation
     âœ“ Short-term trade plan
     âœ“ Bias + direction
     âœ“ Upside/safety targets
     âœ“ One-line summary
============================================================ */

/* -------------------------------------------------------------
   UTILITY â€” Generate Long-Term Upside + Safety Targets
------------------------------------------------------------- */
function getLongTermTargets(item) {
  const price = item.closeNow || 0;
  if(!price || price <= 0) {
    return {
      upside: [],
      safety: [],
      recentHL: null,
      swingHigh: null
    };
  }

  return {
    upside: [
      (price * 1.12).toFixed(6),
      (price * 1.30).toFixed(6),
      (price * 1.60).toFixed(6)
    ],
    safety: [
      (price * 0.92).toFixed(6),
      (price * 0.86).toFixed(6),
      (price * 0.75).toFixed(6)
    ],
    recentHL: `${(price * 1.02).toFixed(6)} / ${(price * 0.92).toFixed(6)}`,
    swingHigh: (price * 1.10).toFixed(6)
  };
}

/* -------------------------------------------------------------
   AI â€” Short-Term Bias Detector
------------------------------------------------------------- */
function getShortTermBias(item) {
  const rsi = item.rsi15 || 50;
  const accum = item.accumCombined ? item.accumCombined.confidence : 0;
  const wick = item.wickRatio4 || 0;

  if(rsi >= 78 && wick > 1.2) return "Bearish";
  if(accum >= 70 && rsi < 65) return "Bullish";
  return "Neutral";
}

/* -------------------------------------------------------------
   AI â€” Short-Term Trading Plan
------------------------------------------------------------- */
function getShortTermRecommendation(item) {
  const bias = getShortTermBias(item);

  if(bias === "Bearish") {
    return {
      bias,
      text: `Short-term bearish â€” bounce likely temporary; best edge is fading rejections.`,
      plan: `Wait for rejection at resistance; short with stop above swing high.`,
      targets: [
        (item.closeNow * 0.965).toFixed(6),
        (item.closeNow * 0.945).toFixed(6),
        (item.closeNow * 0.915).toFixed(6)
      ]
    };
  }

  if(bias === "Bullish") {
    return {
      bias,
      text: `Short-term bullish â€” prefer buying dips during stabilizing RSI.`,
      plan: `Enter on 15m/1h higher-low with rising volume.`,
      targets: [
        (item.closeNow * 1.04).toFixed(6),
        (item.closeNow * 1.08).toFixed(6),
        (item.closeNow * 1.12).toFixed(6)
      ]
    };
  }

  return {
    bias,
    text: `Short-term neutral â€” no clean long or short edge. Wait for structure.`,
    plan: `Wait for a rejection (short) or higher-low with volume (long).`,
    targets: []
  };
}

/* -------------------------------------------------------------
   AI â€” Long-Term Recommendation Logic
------------------------------------------------------------- */
function getFinalRecommendation(item) {
  const phase = item.phase?.phase || "Unknown";
  const accum = item.accumCombined ? item.accumCombined.confidence : 0;
  const rsi4 = item.rsi4h || 50;
  const sim = item.similarity || 0;

  // 1. Strong accumulation
  if(accum >= 70 && rsi4 < 75) {
    return `Strong multi-TF accumulation â€” long-term entries valid on dips; add position only after stable 4H base.`;
  }

  // 2. Blowoff / distribution
  if(phase.includes("Climax") || phase.includes("Distribution") || phase.includes("Breakdown")) {
    return `Distribution detected â€” avoid long-term longs; expect deeper retrace until accumulation forms again.`;
  }

  // 3. Capitulation / post-crash
  if(phase.includes("Capitulation")) {
    return `Post-capitulation region â€” wait for sideways stabilization before long-term entry.`;
  }

  // 4. Return-to-normal (PIPPIN-like)
  if(item.returnToNormal && item.returnToNormal.isReturn) {
    return `Return-to-normal behavior â€” trend is re-balancing. Good for DCA but avoid full size until EMAs turn up.`;
  }

  // 5. PIPPIN-style similarity high
  if(sim >= 0.75) {
    return `High similarity to PIPPIN pattern â€” expect re-accumulation followed by trend continuation.`;
  }

  // 6. Weak or unclear signals
  return `No clear long-term bias â€” use a small starter and wait for stronger multi-TF confirmation.`;
}

/* -------------------------------------------------------------
   MAIN WRAPPER â€” Attach All AI Output to Item
------------------------------------------------------------- */
function enrichWithAI(item) {
  item.longTargets = getLongTermTargets(item);
  item.shortRec = getShortTermRecommendation(item);
  item.finalRec = getFinalRecommendation(item);
  return item;
}


/* ============================================================
   SECTION 5 â€” ADVANCED PHASE DETECTOR (Professional Engine)
   Identifies:
     âœ“ Accumulation
     âœ“ Re-Accumulation
     âœ“ Distribution Top
     âœ“ Blowoff / Climax
     âœ“ Breakdown
     âœ“ Capitulation
     âœ“ Dead-Cat Bounce
     âœ“ Return-to-Normal
============================================================ */

function detectPhaseForSymbol(item) {
  try {
    const k4 = item.k4h || [];
    const k15 = item.k15m || [];
    const rsi4h = item.rsi4h || 0;
    const vol = item.volSpike4 || 1;
    const wick = item.wickRatio4 || 0;

    const reasons = [];
    let score = 0;

    /* ---------------------------------------------------------
       1. STRUCTURE ANALYSIS (Lower highs, drop-from-peak)
    --------------------------------------------------------- */
    let lowerHCount = 0;
    if (k4.length >= 6) {
      const highs = k4.slice(-8).map(k => Number(k[2]));
      for (let i = 1; i < highs.length; i++) {
        if (highs[i] < highs[i - 1]) lowerHCount++;
      }
    }

    const highest4h = k4.length ? Math.max(...k4.map(k => Number(k[2]))) : item.closeNow;
    const lastClose = item.closeNow || 0;
    const dropPctFromPeak = highest4h
      ? Math.abs((lastClose - highest4h) / highest4h) * 100
      : 0;

    /* ---------------------------------------------------------
       2. ACCUMULATION PRIORITY (Multi-TF)
    --------------------------------------------------------- */
    if (item.accumCombined?.isAccum) {
      reasons.push(`Accumulation seen (combined ${item.accumCombined.confidence}%)`);
      score += 4;
    }

    /* ---------------------------------------------------------
       3. BLOWOFF / CLIMAX DETECTION
    --------------------------------------------------------- */
    if (wick >= 1.8 && vol >= 3 && rsi4h >= 85) {
      score += 3;
      reasons.push("Climax candle (wick + volume + RSI)");
    }

    /* ---------------------------------------------------------
       4. DISTRIBUTION (Sideways topping)
    --------------------------------------------------------- */
    if (k15.length > 10) {
      const highs15 = k15.map(k => Number(k[2]));
      const lows15 = k15.map(k => Number(k[3]));
      const range = Math.max(...highs15) - Math.min(...lows15);

      if (range <= (Math.min(...lows15) * 0.10) && rsi4h >= 60) {
        score += 2;
        reasons.push("Distribution: tight range + elevated RSI");
      }
    }

    /* ---------------------------------------------------------
       5. BREAKDOWN (Lower highs + weakness)
    --------------------------------------------------------- */
    if (lowerHCount >= 3) {
      score += 2;
      reasons.push(`Breakdown structure: lower highs (${lowerHCount})`);
    }

    /* ---------------------------------------------------------
       6. CAPITULATION A (fast high-volume drop)
    --------------------------------------------------------- */
    if (dropPctFromPeak >= 18 && vol >= 2.2) {
      score += 3;
      reasons.push("Capitulation: large drop + volume expansion");
    }

    /* ---------------------------------------------------------
       7. DEAD-CAT BOUNCE DETECTION
    --------------------------------------------------------- */
    if (k15.length >= 20) {
      const closes = k15.map(k => Number(k[4]));
      const segment = closes.slice(-20);
      const minVal = Math.min(...segment);
      const bounce = ((segment[segment.length - 1] - minVal) / minVal) * 100;

      if (bounce >= 8 && bounce <= 45) {
        score += 1;
        reasons.push(`Dead-cat bounce: ${bounce.toFixed(1)}%`);
      }
    }

    /* ---------------------------------------------------------
       8. RETURN TO NORMAL (from Section 3)
    --------------------------------------------------------- */
    if (item.returnToNormal?.isReturn) {
      reasons.unshift(`Return-to-normal (${item.returnToNormal.confidence}%)`);
      return {
        phase: "Return-to-normal",
        confidence: item.returnToNormal.confidence,
        reasons,
        dropPctFromPeak
      };
    }

    /* ---------------------------------------------------------
       PHASE PRIORITIZATION ENGINE
    --------------------------------------------------------- */
    const candidates = [];

    // Accumulation gets top priority
    if (item.accumCombined?.isAccum) {
      candidates.push({ phase: "Accumulation / Re-accumulation", priority: 9 });
    }

    if (score >= 9 && reasons.some(r => r.includes("Capitulation"))) {
      candidates.push({ phase: "Capitulation A", priority: 8 });
    }

    if (score >= 7 && reasons.some(r => r.includes("Distribution"))) {
      candidates.push({ phase: "Distribution / Sideways Top", priority: 7 });
    }

    if (score >= 5 && reasons.some(r => r.includes("Breakdown"))) {
      candidates.push({ phase: "Breakdown", priority: 6 });
    }

    if (score >= 5 && reasons.some(r => r.includes("Climax"))) {
      candidates.push({ phase: "Climax Candle (Blowoff Wick)", priority: 6 });
    }

    if (reasons.some(r => r.includes("Dead-cat"))) {
      candidates.push({ phase: "Dead-cat Bounce", priority: 4 });
    }

    if (candidates.length === 0) {
      if (dropPctFromPeak >= 20) {
        candidates.push({ phase: "Capitulation A", priority: 8 });
      } else {
        candidates.push({ phase: "Normal / Trending", priority: 1 });
      }
    }

    // Choose by highest priority
    candidates.sort((a, b) => b.priority - a.priority);

    const chosen = candidates[0].phase;
    const conf = Math.min(
      96,
      Math.round((score / 14) * 80) +
        (item.accumCombined?.confidence ? item.accumCombined.confidence * 0.2 : 0)
    );

    return {
      phase: chosen,
      confidence: Math.round(conf),
      reasons,
      dropPctFromPeak
    };
  } catch (err) {
    return {
      phase: "Unknown",
      confidence: 0,
      reasons: ["Phase detection error: " + err.message],
      dropPctFromPeak: 0
    };
  }
}

    
/* ============================================================
   SECTION 6 â€” BLOWOFF TOP EXPLANATION ENGINE
   Produces:
     âœ“ Probability %
     âœ“ Label (Low / Medium / High / Extreme)
     âœ“ Color code
     âœ“ Key reasons
============================================================ */

function explainBlowoff(item) {
  let pts = 0;
  const reasons = [];

  /* ---------------------------------------------------------
     1. RSI EXTREMES
  --------------------------------------------------------- */
  if (item.rsi1d !== null && item.rsi1d >= 88) {
    pts += 2;
    reasons.push(`ðŸŸ¥ 1D RSI extremely overbought (${item.rsi1d.toFixed(1)})`);
  } else if (item.rsi1d >= 80) {
    pts += 1;
    reasons.push(`ðŸŸ§ 1D RSI elevated (${item.rsi1d.toFixed(1)})`);
  }

  if (item.rsi4h !== null && item.rsi4h >= 85) {
    pts += 2;
    reasons.push(`ðŸŸ¥ 4H RSI at exhaustion (${item.rsi4h.toFixed(1)})`);
  } else if (item.rsi4h >= 78) {
    pts += 1;
    reasons.push(`ðŸŸ§ 4H RSI high (${item.rsi4h.toFixed(1)})`);
  }

  /* ---------------------------------------------------------
     2. VOLUME SPIKE (CLIMAX)
  --------------------------------------------------------- */
  if (item.volSpike4 >= 3) {
    pts += 2;
    reasons.push(`ðŸŸ¥ Volume climax Ã—${item.volSpike4}`);
  } else if (item.volSpike4 >= 1.8) {
    pts += 1;
    reasons.push(`ðŸŸ§ Volume spike Ã—${item.volSpike4}`);
  }

  /* ---------------------------------------------------------
     3. WICK BEHAVIOR (BLOWOFF SIGNAL)
  --------------------------------------------------------- */
  if (item.wickRatio4 >= 2.0) {
    pts += 2;
    reasons.push(`ðŸŸ¥ Blowoff upper wick (${item.wickRatio4.toFixed(2)})`);
  } else if (item.wickRatio4 >= 1.2) {
    pts += 1;
    reasons.push(`ðŸŸ§ Strong upper wick (${item.wickRatio4.toFixed(2)})`);
  }

  /* ---------------------------------------------------------
     4. EMA STRETCH (PARABOLIC EXHAUSTION)
  --------------------------------------------------------- */
  if (item.ema70DistPct >= 150) {
    pts += 2;
    reasons.push(`ðŸŸ¥ EMA stretch ${item.ema70DistPct}% (Very overextended)`);
  } else if (item.ema70DistPct >= 50) {
    pts += 1;
    reasons.push(`ðŸŸ§ EMA overextended ${item.ema70DistPct}%`);
  }

  /* ---------------------------------------------------------
     5. FUNDING (NEGATIVE CONFIRMATION)
  --------------------------------------------------------- */
  if (typeof item.fundingRate === "number") {
    const f = item.fundingRate * 100;
    if (f <= -0.10) {
      pts += 2;
      reasons.push(`ðŸŸ¥ Funding extremely negative (${f.toFixed(3)}%)`);
    } else if (f <= -0.05) {
      pts += 1;
      reasons.push(`ðŸŸ§ Funding negative (${f.toFixed(3)}%)`);
    }
  }

  /* ---------------------------------------------------------
     6. STRUCTURE (LOWER HIGH â†’ TOP REVERSAL)
  --------------------------------------------------------- */
  if (item.lowerHigh) {
    pts += 1;
    reasons.push(`ðŸŸ§ Lower-high formed (trend weakening)`);
  }

  /* ---------------------------------------------------------
     SCORE â†’ LABEL â†’ PROBABILITY
  --------------------------------------------------------- */

  let label = "None";
  let color = "#9fb3cc";
  let prob = 5;

  if (pts >= 10) {
    label = "Extreme";
    color = "#ff4d4d";
    prob = 92;
  } 
  else if (pts >= 7) {
    label = "High";
    color = "#ff884d";
    prob = 78;
  } 
  else if (pts >= 4) {
    label = "Medium";
    color = "#ffd966";
    prob = 55;
  } 
  else if (pts >= 2) {
    label = "Low";
    color = "#7df59e";
    prob = 25;
  }

  const summary = reasons.length
    ? `${reasons.join("; ")}. Estimated reversal probability: ${prob}%.`
    : "No exhaustion signals detected.";

  return {
    pts,
    label,
    color,
    prob,
    reasons,
    explanation: summary
  };
}

    
/* ============================================================
   SECTION 7 â€” AI TRADE RECOMMENDATION ENGINE
   Produces:
     âœ“ Long-term plan (starter allocation, stop, add rules)
     âœ“ Short-term plan (long/short behaviour, targets)
     âœ“ Color-coded sentiment
============================================================ */


/* ------------------------------------------------------------
   7A â€” LONG-TERM TARGET GENERATOR
   Includes:
      â€¢ Upside targets (based on volatility expansion)
      â€¢ Safety levels (retracement zones)
------------------------------------------------------------ */
function getLongTermTargets(item) {
  const price = item.closeNow || 0;
  if (price <= 0) return {upside:[], safety:[]};

  const stretch = Math.max(1.05, 1 + Math.abs(item.ema70DistPct || 15) / 100);

  const t1 = price * (1 + 0.10 * stretch);
  const t2 = price * (1 + 0.25 * stretch);
  const t3 = price * (1 + 0.45 * stretch);

  const s1 = price * (1 - 0.08 * stretch);
  const s2 = price * (1 - 0.15 * stretch);
  const s3 = price * (1 - 0.28 * stretch);

  return {
    upside: [t1, t2, t3].map(x => Number(x.toFixed(6))),
    safety: [s1, s2, s3].map(x => Number(x.toFixed(6)))
  };
}


/* ------------------------------------------------------------
   7B â€” LONG-TERM AI RECOMMENDATION
   Uses phase, accumulation, RSI, return-to-normal, pre-crash
------------------------------------------------------------ */
function getFinalRecommendation(item) {

  const accum = item.accumCombined?.confidence || 0;
  const isAccum = item.accumCombined?.isAccum || false;

  const rsi4 = item.rsi4h || 0;
  const rtn = item.returnToNormal?.confidence || 0;
  const blow = item.expl?.prob || 0;
  const phase = item.phase?.phase || "Unknown";

  /* ---- SCORING MODEL ------------------------------------- */
  let score = 0;

  if (isAccum) score += 3;
  if (accum >= 70) score += 2;

  if (rtn >= 50) score += 2;
  if (rtn >= 70) score += 1;

  if (rsi4 <= 55) score += 1;

  // penalty if blowoff present
  if (blow >= 55) score -= 2;
  if (blow >= 75) score -= 4;
  if (blow >= 90) score -= 6;

  /* ---- INTERPRETATION ------------------------------------ */
  let label = "Neutral";
  let color = "#cfe8ff";
  let text = "";

  if (score >= 5) {
    label = "Bullish Accumulation";
    color = "#66f9a1";
    text = 
`â€¢ Market showing multi-TF accumulation
â€¢ Good for staged long-term entries
â€¢ Start with a small allocation and add on confirmation`;
  }
  else if (score >= 2) {
    label = "Early Re-Accumulation";
    color = "#80ffd0";
    text = 
`â€¢ Trend stabilizing but not yet confirmed
â€¢ Only small starter position recommended
â€¢ Wait for 4H higher-low + rising volume before adding`;
  }
  else if (score <= -4) {
    label = "High-Risk Top / Exhaustion";
    color = "#ff4d4d";
    text =
`â€¢ Strong top signals detected
â€¢ Avoid large long positions
â€¢ Expect pullbacks or full reversal`;
  }
  else {
    label = "Uncertain / No Edge";
    color = "#ffd966";
    text = 
`â€¢ Not enough signal for a long-term trade
â€¢ Prefer to wait for better structure or clarity`;
  }

  return {
    label,
    color,
    text,
    score
  };
}


/* ------------------------------------------------------------
   7C â€” SHORT-TERM TRADE RECOMMENDATION ENGINE
   Generates:
      â€¢ Short-term bias (Bullish / Bearish / Neutral)
      â€¢ Trade plan (long setup / short setup)
      â€¢ Short-term targets
------------------------------------------------------------ */
function getShortTermRecommendation(item) {

  const price = item.closeNow || 0;
  const rsi = item.rsi15 || 0;
  const accum = item.accumCombined?.confidence || 0;
  const blow = item.expl?.prob || 0;

  /* --------------------------------------------------------
     Short-term Bias Logic
  -------------------------------------------------------- */
  let bias = "Neutral";
  let color = "#ffd966";

  if (blow >= 70) {
    bias = "Bearish (Exhaustion)";
    color = "#ff4d4d";
  }
  else if (rsi >= 70 && accum < 55) {
    bias = "Bearish (Overbought)";
    color = "#ff6b6b";
  }
  else if (accum >= 70 && rsi < 65) {
    bias = "Bullish (Accumulation)";
    color = "#66f9a1";
  }
  else if (accum >= 55 && rsi <= 60) {
    bias = "Bullish Attempt";
    color = "#80ffd0";
  }

  /* --------------------------------------------------------
     Short-term Targets (scalping levels)
  -------------------------------------------------------- */
  const t1 = price * 0.985;
  const t2 = price * 0.972;
  const t3 = price * 0.955;

  const u1 = price * 1.015;
  const u2 = price * 1.028;
  const u3 = price * 1.045;

  /* --------------------------------------------------------
     Short-term Plan Recommendation
  -------------------------------------------------------- */
  let plan = "";

  if (bias.includes("Bearish")) {
    plan =
`â€¢ Look for failed bounce / rejection
â€¢ Short at resistance with tight stop
â€¢ Take partial at first support`;
  }
  else if (bias.includes("Bullish")) {
    plan =
`â€¢ Wait for higher-low on 15m or 1h
â€¢ Enter when volume expands on green candle
â€¢ Add only if higher-low holds`;
  }
  else {
    plan =
`â€¢ No clear short-term edge
â€¢ Best to wait for structure to form`;
  }

  return {
    bias,
    color,
    plan,
    targetsDown: [t1, t2, t3].map(x => Number(x.toFixed(6))),
    targetsUp: [u1, u2, u3].map(x => Number(x.toFixed(6)))
  };
}

    
/* ============================================================
   SECTION 8 â€” RENDERING ENGINE
   Renders:
     â€¢ Table view (desktop)
     â€¢ Card view (mobile)
     â€¢ Full AI recommendation panel
============================================================ */


/* ------------------------------------------------------------
   Helper to color numbers
------------------------------------------------------------ */
function fmt(x){
  if (typeof x !== "number") return x;
  if (x > 0) return `<span class="green">${x.toFixed(2)}</span>`;
  if (x < 0) return `<span class="red">${x.toFixed(2)}</span>`;
  return x.toFixed(2);
}


/* ============================================================
   DESKTOP TABLE VIEW
============================================================ */
function renderTable(data){
  if(!data || !data.length){ 
    el.tableView.innerHTML = "<div>No data</div>"; 
    return;
  }

  let html = `
    <table>
      <thead>
        <tr>
          <th>Symbol</th>
          <th>Score</th>
          <th>PIPPIN Sim</th>
          <th>Accum%</th>
          <th>Phase</th>
          <th>Blowoff</th>
          <th>Return-to-Normal</th>
          <th>AI Rec (1-line)</th>
          <th>Long-term</th>
          <th>Short-term</th>
        </tr>
      </thead>
      <tbody>
  `;

  data.forEach(item => {
    
    const blow = item.expl || {};
    const rtn  = item.returnToNormal || {};
    const long = getLongTermTargets(item);
    const rec  = getFinalRecommendation(item);
    const sco  = getShortTermRecommendation(item);

    const phaseTxt = item.phase?.phase || "Unknown";

    const oneLine = rec.label;
    const color   = rec.color;

    html += `
      <tr>
        <td><b>${item.symbol}</b></td>

        <td>${item.score}</td>

        <td>${(item.similarity*100).toFixed(1)}%</td>

        <td>${item.accumCombined?.confidence || 0}%</td>

        <td>${phaseTxt}</td>

        <td style="color:${blow.color || '#fff'}">
          ${blow.label || 'None'}
        </td>

        <td>${rtn.isReturn ? `<span class="green">${rtn.confidence}%</span>` : '-'}</td>

        <td style="color:${color}">${oneLine}</td>

        <td>
          â†‘ ${long.upside.join(" â€¢ ")}<br>
          â†“ ${long.safety.join(" â€¢ ")}
        </td>

        <td>
          <span style="color:${sco.color}">${sco.bias}</span><br>
          â†‘ ${sco.targetsUp.join(" â€¢ ")}<br>
          â†“ ${sco.targetsDown.join(" â€¢ ")}
        </td>
      </tr>
    `;
  });

  html += "</tbody></table>";
  el.tableView.innerHTML = html;
}


/* ============================================================
   MOBILE CARD VIEW
============================================================ */
function renderCards(data){
  if(!data || !data.length){ 
    el.cardView.innerHTML = "<div>No data</div>"; 
    return;
  }

  let html = "";

  data.forEach(item => {
    const blow = item.expl || {};
    const rtn  = item.returnToNormal || {};
    const long = getLongTermTargets(item);
    const rec  = getFinalRecommendation(item);
    const sco  = getShortTermRecommendation(item);
    const phaseTxt = item.phase?.phase || "Unknown";

    html += `
      <div class="coinCard">

        <div class="coinRow1">
          <div class="coinSymbol">${item.symbol}</div>
          <div class="coinScore">Score: ${item.score}</div>
        </div>

        <div class="sigList">
          <b>Phase:</b> ${phaseTxt}<br>
          <b>PIPPIN sim:</b> ${(item.similarity*100).toFixed(1)}%<br>
          <b>Accum:</b> ${item.accumCombined?.confidence || 0}%<br>

          <b>Blowoff:</b>
          <span style="color:${blow.color || '#fff'}">${blow.label}</span><br>

          <b>Return-to-Normal:</b>
          ${rtn.isReturn ? `<span class="green">${rtn.confidence}%</span>` : '-'}
          <br>

          <b>AI (LT):</b> <span style="color:${rec.color}">${rec.label}</span><br>
          <b>AI (ST):</b> <span style="color:${sco.color}">${sco.bias}</span><br>

          <b>Long targets:</b><br>
          â†‘ ${long.upside.join(" â€¢ ")}<br>
          â†“ ${long.safety.join(" â€¢ ")}<br>

          <b>Short-term targets:</b><br>
          â†‘ ${sco.targetsUp.join(" â€¢ ")}<br>
          â†“ ${sco.targetsDown.join(" â€¢ ")}<br>
        </div>

      </div>
    `;
  });

  el.cardView.innerHTML = html;
}


/* ============================================================
   FULL INTERPRETATION PANEL (when clicking a coin)
============================================================ */
function buildTradingInterpretation(item){

  const rec = getFinalRecommendation(item);
  const sco = getShortTermRecommendation(item);
  const long = getLongTermTargets(item);

  return `
    <h3>${item.symbol} â€” Full Analysis</h3>

    <p><b>Phase:</b> ${item.phase?.phase}</p>

    <div class="recBox">
      <div class="finalRec" style="color:${rec.color}">
        ðŸ§  Long-term Recommendation: ${rec.label}
      </div>
      <p>${rec.text}</p>
    </div>

    <div class="recBox">
      <div class="shortRec" style="color:${sco.color}">
        âš¡ Short-term Bias: ${sco.bias}
      </div>
      <p>${sco.plan}</p>
    </div>

    <p><b>Long-term Targets:</b><br>
      â†‘ ${long.upside.join(" â€¢ ")}<br>
      â†“ ${long.safety.join(" â€¢ ")}
    </p>

    <p><b>Short-term Targets:</b><br>
      â†‘ ${sco.targetsUp.join(" â€¢ ")}<br>
      â†“ ${sco.targetsDown.join(" â€¢ ")}
    </p>
  `;
}


/* ------------------------------------------------------------
   Updates the Interpretation Panel (bottom of UI)
------------------------------------------------------------ */
function updateTradingInterpretation(data){
  if(!data || !data.length){
    el.tradeInterpret.style.display = "none";
    return;
  }

  // Show the first (top sorted) coin's full interpretation
  const item = data[0];

  el.tradeInterpret.innerHTML = buildTradingInterpretation(item);
  el.tradeInterpret.style.display = "block";
}

    
/* ============================================================
   SECTION 9 â€” MAIN RUN LOOP + SORTING + AUTO-SCAN CYCLE
============================================================ */

async function runScan(once = false){
  try{
    running = true;
    el.startBtn.disabled = true;
    el.stopBtn.disabled = false;
    el.debug.innerText = "";

    resetWindow();
    el.message.innerText = "Fetching top symbols...";

    // UI parameters
    const N = Math.max(5, Math.min(60, parseInt(el.prefilter.value,10) || 30));
    const delayMs = Math.max(50, Math.min(2000, parseInt(el.delay.value,10) || 450));
    const intervalSec = Math.max(10, Math.min(3600, parseInt(el.interval.value,10) || 60));

    // fetch top-volume/perf USDT futures
    const top = await getTopN(N);

    // queue tasks
    queue = [];
    totalTasks = top.length;
    doneTasks  = 0;
    updateProgress();

    const results = [];

    top.forEach(t => queueSymbolAnalysis(t.symbol, results));

    if(!once) startCountdown(intervalSec);

    // process queue
    while(queue.length && running){
      if(checkSafetyAndMaybePause()) break;

      const job = queue.shift();
      try{ await job(); }
      catch(e){ el.debug.innerText += `\nTask error: ${e.message}`; }

      doneTasks++;
      updateProgress();
      await delay(delayMs);
    }

    // phase classification
    results.forEach(r => {
      r.phase = detectPhaseForSymbol(r);
      r.dropPctFromPeak = r.phase.dropPctFromPeak || 0;
    });

    // return-to-normal
    results.forEach(r => {
      const rtn = detectReturnToNormal(r, { sensitivity: parseInt(el.sensitivity.value,10) || 50 });
      r.returnToNormal = rtn;

      if(rtn.isReturn){
        if(r.phase && r.phase.reasons)
          r.phase.reasons.unshift(`Return-to-normal (${rtn.confidence}%)`);
        else
          r.phase = {phase:'Return-to-normal', confidence:rtn.confidence, reasons:[`Return-to-normal (${rtn.confidence}%)`]};

        r.phase.isReturnToNormal = true;
      }
    });

    /* ----------------------------------------------
       PIPPIN VECTOR (for similarity scoring)
    ---------------------------------------------- */
    let pippinVector = null;
    const pippinEntry = results.find(x => x.symbol === "PIPPINUSDT");

    if(pippinEntry){
      pippinVector = makeFeatureVector(pippinEntry);
    } else {
      try{
        const k4 = await safeFetch(`${API_BASE}/fapi/v1/klines?symbol=PIPPINUSDT&interval=4h&limit=30`,{allowIfNotRunning:true});
        const k15 = await safeFetch(`${API_BASE}/fapi/v1/klines?symbol=PIPPINUSDT&interval=15m&limit=40`,{allowIfNotRunning:true});

        if(k4 && k4.length){
          const closes4 = k4.map(k=>Number(k[4]));
          const last4   = k4[k4.length-1];
          const open4=Number(last4[1]), high4=Number(last4[2]), low4=Number(last4[3]), close4=Number(last4[4]);
          const body4 = Math.max(1e-9, Math.abs(close4 - open4));
          const wick4 = Math.max(0, high4 - Math.max(open4,close4)) / body4;
          const volMA4 = sma(k4.map(k=>Number(k[5])), Math.min(10,k4.length)) || 1;
          const volSpike4 = Number((Number(last4[5]) / volMA4).toFixed(2));
          const ema70 = ema(closes4,70) || ema(closes4,Math.min(21,closes4.length));
          const emaDist = ema70 ? Number(pct(close4,ema70).toFixed(2)) : 0;
          const rsi4 = rsiFromCloses(closes4,14);

          const accum = detectAccumulationGeneric(
            k15.map(k=>Number(k[4])),
            k15.map(k=>Number(k[2])),
            k15.map(k=>Number(k[3])),
            k15.map(k=>Number(k[5])),
            30,
            parseInt(el.sensitivity.value,10)||50
          );

          pippinVector = makeFeatureVector({
            rsi4h:rsi4,
            volSpike4,
            wickRatio4:wick4,
            ema70DistPct:emaDist,
            fundingRate:0,
            slope15:1,
            dropPctFromPeak:0,
            accumCombined:{confidence:accum.confidence, isAccum:accum.isAccum}
          });
        }
      }catch(e){
        pippinVector = null;
      }
    }

    if(pippinVector){
      results.forEach(r => {
        r.similarity = cosineSim(makeFeatureVector(r), pippinVector);
      });
    } else {
      results.forEach(r => r.similarity = 0);
    }

    // blowoff explanation
    results.forEach(r => {
      r.expl = explainBlowoff(r);
      r.finalRec = getFinalRecommendation(r);
      r.shortRec = getShortTermRecommendation(r);
      r.longTargets = getLongTermTargets(r);
    });

    window.lastScanResults = results;

    /* ----------------------------------------------
       SORTING ENGINE
    ---------------------------------------------- */
    function sortValue(r,key){
      if(!r) return 0;

      switch(key){
        case "score": return r.score || 0;
        case "similarity": return r.similarity || 0;
        case "accum": return r.accumCombined?.confidence || 0;
        case "preCrash": return r.preCrash?.confidence || r.preCrash?.score || 0;
        case "rsi4h": return r.rsi4h || 0;
        case "ema70DistPct": return Math.abs(r.ema70DistPct || 0);
        case "last": return r.closeNow || 0;
        case "symbol": return (r.symbol||"").toUpperCase();
        default: return 0;
      }
    }

    const key = el.sortBy.value;
    const descending = (el.sortDir.innerText === "Desc");

    results.sort((a,b)=>{
      const A = sortValue(a,key), B = sortValue(b,key);

      if(key === "symbol"){
        if(A < B) return descending ? 1 : -1;
        if(A > B) return descending ? -1 : 1;
        return 0;
      }

      if(A === B){
        if((b.score||0) !== (a.score||0))
          return (b.score||0) - (a.score||0);
        return (b.similarity||0) - (a.similarity||0);
      }
      
      return descending ? (B - A) : (A - B);
    });

    /* ----------------------------------------------
       RENDER RESULTS
    ---------------------------------------------- */
    if(window.innerWidth >= 680) renderTable(results);
    else renderCards(results);

    updateTradingInterpretation(results);

    /* ----------------------------------------------
       CONDITIONAL ALERT
    ---------------------------------------------- */
    const blowoffThreshold = parseInt(el.threshold.value,10) || 4;
    const accumReq = parseInt(el.accumAlertThreshold.value,10) || 50;

    const blow = results.filter(r=>r.score >= blowoffThreshold);
    const blowAccum = blow.filter(r => r.accumCombined?.confidence >= accumReq);

    if(el.condAlert.checked && blowAccum.length){
      try{
        const audio = new Audio("https://actions.google.com/sounds/v1/alarms/beep_short.ogg");
        audio.volume = 0.8;
        audio.play().catch(()=>{});
      }catch(e){}

      if(Notification.permission === "granted"){
        new Notification("Blowoff + Accum Alert",{
          body: blowAccum.map(x=>`${x.symbol} ${x.accumCombined.confidence}%`).join(", ")
        });
      }
    }

    /* ----------------------------------------------
       AUTO-RESCAN LOGIC
    ---------------------------------------------- */
    if(!once){
      if(requestsThisWindow <= SAFETY_MAX){
        if(autoTimer) clearTimeout(autoTimer);
        autoTimer = setTimeout(()=> runScan(false), intervalSec * 1000);
        startCountdown(intervalSec);
      }
    }

    running = false;
    el.startBtn.disabled = false;
    el.stopBtn.disabled  = true;

  }catch(err){
    el.debug.innerText += `\nRun error: ${err.message}`;
    running = false;
    el.startBtn.disabled = false;
    el.stopBtn.disabled = true;
  }
}


/* ============================================================
   START / STOP / RUN ONCE BUTTONS
============================================================ */
el.startBtn.addEventListener("click", ()=>{
  if(!running) runScan(false);
});

el.stopBtn.addEventListener("click", ()=>{
  running = false;
  queue = [];
  el.startBtn.disabled = false;
  el.stopBtn.disabled = true;

  if(autoTimer) clearTimeout(autoTimer);
  if(countdownTimer) clearInterval(countdownTimer);

  el.countdown.innerText = "Next scan in: -";
  el.message.innerText = "Stopped.";
});

el.oneShot.addEventListener("click", ()=>{
  if(!running) runScan(true);
});

/* Update sensitivity label */
el.sensitivity.addEventListener("input", ()=>{
  el.sensVal.innerText = el.sensitivity.value;
});


/* Request notification permission */
if("Notification" in window){
  Notification.requestPermission().catch(()=>{});
}

/* Initial ping to Binance */
(async function ping(){
  try{ await fetch(API_BASE + "/fapi/v1/ping"); }
  catch(e){ console.warn("Ping fail:",e.message); }
})();

    
/* ============================================================
   SECTION 10 â€” AI RECOMMENDATION ENGINE
   (Long-term, Short-term, Target Generator)
============================================================ */

/* ------------------------------
   1. LONG-TERM TARGET GENERATOR
------------------------------ */
function getLongTermTargets(item){
  const last = item.closeNow || 0;
  if(!last) return null;

  // Generate smooth % levels
  const levelsUp = [
    last * 1.12,
    last * 1.35,
    last * 1.75
  ].map(x=>Number(x.toFixed(6)));

  const safety = [
    last * 0.85,
    last * 0.78,
    last * 0.68
  ].map(x=>Number(x.toFixed(6)));

  // recent high/low detection
  let high = null, low = null;
  if(item.k4h && item.k4h.length){
    const highs = item.k4h.map(k=>Number(k[2]));
    const lows  = item.k4h.map(k=>Number(k[3]));
    high = Math.max(...highs);
    low  = Math.min(...lows);
  }

  return {
    upside: levelsUp,
    safety,
    recentHL: [high, low],
    swingHigh: high
  };
}

/* ------------------------------
   2. LONG-TERM FINAL RECOMMENDATION
------------------------------ */
function getFinalRecommendation(r){
  const phase = (r.phase && r.phase.phase) ? r.phase.phase : "Unknown";
  const accum = r.accumCombined?.confidence || 0;
  const sim = Math.round((r.similarity || 0) * 100);
  const rsi = Math.round(r.rsi4h || 0);
  const funding = Number(r.fundingRate || 0);
  const pre = r.preCrash?.confidence || 0;

  /* ===========================
     RULE-BASED SENIOR AI BRAIN
     =========================== */

  // 1 â€” BLOWOFF / EXTREME RISK
  if(r.expl?.label === "Extreme" || pre >= 70){
    return `Extreme exhaustion detected â€” avoid long-term entries; expect deeper corrective structure unless strong accumulation forms.`;
  }

  // 2 â€” ACCUMULATION (strong)
  if(phase.includes("Accumulation") && accum >= 65){
    return `Strong multi-TF accumulation â€” long-term entries valid using staged position sizing; add only after higher lows confirm on 4H/1D.`;
  }

  // 3 â€” ACCUMULATION but RSI overheated
  if(phase.includes("Accumulation") && accum >= 45 && rsi >= 75){
    return `Accumulation present but RSI overheated â€” wait for a cooldown or dip before building long-term exposure.`;
  }

  // 4 â€” RETURN TO NORMAL (healthy consolidation)
  if(phase.includes("Return")){
    return `Return-to-normal consolidation â€” long-term bullish bias, but require confirmation of a higher low before adding size.`;
  }

  // 5 â€” DISTRIBUTION (bearish)
  if(phase.includes("Distribution")){
    return `Distribution pattern â€” avoid long-term longs; expect fading momentum and potential breakdown unless reclaimed highs appear.`;
  }

  // 6 â€” DEAD-CAT BOUNCE (bearish)
  if(phase.includes("Dead-cat")){
    return `Dead-cat bounce structure â€” avoid long-term buys; expect another leg down before any real reversal.`;
  }

  // 7 â€” BREAKDOWN PHASE
  if(phase.includes("Breakdown")){
    return `Breakdown in progress â€” long-term longs unsafe until structure stabilizes and accumulation reappears.`;
  }

  // 8 â€” HIGH PIPPIN SIMILARITY
  if(sim >= 70){
    return `High similarity to PIPPIN pattern â€” expect volatility and post-blowoff corrective structure; avoid heavy long-term exposure.`;
  }

  // 9 â€” DEFAULT SAFE
  return `No clear long-term signal â€” use small starter size only and add after structural confirmation.`;
}

/* ------------------------------
   3. SHORT-TERM RECOMMENDATION
------------------------------ */
function getShortTermRecommendation(r){
  const rsi15 = Math.round(r.rsi15 || 0);
  const accum = r.accumCombined?.confidence || 0;
  const vol = r.volSpike15 || 1;
  const phase = r.phase?.phase || "Unknown";

  /* SHORT-TERM BIAS */
  if(phase.includes("Breakdown")){
    return {
      bias: "Bearish",
      text: `Short-term bearish â€” momentum weakening; look for rejection entries.`,
      targets: [
        Number((r.closeNow * 0.97).toFixed(6)),
        Number((r.closeNow * 0.95).toFixed(6)),
        Number((r.closeNow * 0.92).toFixed(6)),
      ]
    };
  }

  if(phase.includes("Accumulation") && accum >= 60){
    return {
      bias: "Bullish",
      text: `Short-term bullish bias â€” accumulation active; buy dips with downside protection.`,
      targets: [
        Number((r.closeNow * 1.03).toFixed(6)),
        Number((r.closeNow * 1.06).toFixed(6)),
        Number((r.closeNow * 1.10).toFixed(6)),
      ]
    };
  }

  if(rsi15 >= 80){
    return {
      bias: "Bearish",
      text: `Short-term overbought â€” expect rejection or cool-off.`,
      targets: [
        Number((r.closeNow * 0.982).toFixed(6)),
        Number((r.closeNow * 0.965).toFixed(6)),
        Number((r.closeNow * 0.948).toFixed(6)),
      ]
    };
  }

  if(rsi15 <= 30){
    return {
      bias: "Bullish",
      text: `Short-term oversold â€” expect bounce or mean reversion.`,
      targets: [
        Number((r.closeNow * 1.02).toFixed(6)),
        Number((r.closeNow * 1.04).toFixed(6)),
        Number((r.closeNow * 1.07).toFixed(6)),
      ]
    };
  }

  return {
    bias: "Neutral",
    text: `No clean short-term edge â€” wait for confirmation.`,
    targets: [
      Number((r.closeNow * 0.99).toFixed(6)),
      Number((r.closeNow * 1.01).toFixed(6)),
    ]
  };
}

    
/* ============================================================
   SECTION 11 â€” RENDER ENGINE
   - renderTable()
   - renderCards()
   - helper: phaseColor()
============================================================ */

/* ------------------------------
   Helper: Assign colors by phase
------------------------------ */
function phaseColor(phase){
  if(!phase) return "#9fb3cc";
  const p = phase.toLowerCase();

  if(p.includes("accumulation")) return "#2dd4bf";
  if(p.includes("return")) return "#60a5fa";
  if(p.includes("distribution")) return "#ffd966";
  if(p.includes("breakdown")) return "#ff7b7b";
  if(p.includes("climax") || p.includes("blowoff")) return "#ff4d4d";
  if(p.includes("dead-cat")) return "#ff9d4d";
  if(p.includes("capitulation")) return "#ff3333";

  return "#9fb3cc";
}

/* ------------------------------
   RENDER TABLE (DESKTOP)
------------------------------ */
function renderTable(rows){
  let html = `
    <table>
      <thead>
        <tr>
          <th>Symbol</th>
          <th>Score</th>
          <th>Accum%</th>
          <th>Pre-Crash%</th>
          <th>PIPPIN Sim</th>
          <th>RSI 4H</th>
          <th>EMA Stretch</th>
          <th>Phase</th>
          <th>Price</th>
        </tr>
      </thead>
      <tbody>
  `;

  rows.forEach(r => {
    const accum = r.accumCombined?.confidence || 0;
    const pre = r.preCrash?.confidence || 0;
    const sim = Math.round((r.similarity || 0) * 100);
    const phase = r.phase?.phase || "Unknown";
    const pColor = phaseColor(phase);

    const isBlow = r.score >= (parseInt(el.threshold.value,10)||4);
    const blowTag = isBlow ? `<span class="badge" style="background:#ff4d4d;color:white;font-weight:700">BLOWOFF</span>` : "";

    html += `
      <tr>
        <td><b>${r.symbol}</b> ${blowTag}</td>
        <td style="color:${isBlow ? '#ff4d4d' : '#66f9a1'};font-weight:700">${r.score}</td>
        <td style="color:${accum>=60 ? '#2dd4bf':'#9fb3cc'}">${accum}%</td>
        <td style="color:${pre>=60 ? '#ff7b7b':'#9fb3cc'}">${pre}%</td>
        <td>${sim}%</td>
        <td>${Math.round(r.rsi4h||0)}</td>
        <td>${Math.round(r.ema70DistPct||0)}%</td>
        <td>
          <span class="phaseTag" style="background:${pColor}22;color:${pColor};border:1px solid ${pColor}">${phase}</span>
        </td>
        <td>${r.closeNow?.toFixed(6)}</td>
      </tr>
    `;
  });

  html += `</tbody></table>`;
  el.tableView.innerHTML = html;
  el.cardView.innerHTML = "";
}

/* ------------------------------
   RENDER MOBILE CARDS
------------------------------ */
function renderCards(rows){
  let html = ``;

  rows.forEach(r => {
    const accum = r.accumCombined?.confidence || 0;
    const pre = r.preCrash?.confidence || 0;
    const sim = Math.round((r.similarity || 0) * 100);
    const phase = r.phase?.phase || "Unknown";
    const pColor = phaseColor(phase);
    const price = r.closeNow?.toFixed(6);

    const blow = r.score >= (parseInt(el.threshold.value,10)||4);

    html += `
      <div class="coinCard">
        <div class="coinRow1">
          <div class="coinSymbol">${r.symbol}</div>
          <div class="coinScore" style="color:${blow ? '#ff4d4d':'#66f9a1'}">${r.score}</div>
        </div>

        <div style="margin-top:6px">
          <span class="accBadge">Accum: ${accum}%</span>
          <span class="potBadge" style="background:${pColor}22;color:${pColor};border:1px solid ${pColor}">${phase}</span>
        </div>

        <div class="sigList">
          <div><b>Price:</b> ${price}</div>
          <div><b>RSI 4H:</b> ${Math.round(r.rsi4h||0)}</div>
          <div><b>EMA Stretch:</b> ${Math.round(r.ema70DistPct||0)}%</div>
          <div><b>Pre-Crash:</b> ${pre}%</div>
          <div><b>PIPPIN Sim:</b> ${sim}%</div>
        </div>
      </div>
    `;
  });

  el.cardView.innerHTML = html;
  el.tableView.innerHTML = "";
}

    
/* ============================================================
   SECTION 12 â€” TRADING INTERPRETATION ENGINE
   Builds the big explanation box below the table/cards.
============================================================ */

/* ------------------------------
   Long-Term Target Calculation
------------------------------ */
function getLongTermTargets(item){
  const price = item.closeNow || 0;
  if(!price) return [];

  return [
    (price * 1.12).toFixed(4),
    (price * 1.28).toFixed(4),
    (price * 1.55).toFixed(4),
  ];
}

/* ------------------------------
   Final AI Recommendation
------------------------------ */
function getFinalRecommendation(item){
  const accum = item.accumCombined?.confidence || 0;
  const rsi = item.rsi4h || 0;
  const pre = item.preCrash?.confidence || 0;
  const sim = Math.round((item.similarity || 0) * 100);

  if(accum >= 70 && rsi < 78 && pre < 40){
    return `Bullish Accumulation â€” Consider staged long-term entries (accum ${accum}%, RSI ${Math.round(rsi)})`;
  }

  if(pre >= 65 && rsi >= 80){
    return `High Exhaustion Risk â€” Avoid new longs, wait for breakdown or re-accumulation`;
  }

  if(sim >= 80){
    return `Matches PIPPIN pattern (${sim}%) â€” expect similar structure development`;
  }

  return `Neutral â€” wait for structure confirmation`;
}

/* ------------------------------
   Short-Term Trade Suggestion
------------------------------ */
function getShortTermRecommendation(item){
  const rsi = item.rsi15 || 0;
  const accum = item.accumCombined?.confidence || 0;
  const pre = item.preCrash?.confidence || 0;

  if(pre >= 60){
    return `Short-term bias: Bearish â€” candle exhaustion building, avoid FOMO entries.`;
  }

  if(accum >= 70 && rsi <= 75){
    return `Short-term bias: Bullish â€” early higher-low forming.`;
  }

  return `Short-term bias: Neutral â€” no strong edge.`;
}

/* ------------------------------
   Build the Interpretation Box
------------------------------ */
function buildTradingInterpretation(items){
  if(!items || !items.length) return "";

  const item = items[0]; // single-symbol or top-ranked
  const phase = item.phase?.phase || "Unknown";
  const phaseConf = item.phase?.confidence || 0;
  const phaseColorVal = phaseColor(phase);

  const rtn = item.returnToNormal || {isReturn:false, confidence:0};

  const targets = getLongTermTargets(item);
  const finalRec = item.finalRec || getFinalRecommendation(item);
  const shortRec = item.shortRec || getShortTermRecommendation(item);

  const accum = item.accumCombined?.confidence || 0;
  const pre = item.preCrash?.confidence || 0;

  return `
    <h3 style="color:#8bffc0">Trading Interpretation</h3>

    <p><b style="color:${phaseColorVal}">Phase:</b> ${phase} 
       <span style="color:${phaseColorVal}">(${phaseConf}%)</span></p>

    <p><b>AI Long-Term Outlook:</b> 
       <span style="color:#8bffc0">${finalRec}</span></p>

    <p><b>Short-Term:</b> 
       <span style="color:#ffd966">${shortRec}</span></p>

    <hr style="border-color:#1d2b38;margin:10px 0">

    <p><b>Accumulation:</b> ${accum}%</p>
    <p><b>Pre-Crash Risk:</b> 
       <span style="color:${pre>=60 ? '#ff7b7b' : '#9fb3cc'}">${pre}%</span></p>

    <p><b>Return-to-Normal:</b> 
       ${rtn.isReturn ? `<span style="color:#2dd4bf">YES (${rtn.confidence}%)</span>` : 
                        `<span style="color:#9fb3cc">No clear signal</span>`}</p>

    <hr style="border-color:#1d2b38;margin:10px 0">

    <p><b>Upside Targets:</b></p>
    <ul class="tradeList">
      <li>${targets[0]}</li>
      <li>${targets[1]}</li>
      <li>${targets[2]}</li>
    </ul>

    <p class="mutedNote">Targets are not guarantees â€” they represent statistical extensions from structure.</p>

    <hr style="border-color:#1d2b38;margin:10px 0">

    <p><b>Momentum Notes:</b></p>
    <ul class="tradeList">
      <li>RSI 4H: ${Math.round(item.rsi4h || 0)}</li>
      <li>EMA Stretch: ${Math.round(item.ema70DistPct || 0)}%</li>
      <li>Wick Ratio: ${item.wickRatio4?.toFixed(2)}</li>
      <li>Vol Spike Ã—${item.volSpike4}</li>
    </ul>
  `;
}

/* ------------------------------
   Auto-update interpretation box
------------------------------ */
function updateTradingInterpretation(results){
  if(!results || !results.length){
    el.tradeInterpret.style.display = "none";
    return;
  }

  const boxHTML = buildTradingInterpretation(results);
  el.tradeInterpret.innerHTML = boxHTML;
  el.tradeInterpret.style.display = "block";
}

    
/* ============================================================
   SECTION 13 â€” SORTING ENGINE
   Enables: Sort by score, similarity, accum, rsi, ema, etc.
============================================================ */

/* ------------------------------
   Return value for sort keys
------------------------------ */
function sortingValue(item, key) {
  if(!item) return 0;

  switch(key){

    case "score": 
      return item.score || 0;

    case "similarity":
      return item.similarity || 0;

    case "accum":
      return item.accumCombined?.confidence || 0;

    case "preCrash":
      return item.preCrash?.confidence ||
             item.preCrash?.score || 0;

    case "rsi4h":
      return item.rsi4h || 0;

    case "ema70DistPct":
      return Math.abs(item.ema70DistPct || 0);

    case "last":
      return item.closeNow || 0;

    case "symbol":
      return (item.symbol || "").toUpperCase();

    default:
      return 0;
  }
}

/* ------------------------------
   Sorting function
------------------------------ */
function applySorting(results){
  if(!results || !results.length) return results;

  const key = el.sortBy.value;
  const descending = (el.sortDir.innerText === "Desc");

  results.sort((a, b) => {

    const A = sortingValue(a, key);
    const B = sortingValue(b, key);

    // Alphabetical sorting
    if(key === "symbol"){
      if(A < B) return descending ? 1 : -1;
      if(A > B) return descending ? -1 : 1;
      return 0;
    }

    // Numeric sorting
    if(A === B){
      // Secondary tie-breaker = score
      const sA = a.score || 0;
      const sB = b.score || 0;
      if(sA !== sB) return descending ? (sB - sA) : (sA - sB);

      // Tertiary tie-breaker = similarity
      const simA = a.similarity || 0;
      const simB = b.similarity || 0;
      return descending ? (simB - simA) : (simA - simB);
    }

    // Main comparison
    return descending ? (B - A) : (A - B);
  });

  return results;
}

/* ------------------------------
   Sorting Button Events
------------------------------ */
el.sortDir.addEventListener("click", () => {
  el.sortDir.innerText = 
      (el.sortDir.innerText === "Desc") ? "Asc" : "Desc";

  if(window.lastScanResults){
    const sorted = applySorting(window.lastScanResults);

    if(window.innerWidth >= 680){
      renderTable(sorted);
    } else {
      renderCards(sorted);
    }
  }
});

el.sortBy.addEventListener("change", () => {
  if(window.lastScanResults){
    const sorted = applySorting(window.lastScanResults);

    if(window.innerWidth >= 680){
      renderTable(sorted);
    } else {
      renderCards(sorted);
    }
  }
});

    
/* ============================================================
   SECTION 14 â€” NOTIFICATION & ALERT ENGINE
   Handles: blowoff alerts, conditional alerts, audio alarms,
   browser notifications, and alert throttling.
============================================================ */

/* ------------------------------
   Audio helper
------------------------------ */
function playAlertSound(volume = 0.80) {
  try {
    const audio = new Audio(
      "https://actions.google.com/sounds/v1/alarms/beep_short.ogg"
    );
    audio.volume = volume;
    audio.play().catch(() => {});
  } catch (e) {
    console.warn("Audio error:", e.message);
  }
}

/* ------------------------------
   Browser notification helper
------------------------------ */
function pushNotification(title, body) {
  try {
    if (!("Notification" in window)) return;

    if (Notification.permission === "granted") {
      new Notification(title, { body });
    } else if (Notification.permission !== "denied") {
      Notification.requestPermission();
    }
  } catch (e) {
    console.warn("Notification error:", e.message);
  }
}

/* ------------------------------
   Alert throttling (avoid spam)
------------------------------ */
let lastAlertTime = 0;
const ALERT_COOLDOWN_MS = 6000; // 6 seconds

function canSendAlert() {
  const now = Date.now();
  if (now - lastAlertTime < ALERT_COOLDOWN_MS) return false;
  lastAlertTime = now;
  return true;
}

/* ------------------------------
   Main alert engine
   Called AFTER each scan run
------------------------------ */
function runAlertEngine(results) {
  if (!results || !results.length) return;

  // User settings
  const blowoffThreshold = parseInt(el.threshold.value, 10) || 4;
  const accumThreshold = parseInt(el.accumAlertThreshold.value, 10) || 50;
  const conditionalEnabled = el.condAlert.checked;

  // Filter blowoff candidates
  const blowoffCoins = results.filter(r => r.score >= blowoffThreshold);

  // Conditional mode: Blowoff + High Accumulation
  const blowoffAccum = blowoffCoins.filter(
    r => r.accumCombined?.confidence >= accumThreshold
  );

  // No blowoff at all â†’ no alert
  if (!blowoffCoins.length) return;

  // Alert too recently â†’ skip
  if (!canSendAlert()) return;

  /* --------------------------------------------------
     CASE 1 â€” CONDITIONAL ALERT (Blowoff + Accum â‰¥ X)
  -------------------------------------------------- */
  if (conditionalEnabled) {
    if (blowoffAccum.length) {
      const list = blowoffAccum
        .slice(0, 6)
        .map(r => `${r.symbol} â€¢ Acc ${r.accumCombined.confidence}%`)
        .join(", ");

      // Audio + popup
      playAlertSound(0.90);
      pushNotification("âš  Blowoff + Accum Alert", list);

      console.log("[Alert] Conditional:", list);
    }
    return; // conditional mode ends here
  }

  /* --------------------------------------------------
     CASE 2 â€” NORMAL BLOWOFF ALERT (score â‰¥ threshold)
  -------------------------------------------------- */
  if (blowoffCoins.length) {
    const list = blowoffCoins
      .slice(0, 6)
      .map(r => `${r.symbol} â€¢ Score ${r.score}`)
      .join(", ");

    playAlertSound(0.70);
    pushNotification("ðŸ”¥ Blowoff Detected", list);

    console.log("[Alert] Blowoff-only:", list);
  }
}

/* ============================================================
   Allow browser to ask for notification permission once
============================================================ */
if ("Notification" in window) {
  try {
    Notification.requestPermission().catch(() => {});
  } catch (e) {}
}

    
/* ============================================================
   SECTION 15 â€” AI RECOMMENDATION ENGINE + TARGETS + TRADE PANEL
============================================================ */

/* ------------------------------------------------------------
   Long-Term Targets Generator (Upside + Safety Levels)
------------------------------------------------------------ */
function getLongTermTargets(item) {
  const price = item.closeNow || 0;
  if (!price) return null;

  const swingHigh = item.k4h ? Math.max(...item.k4h.map(k => Number(k[2]))) : price;
  const swingLow  = item.k4h ? Math.min(...item.k4h.map(k => Number(k[3]))) : price;

  // Fibonacci-like projection levels
  const t1 = price * 1.12;   // minor breakout
  const t2 = price * 1.28;   // strong breakout
  const t3 = price * 1.52;   // parabolic extension

  // Safety levels (risk management)
  const s1 = swingLow;
  const s2 = swingLow * 0.93;
  const s3 = swingLow * 0.82;

  return {
    upside: [t1, t2, t3],
    safety: [s1, s2, s3],
    swingHigh,
    swingLow
  };
}

/* ------------------------------------------------------------
   Long-Term AI Recommendation (1 clear sentence)
------------------------------------------------------------ */
function getFinalRecommendation(item) {
  const rsi = item.rsi4h || 50;
  const accum = item.accumCombined?.confidence || 0;
  const sim = Math.round((item.similarity || 0) * 100);
  const phase = item.phase?.phase || "Normal";

  // Logic tree
  if (rsi >= 80 && accum < 50) {
    return "Avoid full long-term positions; only use small starters and add only after confirmed 4H accumulation.";
  }
  if (phase.includes("Distribution") || phase.includes("Breakdown")) {
    return "Trend is weakening â€” wait for confirmation before taking any long-term entries.";
  }
  if (accum >= 70) {
    return "High accumulation detected â€” long-term accumulation entries are favorable on dips.";
  }
  if (sim >= 70 && accum >= 60) {
    return "PIPPIN-like re-accumulation forming â€” consider staggered long-term entries.";
  }
  return "No strong long-term signal yet â€” wait for structure to form (4H higher low or rising volume).";
}

/* ------------------------------------------------------------
   SHORT-TERM TRADING RECOMMENDATION (scalp logic)
------------------------------------------------------------ */
function getShortTermRecommendation(item) {
  const rsi = item.rsi15 || 50;
  const accum = item.accumCombined?.confidence || 0;
  const phase = item.phase?.phase || "";
  const price = item.closeNow || 0;

  // Short-term targets
  const t1 = price * 0.97;
  const t2 = price * 0.95;
  const t3 = price * 0.91;

  if (rsi >= 80) {
    return {
      bias: "Bearish",
      text: "Short-term overbought â€” shorting the bounce or waiting for a lower re-entry is safer.",
      targets: [t1, t2, t3]
    };
  }

  if (phase.includes("Distribution") || phase.includes("Breakdown")) {
    return {
      bias: "Bearish",
      text: "Distribution signal active â€” expect weakness; avoid chasing longs.",
      targets: [t1, t2, t3]
    };
  }

  if (accum >= 65 && rsi < 75) {
    return {
      bias: "Bullish",
      text: "Short-term accumulation present â€” long entries possible on pullback (15m higher low).",
      targets: [price * 1.02, price * 1.05, price * 1.09]
    };
  }

  return {
    bias: "Neutral",
    text: "No clean short-term edge â€” wait for either a rejection or a higher low structure.",
    targets: [t1, t2, t3]
  };
}

/* ------------------------------------------------------------
   Trading Interpretation Panel Builder
------------------------------------------------------------ */
function buildTradingInterpretation(results) {
  if (!results || !results.length) return "";

  let out = "";
  results.forEach(r => {
    const lt = getLongTermTargets(r);
    const st = getShortTermRecommendation(r);
    const rec = getFinalRecommendation(r);

    out += `
      <div style="margin-bottom:22px;padding:14px;border-bottom:1px solid #1a2638">
        <div style="font-size:17px;font-weight:700;color:#7bdcff">${r.symbol}</div>

        <div class="finalRec">ðŸ§  Long-Term Recommendation:
          <br>${rec}
        </div>

        <div class="shortRec" style="margin-top:10px">
          ðŸ”Ž Short-Term (${st.bias}):
          <br>${st.text}
        </div>

        <div style="margin-top:6px;color:#ffd966">
          ðŸŽ¯ Short-Term Targets: 
          ${st.targets.map(x => x.toFixed(4)).join(" â€¢ ")}
        </div>

        <div style="margin-top:12px;color:#8bffc0">
          ðŸ“ˆ Long-Term Upside:
          ${lt.upside.map(x => x.toFixed(4)).join(" â€¢ ")}
        </div>

        <div style="margin-top:6px;color:#ff8f8f">
          ðŸ›¡ Safety Levels:
          ${lt.safety.map(x => x.toFixed(4)).join(" â€¢ ")}
        </div>

        <div style="margin-top:8px;font-size:12px;color:#9fb3cc">
          Swing High: ${lt.swingHigh.toFixed(4)} â€¢ Swing Low: ${lt.swingLow.toFixed(4)}
        </div>
      </div>
    `;
  });

  return out;
}

/* ------------------------------------------------------------
   Renderer (injects trade interpretation panel)
------------------------------------------------------------ */
function updateTradingInterpretation(results) {
  try {
    const html = buildTradingInterpretation(results);
    el.tradeInterpret.innerHTML = html;
    el.tradeInterpret.style.display = "block";
  } catch (e) {
    console.log("Interpretation error:", e);
  }
}

    
/* ============================================================
   SECTION 16 â€” TABLE VIEW & CARD VIEW RENDERING ENGINE
============================================================ */

/* ------------------------------------------------------------
   Helper: Color based on numeric value
------------------------------------------------------------ */
function colorize(val) {
  if (val >= 70) return '<span style="color:#66ffb2">' + val + '%</span>';
  if (val >= 50) return '<span style="color:#ffd966">' + val + '%</span>';
  return '<span style="color:#ff7b7b">' + val + '%</span>';
}

/* ------------------------------------------------------------
   TABLE RENDERER (Desktop View)
------------------------------------------------------------ */
function renderTable(list) {
  if (!list || !list.length) {
    el.tableView.innerHTML = "<div>No data.</div>";
    return;
  }

  let html = `
    <table>
      <thead>
        <tr>
          <th>Symbol</th>
          <th>Score</th>
          <th>PIPPIN Sim</th>
          <th>Accum</th>
          <th>Phase</th>
          <th>RSI 4H</th>
          <th>Wick</th>
          <th>Vol</th>
          <th>EMA Dist%</th>
          <th>Funding</th>
          <th>Final AI Rec</th>
        </tr>
      </thead>
      <tbody>
  `;

  list.forEach(r => {
    const accum = r.accumCombined?.confidence ?? 0;
    const simPct = Math.round((r.similarity || 0) * 100);

    html += `
      <tr>
        <td><strong>${r.symbol}</strong></td>
        <td>${r.score}</td>
        <td>${colorize(simPct)}</td>
        <td>${colorize(accum)}</td>

        <td>
          <span class="phaseTag" style="background:#0f2430;color:#8bffc0;">
            ${r.phase?.phase || "Normal"}
          </span>
        </td>

        <td style="color:${r.rsi4h >= 80 ? '#ff7b7b' : '#cfe8ff'}">
          ${r.rsi4h?.toFixed(1) || "-"}
        </td>

        <td>${r.wickRatio4?.toFixed(2) || "-"}</td>
        <td>${r.volSpike4?.toFixed(2) || "-"}</td>
        <td>${r.ema70DistPct?.toFixed(1) || "-"}</td>

        <td style="color:${r.fundingRate < 0 ? '#ff957a' : '#66ffb2'}">
          ${(r.fundingRate*100).toFixed(4)}%
        </td>

        <td class="small" style="color:#8bffc0">
          ${r.finalRec}
        </td>
      </tr>
    `;
  });

  html += `</tbody></table>`;
  el.tableView.innerHTML = html;
}

/* ------------------------------------------------------------
   CARD RENDERER (Mobile View)
------------------------------------------------------------ */
function renderCards(list) {
  if (!list || !list.length) {
    el.cardView.innerHTML = "<div>No data.</div>";
    return;
  }

  let html = "";

  list.forEach(r => {
    const accum = r.accumCombined?.confidence ?? 0;
    const simPct = Math.round((r.similarity || 0) * 100);

    html += `
      <div class="coinCard">
        <div class="coinRow1">
          <div class="coinSymbol">${r.symbol}</div>
          <div class="coinScore">Score: ${r.score}</div>
        </div>

        <div style="margin-top:6px">
          <span class="accBadge">Accum: ${accum}%</span>
          <span class="potBadge">Sim: ${simPct}%</span>
        </div>

        <div class="sigList">
          <div>Phase: <strong style="color:#8bffc0">${r.phase?.phase || "Normal"}</strong></div>
          <div>RSI 4H: ${r.rsi4h?.toFixed(1) || "-"}</div>
          <div>Wick: ${r.wickRatio4?.toFixed(2) || "-"}</div>
          <div>Vol Spike: ${r.volSpike4?.toFixed(2) || "-"}</div>
          <div>EMA Dist: ${r.ema70DistPct?.toFixed(1) || "-"}</div>
          <div>Funding: ${(r.fundingRate*100).toFixed(4)}%</div>
        </div>

        <div class="recBox">
          <div class="finalRec">
            ðŸ§  ${r.finalRec}
          </div>

          <div class="shortRec">
            ðŸ”Ž Short-Term (${r.shortRec?.bias || "Neutral"}):
            <br>${r.shortRec?.text || ""}
          </div>

          <div class="small" style="margin-top:6px;color:#ffd966;">
            ðŸŽ¯ ST Targets:
            ${r.shortRec?.targets?.map(x => x.toFixed(4)).join(" â€¢ ")}
          </div>

          <div class="small" style="margin-top:6px;color:#8bffc0;">
            ðŸ“ˆ Upside:
            ${r.longTargets?.upside?.map(x => x.toFixed(4)).join(" â€¢ ")}
          </div>

          <div class="small" style="margin-top:6px;color:#ff8f8f;">
            ðŸ›¡ Safety:
            ${r.longTargets?.safety?.map(x => x.toFixed(4)).join(" â€¢ ")}
          </div>
        </div>
      </div>
    `;
  });

  el.cardView.innerHTML = html;
}

    
/* ============================================================
   SECTION 17 â€” MAIN SCAN ENGINE + EVENT WIRING
============================================================ */

let running = false;
let autoTimer = null;
let countdownTimer = null;

let queue = [];
let totalTasks = 0;
let doneTasks = 0;

let requestsThisWindow = 0;
let windowStart = Date.now();
const WINDOW_MS = 60000;
const LIMIT_PER_MINUTE = 900;
const SAFETY_PAUSE_SEC = 30;

function resetWindow() {
  requestsThisWindow = 0;
  windowStart = Date.now();
}

/* Update progress bar + message --------------------------------- */
function updateProgress() {
  const pct = totalTasks ? Math.round((doneTasks / totalTasks) * 100) : 0;
  el.bar.style.width = pct + "%";
  el.message.innerText = `Scanning ${doneTasks}/${totalTasks} (${pct}%)`;
}

/* Countdown for next autoscan ---------------------------------- */
function startCountdown(sec) {
  if (countdownTimer) clearInterval(countdownTimer);
  const end = Date.now() + sec * 1000;

  countdownTimer = setInterval(() => {
    let left = Math.max(0, Math.round((end - Date.now()) / 1000));
    el.countdown.innerText = `Next scan in: ${left}s`;
    if (left <= 0) {
      clearInterval(countdownTimer);
      el.countdown.innerText = "Running...";
    }
  }, 500);
}

/* --- Rate-limit safety ----------------------------------------- */
function checkSafety() {
  const now = Date.now();
  if (now - windowStart > WINDOW_MS) {
    resetWindow();
    el.safetyStatus.innerText = "Safety OK";
    return false;
  }

  if (requestsThisWindow > LIMIT_PER_MINUTE) {
    running = false;
    el.safetyStatus.innerText = `Auto-paused (${requestsThisWindow} req/min)`;
    el.message.innerText = `Pausing ${SAFETY_PAUSE_SEC}s to avoid rate limits`;

    setTimeout(() => {
      resetWindow();
      el.message.innerText = "Resuming...";
      el.safetyStatus.innerText = "Safety OK";
      el.startBtn.disabled = false;
      el.stopBtn.disabled = true;
    }, SAFETY_PAUSE_SEC * 1000);

    return true;
  }

  el.safetyStatus.innerText = `Req/min: ${requestsThisWindow}`;
  return false;
}

/* ============================================================
   MAIN SCAN LOOP
============================================================ */

async function runScan(runOnce = false) {
  try {
    running = true;
    el.startBtn.disabled = true;
    el.stopBtn.disabled = false;

    resetWindow();
    el.message.innerText = "Fetching top symbols...";

    const topN = Math.min(60, Math.max(5, Number(el.prefilter.value)));
    const delayMs = Math.min(2000, Math.max(50, Number(el.delay.value)));
    const intervalSec = Math.min(3600, Math.max(10, Number(el.interval.value)));

    const top = await getTopN(topN);

    queue = [];
    totalTasks = top.length;
    doneTasks = 0;
    updateProgress();

    const results = [];

    // queue analysis tasks
    top.forEach(t => {
      queue.push(() => analyzeSymbol(t.symbol).then(res => results.push(res)));
    });

    if (!runOnce) startCountdown(intervalSec);

    // execute tasks sequentially with delay
    while (queue.length && running) {
      if (checkSafety()) break;
      await queue.shift()();
      doneTasks++;
      updateProgress();
      await delay(delayMs);
    }

    if (!running) return;

    // Sort before render
    applySorting(results);

    // Render desktop/table or mobile/cards
    if (window.innerWidth >= 680) {
      renderTable(results);
    } else {
      renderCards(results);
    }

    // Show trading interpretation summary at bottom
    updateTradingInterpretation(results);

    // Handle alerts
    handleAlerts(results);

    // Save results globally for similarity + search
    window.lastScanResults = results;

    // Setup next autoscan
    if (!runOnce) {
      autoTimer = setTimeout(() => {
        if (requestsThisWindow <= LIMIT_PER_MINUTE) runScan(false);
      }, intervalSec * 1000);
    }

    running = false;
    el.startBtn.disabled = false;
    el.stopBtn.disabled = true;

  } catch (err) {
    el.debug.innerText += "\nScan error: " + err.message;
    running = false;
    el.startBtn.disabled = false;
    el.stopBtn.disabled = true;
  }
}

/* ============================================================
   SORTING
============================================================ */
function applySorting(list) {
  const key = el.sortBy.value;
  let desc = el.sortDir.innerText === "Desc";

  function get(r) {
    switch (key) {
      case "score": return r.score;
      case "similarity": return r.similarity;
      case "accum": return r.accumCombined?.confidence ?? 0;
      case "preCrash": return r.preCrash?.confidence ?? 0;
      case "rsi4h": return r.rsi4h ?? 0;
      case "ema70DistPct": return Math.abs(r.ema70DistPct ?? 0);
      case "last": return r.closeNow ?? 0;
      case "symbol": return r.symbol;
    }
  }

  list.sort((a, b) => {
    let A = get(a), B = get(b);

    if (key === "symbol") {
      return desc ? B.localeCompare(A) : A.localeCompare(B);
    }
    return desc ? (B - A) : (A - B);
  });
}

/* Toggle sort direction */
el.sortDir.addEventListener("click", () => {
  el.sortDir.innerText = el.sortDir.innerText === "Desc" ? "Asc" : "Desc";
  if (window.lastScanResults) {
    applySorting(window.lastScanResults);
    renderTable(window.lastScanResults);
  }
});

/* ============================================================
   ALERT LOGIC
============================================================ */
function handleAlerts(results) {
  const blowScore = Number(el.threshold.value);
  const accumMin = Number(el.accumAlertThreshold.value);
  const condEnabled = el.condAlert.checked;

  const blowoffList = results.filter(r => r.score >= blowScore);
  const blowoffAccum = blowoffList.filter(r =>
    (r.accumCombined?.confidence ?? 0) >= accumMin
  );

  if (!condEnabled && blowoffList.length) playAlert(blowoffList);
  if (condEnabled && blowoffAccum.length) playAlert(blowoffAccum);
}

/* Play notification sound + browser notification */
function playAlert(arr) {
  try {
    const audio = new Audio(
      "https://actions.google.com/sounds/v1/alarms/beep_short.ogg"
    );
    audio.volume = 0.8;
    audio.play().catch(() => {});
  } catch {}

  if ("Notification" in window) {
    if (Notification.permission === "granted") {
      new Notification("Alert", {
        body: arr.map(x => x.symbol).join(", ")
      });
    } else if (Notification.permission !== "denied") {
      Notification.requestPermission();
    }
  }
}

/* ============================================================
   UI EVENT WIRING
============================================================ */

el.startBtn.addEventListener("click", () => {
  if (!running) runScan(false);
});

el.stopBtn.addEventListener("click", () => {
  running = false;
  el.stopBtn.disabled = true;
  el.startBtn.disabled = false;
  if (autoTimer) clearTimeout(autoTimer);
  if (countdownTimer) clearInterval(countdownTimer);
  el.countdown.innerText = "Next scan in: -";
  el.message.innerText = "Stopped.";
});

el.oneShot.addEventListener("click", () => {
  if (!running) runScan(true);
});

// Sensitivity dynamic update
el.sensitivity.addEventListener("input", () => {
  el.sensVal.innerText = el.sensitivity.value;
});

// Allow browsing notifications
if ("Notification" in window) {
  try { Notification.requestPermission(); } catch {}
}

// Test ping to warm connection
(async () => {
  try { await fetch(API_BASE + "/fapi/v1/ping"); } catch {}
})();
    <script>

    <!-- ============================================================
   SECTION 18 â€” Footer, License, Packaging & Debugging Tips
   Place this at the end of your single-file HTML (before </body>)
   ============================================================ -->

<footer class="small" style="margin-top:18px">
  <div style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;">
    <div style="flex:1">
      <strong>Blowoff Top Detector</strong> â€” Multi-TF accumulation detector,
      pre-crash detection, PIPPIN similarity, and conditional alerts.
    </div>

    <div style="font-size:12px;color:var(--muted);">
      <span title="Version">v1.0</span>
      &nbsp;â€¢&nbsp;
      <span title="Author">You (Var)</span>
      &nbsp;â€¢&nbsp;
      <span title="License">MIT</span>
    </div>
  </div>

  <div style="margin-top:6px;color:var(--muted);font-size:12px">
    Notes: Run from a local server (recommended) to avoid CORS issues:
    <code style="background:#071722;padding:4px;border-radius:6px">python -m http.server 8000</code>
    â€” then open <code>http://localhost:8000/</code>.
  </div>
</footer>

<!-- ============================================================
   LICENSE (MIT) â€” short form (keep in-file for single-file distribution)
   ============================================================ -->
<!--
MIT License

Copyright (c) 2025 Var

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction...

(Full license text may be added here if desired)
-->

<!-- ============================================================
   PACKAGING & ZIP (HOW-TO)
   ============================================================ -->
<!--
1) Single-file HTML:
   - Keep everything (HTML, CSS, JS) in one .html file (you already are).
   - Minify if desired with tools like html-minifier for production.

2) Create a zip (macOS / Linux):
   - Open terminal in folder containing file:
     zip blowoff-detector-v1.zip blowoff-detector.html

   Windows (PowerShell):
     Compress-Archive -Path "blowoff-detector.html" -DestinationPath "blowoff-detector-v1.zip"

3) Serve locally (dev):
   python -m http.server 8000
   open http://localhost:8000/blowoff-detector.html

4) Deploy (static hosting):
   - Netlify / Vercel / GitHub Pages: push repo (single file OK)
   - Ensure CORS: frontend uses Binance public REST; avoid client-side secrets.
-->

<!-- ============================================================
   DEBUGGING CHECKLIST (color-coded quick guide)
   ============================================================ -->
<!--
ðŸŸ¢ Green (Network OK)
  - Ping: fetch(API_BASE + '/fapi/v1/ping') passes
  - Browser console shows no 4xx/5xx for klines/funding endpoints

ðŸŸ¡ Yellow (Safety / Rate-limit)
  - If "Auto-paused" message appears, increase delay or reduce prefilter.
  - Check requestsThisWindow and windowStart in code.

ðŸ”´ Red (Not running / renderTable undefined)
  - Ensure renderTable, renderCards, getLongTermTargets, getFinalRecommendation, getShortTermRecommendation,
    buildTradingInterpretation, updateTradingInterpretation are defined before Section 17 (main engine).
  - If browser console error: "renderTable is not defined" â€” confirm the function exists (search the file).
  - Functions must be in global scope (not inside a block) so Section 17 can call them.

Common fixes:
  - Move SECTION 17 and SECTION 18 to bottom so helpers exist when run.
  - Ensure no duplicate `const el = { ... }` declarations â€” only one wiring object.
  - Use `safeFetch(..., { allowIfNotRunning: true })` if you need symbol analyze while scanner stopped.
-->

<!-- ============================================================
   SIMPLE MAINTENANCE NOTES
   ============================================================ -->
<!--
- To add a new TF, implement kline fetch + accumulation detector and add control checkbox.
- To persist user watchlist: use localStorage (key: blowoff_watchlist) and re-run analysis on saved symbols.
- To debug faster: set el.delay.value = 50 during development and temporarily lower SAFETY_MAX.
- When sharing, remove any hard-coded API keys (none in current design).
-->

  </body>
</html>
