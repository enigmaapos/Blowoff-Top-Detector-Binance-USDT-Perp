<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Blowoff Top Detector — Binance USDT-Perp (Top 20) — Blacklist Enabled</title>
<style>
  :root{--bg:#07101a;--card:#0b1220;--muted:#9fb3cc;--accent:#2dd4bf;--danger:#ff7b7b}
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:#e6eef8; margin:16px}
  .card{background:var(--card); border:1px solid #172033; padding:14px; border-radius:10px; box-shadow:0 6px 20px rgba(0,0,0,.6)}
  h1{margin:0;font-size:18px}
  .controls{display:flex;flex-wrap:wrap;gap:10px;margin-top:12px;align-items:center}
  label{font-size:13px;color:var(--muted)}
  input,select{background:#071722;border:1px solid #243241;color:#e6eef8;padding:6px;border-radius:6px}
  button{background:#1f6feb;border:none;color:white;padding:8px 10px;border-radius:6px;cursor:pointer}
  button.alt{background:#2b3947}
  .status{margin-top:8px;color:var(--muted);font-size:13px}
  .progress{height:8px;background:#05101a;border-radius:4px;margin-top:8px;overflow:hidden}
  .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#60a5fa);width:0%}
  table{width:100%;border-collapse:collapse;margin-top:12px;font-size:13px}
  th,td{padding:8px 10px;border-bottom:1px dashed #122331;text-align:left}
  th{color:var(--muted);font-size:12px}
  .green{color:#66f9a1}
  .red{color:var(--danger)}
  .small{font-size:12px;color:var(--muted)}
  .badge{display:inline-block;padding:4px 8px;border-radius:12px;background:#0f2430;color:#bfeee1;font-size:12px}
  pre{background:#041223;padding:8px;border-radius:6px;overflow:auto;color:#cfe8ff}
  footer{margin-top:12px;color:var(--muted);font-size:12px}
</style>
</head>
<body>
<div class="card">
  <h1>Blowoff Top Detector — Binance USDT-Perp (Top 20) — Blacklist Enabled</h1>
  <div class="small" style="margin-top:6px;color:var(--muted)">Auto scans top N futures by 24h change and evaluates blow-off top signals (RSI, wick, volume, funding, EMAs). Uses rate limiter — tune delay and interval below.</div>

  <div class="controls">
    <label>Prefilter (top by 24h) <input id="prefilter" type="number" value="20" min="5" max="100"/></label>
    <label>Delay (ms) <input id="delay" type="number" value="400" min="50" max="2000"/></label>
    <label>Auto update (sec) <input id="interval" type="number" value="60" min="10" max="3600"/></label>
    <label>Score threshold <input id="threshold" type="number" value="3" min="1" max="6"/></label>
    <button id="startBtn">Start</button>
    <button id="stopBtn" class="alt" disabled>Stop</button>
    <button id="oneShot" class="alt">Run Once</button>
  </div>

  <div class="status">
    <div id="message">Ready. Recommended: run via local server to avoid CORS (e.g. python -m http.server).</div>
    <div class="progress"><i id="bar"></i></div>
  </div>

  <div id="tableArea"></div>
  <div id="debug" style="margin-top:10px;color:var(--muted);font-size:12px"></div>
</div>

<footer class="small">
  Notes: This tool is for research/alerts only. Tune delay to be safe. If you get CORS errors, use a local static server.
</footer>

<script>
/* Blowoff Top Detector for Binance USDT-Perp (with blacklist)
   - Prefilter top N by 24h change (default 20)
   - For each symbol fetch klines (1d, 4h, 15m), funding, and compute indicators:
     * 1D RSI, 4H RSI
     * Volume spike (4H last volume vs MA10)
     * Wick ratio (4H latest candle)
     * EMA14/EMA70 distance on 4H
     * Lower-high detection on 4H
     * Latest funding rate (most recent)
   - Scoring: each positive condition => +1. Flag if score >= threshold.
   - Rate-limited queue with configurable delay.
   - Blacklist: symbols in the blacklist array are ignored in prefilter.
*/

const API_BASE = 'https://fapi.binance.com';

// ---------- USER BLACKLIST ----------
const blacklist = [
  "ALPACAUSDT","BNXUSDT","ALPHAUSDT","OCEANUSDT","DGBUSDT",
  "AGIXUSDT","LINAUSDT","LOKAUSDT","KEYUSDT","MDTUSDT",
  "LOOMUSDT","RENUSDT","OMNIUSDT","SLERFUSDT","STMXUSDT",
  "UXLINKUSDT","BSWUSDT","NEIROETHUSDT","VIDTUSDT","TROYUSDT",
  "BAKEUSDT","AMBUSDT","MEMEFIUSDT","NULSUSDT","HIFIUSDT",
  "LEVERUSDT","XEMUSDT","STRAXUSDT","COMBOUSDT"
];
// ------------------------------------

const el = {
  prefilter: document.getElementById('prefilter'),
  delay: document.getElementById('delay'),
  interval: document.getElementById('interval'),
  threshold: document.getElementById('threshold'),
  startBtn: document.getElementById('startBtn'),
  stopBtn: document.getElementById('stopBtn'),
  oneShot: document.getElementById('oneShot'),
  message: document.getElementById('message'),
  bar: document.getElementById('bar'),
  tableArea: document.getElementById('tableArea'),
  debug: document.getElementById('debug'),
};

let running = false;
let queue = [];
let totalTasks = 0, doneTasks = 0;
let autoTimer = null;

function safeFetch(url){
  return fetch(url).then(r=>{
    if(!r.ok) throw new Error('HTTP '+r.status);
    return r.json();
  });
}

// Simple indicators
function sma(values, n){
  if(values.length < n) return null;
  let sum = 0;
  for(let i=values.length-n;i<values.length;i++) sum += values[i];
  return sum/n;
}
function ema(values, period){
  if(!values || values.length === 0) return null;
  // simple EMA seed with first value
  const k = 2/(period+1);
  let emaVal = values[0];
  for(let i=1;i<values.length;i++){
    emaVal = values[i]*k + emaVal*(1-k);
  }
  return emaVal;
}
function rsiFromCloses(closes, period=14){
  if(!closes || closes.length <= period) return null;
  let gains=0, losses=0;
  for(let i=closes.length-period;i<closes.length;i++){
    const diff = closes[i] - closes[i-1];
    if(diff>0) gains += diff; else losses += Math.abs(diff);
  }
  const avgGain = gains/period;
  const avgLoss = losses/period;
  if(avgLoss===0) return 100;
  const rs = avgGain/avgLoss;
  return 100 - (100/(1+rs));
}
function pct(a,b){ if(b===0) return 0; return ((a-b)/b)*100; }

// Queue processor (rate-limited)
async function processQueue(delay){
  while(queue.length && running){
    const job = queue.shift();
    try{ await job(); } catch(e){ console.warn('job error', e); }
    doneTasks++;
    updateProgress();
    await new Promise(r=>setTimeout(r, delay));
  }
  // finished
  running=false;
  el.startBtn.disabled=false; el.stopBtn.disabled=true;
  el.message.innerText = 'Scan complete.';
}

// Build candidate list (top N by 24h change) excluding blacklist
async function getTop24N(n){
  const tickers = await safeFetch(API_BASE + '/fapi/v1/ticker/24hr');
  const usdt = tickers.filter(t => t.symbol.endsWith('USDT') && !blacklist.includes(t.symbol));
  usdt.sort((a,b)=> parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent));
  return usdt.slice(0,n).map(x=>({symbol:x.symbol,priceChangePercent:parseFloat(x.priceChangePercent),lastPrice:parseFloat(x.lastPrice)}));
}

// For a symbol compute signals
function queueSymbolAnalysis(symbol, results){
  queue.push(async ()=>{
    try{
      // klines: 1d limit=9, 4h limit=20, 15m limit=40
      const [k1d, k4h, k15m, fundingArr] = await Promise.all([
        safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=1d&limit=9`),
        safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=4h&limit=20`),
        safeFetch(`${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=15m&limit=40`),
        safeFetch(`${API_BASE}/fapi/v1/fundingRate?symbol=${symbol}&limit=1`)
      ]);

      const closes1d = k1d.map(k=>parseFloat(k[4]));
      const closes4h = k4h.map(k=>parseFloat(k[4]));
      const vols4h = k4h.map(k=>parseFloat(k[5]));
      const closes15m = k15m.map(k=>parseFloat(k[4]));
      const last4h = k4h[k4h.length-1];
      const prev4h = k4h[k4h.length-2];
      const fundingRate = (fundingArr && fundingArr.length)? parseFloat(fundingArr[0].fundingRate) : 0;

      const rsi1d = rsiFromCloses(closes1d, 14);
      const rsi4h = rsiFromCloses(closes4h, 14);
      const volMA4h = sma(vols4h, Math.min(10, vols4h.length));
      const volSpike = volMA4h ? (parseFloat(last4h[5]) / volMA4h) : 1;

      // Wick/top ratio
      const open4 = parseFloat(last4h[1]), high4 = parseFloat(last4h[2]);
      const low4 = parseFloat(last4h[3]), close4 = parseFloat(last4h[4]);
      const body = Math.abs(close4 - open4) || 0.0000001;
      const wickTop = high4 - Math.max(open4, close4);
      const wickTopRatio = wickTop / body;

      // EMA distance: use closes4h (if not enough values, fallback)
      const ema14 = ema(closes4h.slice(Math.max(0, closes4h.length-14)), 14);
      const ema70 = ema(closes4h.slice(Math.max(0, closes4h.length-70)), 70);
      const closeNow = closes4h[closes4h.length-1];
      const ema70DistPct = ema70 ? pct(closeNow, ema70) : 0;

      // lower high detection: compare last high to previous 4h high
      const prevHigh = parseFloat(prev4h[2]);
      const lastHigh = high4;
      const lowerHigh = lastHigh < prevHigh;

      // slope proxy: closeNow / close 3 bars ago
      const ratioSlope = closes4h.length>3 ? closeNow / closes4h[closes4h.length-4] : 1;

      // Score rules (default thresholds; tune in code if you wish)
      let score = 0;
      const signals = {};
      if(rsi1d !== null && rsi1d >= 88){ score++; signals.rsi1d = true; } // slightly higher for 1D
if(rsi4h !== null && rsi4h >= 80){ score++; signals.rsi4h=true; }
if(volSpike >= 1.8){ score++; signals.volSpike=true; } // easier to trigger
if(wickTopRatio >= 1.2){ score++; signals.wickTop=true; }
if(ema70DistPct >= 50){ score++; signals.emaDist=true; } // price 50% above ema70
if(lowerHigh){ score++; signals.lowerHigh=true; }
// extra: treat negative funding as confirmation
if(fundingRate < -0.0005){ score++; signals.fundingConfirm = true; }
signals.funding = fundingRate;

      results.push({
        symbol,
        rsi1d, rsi4h,
        volSpike: Number(volSpike.toFixed(2)),
        wickTopRatio: Number(wickTopRatio.toFixed(2)),
        ema70DistPct: Number(ema70DistPct.toFixed(2)),
        lowerHigh,
        fundingRate,
        score,
        closeNow,
        ratioSlope: Number(ratioSlope.toFixed(2))
      });
    } catch(err){
      el.debug.innerText += `\nError for ${symbol}: ${err.message}`;
    }
  });
}

// Render results
function renderResults(results){
  results.sort((a,b)=> (b.score - a.score) || (b.ema70DistPct - a.ema70DistPct) || (b.volSpike - a.volSpike));
  const threshold = parseInt(el.threshold.value,10) || 3;
  const rows = results.map(r=>{
    const flag = r.score >= threshold ? `<span class="badge">FLAG ${r.score}</span>` : `<span class="small">${r.score}</span>`;
    return `<tr>
      <td><strong>${r.symbol}</strong> ${flag}</td>
      <td>${r.closeNow}</td>
      <td class="${r.rsi4h>=80?'green':''}">${r.rsi4h? r.rsi4h.toFixed(1):'n/a'}</td>
      <td class="small">volRatio:${r.volSpike} wickTop:${r.wickTopRatio} emaDist:${r.ema70DistPct}%</td>
      <td class="small">fund:${r.fundingRate}</td>
    </tr>`;
  }).join('');
  el.tableArea.innerHTML = `<div class="card"><table>
    <thead><tr><th>Symbol</th><th>Last</th><th>4H RSI</th><th class="small">Signals</th><th class="small">Funding</th></tr></thead>
    <tbody>${rows}</tbody>
  </table></div>`;
}

// Update progress
function updateProgress(){
  const pctDone = totalTasks ? Math.round((doneTasks/totalTasks)*100) : 0;
  el.bar.style.width = pctDone + '%';
  el.message.innerText = `Scanning ${doneTasks}/${totalTasks} (${pctDone}%) — delay ${el.delay.value}ms — threshold ${el.threshold.value}`;
}

// Main run
async function runScan(once=false){
  try{
    el.debug.innerText = '';
    el.startBtn.disabled=true;
    el.stopBtn.disabled=false;
    running = true;
    const prefilter = Math.max(5, Math.min(100, parseInt(el.prefilter.value,10) || 20));
    const delayMs = Math.max(50, Math.min(2000, parseInt(el.delay.value,10) || 400));

    el.message.innerText = 'Fetching top symbols by 24h change (blacklist applied)...';
    const top = await getTop24N(prefilter);
    const symbols = top.map(t=>t.symbol);

    queue = [];
    totalTasks = symbols.length;
    doneTasks = 0;
    updateProgress();
    const results = [];

    for(const s of symbols){
      queueSymbolAnalysis(s, results);
    }
    processQueue(delayMs).then(()=>{
      renderResults(results);
    });
  } catch(e){
    el.debug.innerText += '\nError run: ' + e.message;
  }
}

// UI events
el.startBtn.addEventListener('click', ()=>{
  if(running) return;
  runScan(false);
  const secs = Math.max(10, Math.min(3600, parseInt(el.interval.value,10) || 60));
  autoTimer = setInterval(()=>{ if(!running) runScan(false); }, secs*1000);
});
el.stopBtn.addEventListener('click', ()=>{
  running=false;
  queue = [];
  el.startBtn.disabled=false;
  el.stopBtn.disabled=true;
  if(autoTimer) { clearInterval(autoTimer); autoTimer=null; }
  el.message.innerText = 'Stopped.';
});
el.oneShot.addEventListener('click', ()=>{ if(!running) runScan(true); });

// helper: fetch top N by 24h (blacklist applied)
async function getTop24N(n){
  const tickers = await safeFetch(API_BASE + '/fapi/v1/ticker/24hr');
  const usdt = tickers.filter(t => t.symbol.endsWith('USDT') && !blacklist.includes(t.symbol));
  usdt.sort((a,b)=> parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent));
  return usdt.slice(0,n).map(x=>({symbol:x.symbol,priceChangePercent:parseFloat(x.priceChangePercent),lastPrice:parseFloat(x.lastPrice)}));
}

// quick ping to detect CORS
(async function ping(){
  try {
    await fetch(API_BASE + '/fapi/v1/ping');
  } catch(e){
    console.warn('ping failed (CORS?)', e);
  }
})();
</script>
</body>
</html>
